[ { "title": "[개발일지] 3일차 개발일지 - 기획시작 2", "url": "/posts/Day3/", "categories": "개발일지, Unity", "tags": "unity, c#", "date": "2022-12-08 11:10:30 +0900", "snippet": "개발일지 3일차오늘은 어제 생각했던 것들을 구체화 해보려한다.원래는 기획서를 바로 작성하면서 해볼까 했엇지만 기획서 작성경험도 전무하고 태그를 나열한것만으로 막 거창하게 작성을 할 수가 없어보인다.천천히 꼼꼼하게 만들어보자는 생각으로 최대한 정리를 해보고 다듬어 가봐야겠다.구체화 작업Excel을 이용하여 문서화를 하려고 한다." }, { "title": "[개발일지] 2일차 개발일지 - 기획시작 1", "url": "/posts/Day2/", "categories": "개발일지, Unity", "tags": "unity, c#", "date": "2022-12-07 23:11:30 +0900", "snippet": "개발일지 2일차오늘은 기초적인 기획틀을 짜보려고한다.게임 컨셉게임 컨셉으로는 벰파이어 서바이벌을 레퍼런스로 하여 만들어 볼 계획이다.장르로그라이크, 2D, RPG, 핵앤슬래시시점탑뷰(Top view)시스템UI/UX메인, 게임 진행, 설정 등등 화면조작Touch(Mobile 환경), Keyboard(PC 환경)유저HP, MP, EXP, SKILL(일단 프로토타입 개발후 추후 생각)몬스터HP, MP, BOSS, ITEM DROP전투ITEM, EXP, Demage, Death하루 마무리오늘은 기획부분에서 크게크게 보면서 틀만 잡는 식으로 진행하였다.생각을 하고 더 생각을 할수록 깊게만 생각하게 되고 이런식으로 하다간 토대를 제대로 못잡겠다.문서화를 진행을 하면서 추가해야할 부분들이 생각난다면 여기다가 추가적으로 적어야겠다." }, { "title": "[개발일지] 1일차 개발일지 작성시작", "url": "/posts/Day1/", "categories": "개발일지, Unity", "tags": "unity, c#", "date": "2022-12-06 23:11:30 +0900", "snippet": "오늘부터 Unity 개발일지를써보려고 한다.1일차에는 내가 이것을 왜 하려고 하는지(목적), 무엇을 이제 해야하는지(계획) 정리를 해볼까 한다.1. 목적하나지금까지 Unity를 이용하여 1인 개발을 하기에 앞서 각각의 필요한 기능들을 구글링해가며 구동해보고 개별적인 코드를 공부를 해왔으나..메인보드 고장으로 인하여 지금까지의 기록들이 사라졌다.이로 인하여 백업의 중요성을 깨닫게 되었다.둘게임 개발 프로세스를 보면 기획 - 개발 - 테스트 - 유지보수로 볼수있다. (Agile)나는 모든 프로젝트는 기획이 제일 중요하다고 보는 편이다.토대가 제대로 잡혀있어야지 개발도 수월하게 진행이 된다고 생각한다.이전 회사를 다녔을땐 개발건이 들어오면 거의다 완성이 되면 수정건이 너무많이 발생하여 개발이 제 날짜에 맞춰진적이 없거나 아예 break가 걸린 경우가 많았다.기간은 기간대로 날아가고 좀 많이 안 좋은 경험들을 하다보니 기획부분이 얼마나 중요한지 깨닫게 되었다.셋dcinside 인디게임개발 갤러리의 개발일지 탭을 보면서 '다른사람들은 이런식으로 기록을 하는구나.. 이게 1인 개발이라고? 다들 멋지다 나도 해볼까?'도 생각을 해보았지만 커뮤니티보단 개인 블로그에 작성하는것이 관리하기도 쉽고 내가 접근하기도 쉽다 생각하여 이곳에 작성을 할 예정이다.근데 진짜 이곳에서 다른사람들이 '개발일지 #n OO기능 개발/수정 중' 식의 글을 보다보면 동기부여가 되어 더욱더 재밌고 도움이 많이 되는것같다.2. 계획위에 말한것처럼 프로세스는 기획 - 개발 - 테스트 - 유지보수로 이루어져있으니, 기획부터 진행을 할것이다.아래의 계획은 현재 개발일지를 시작하기에 앞서 무엇들이 존재하고 무엇을 해야하는지 대강 정리를 해본것이다.기획현재 기획 계획에는 4가지만 생각중이다.컨셉 기획 -시스템 기획 -레벨 디자인 -밸런싱 -기획하면서 지금까지 기획 공부 했던것들을 다시 보면서 추가 기획해야하는 부분들이 존재하면 추가해서 기획을 할예정이다.개발개발 계획에는 2가지가 생각난다.기능개발최적화테스트주변 지인들에게 테스트를 맡겨 볼까한다.유지보수게임 출시이후 버그 및 문제점 파악후 유지보수3. 프로그램 정보기획Excel &amp; PPT프로그래밍Unity디자인사서 사용할지 그려서 할지 모르겠음" }, { "title": "[C++] Chapter.9 연산자 오버로딩", "url": "/posts/Cpp-Ch9/", "categories": "Language, C++", "tags": "c++", "date": "2022-09-24 22:20:19 +0900", "snippet": "산술 연산자 오버로딩 하기// 산술 연산자 오버로딩 하기#include &lt;iostream&gt;using namespace std ;class Cents{private: int m_cents; public: Cents(int cents = 0) { m_cents = cents; } int getCents() const { return m_cents; } int&amp; getCents() { return m_cents; } //class 내부함수로 구현 Cents operator +(const Cents&amp; c2) { return Cents(this-&gt;m_cents + c2.m_cents); } //멤버 함수로 바꾸는경우 파라미터 오류가 발생한다. //c1을 this로 교체 해야한다. //member로만 해야하는 연산자가 존재한다. //=, [], (), -&gt;};void add(const Cents&amp; c1, const Cents&amp; c2, Cents&amp; c_out ){ c_out.getCents() = c1.getCents() + c2.getCents();}Cents add(const Cents&amp; c1, const Cents&amp; c2){ return Cents(c1.getCents() + c2.getCents());}//getCent를 쓰는것이 귀찮을때 class에 병합하면 된다.//Cents operator +(const Cents&amp; c1, const Cents&amp; c2)//{// return Cents(c1.getCents() + c2.getCents());//}int main() { //기본 자료형에는 기본 산술 연산자(+, -, /, *, %)를 사용하는것을 알고있다. //사용자 정의 자료형에서도 산술 연산자를 만들어서 사용할 수 있다. Cents cents1(6); Cents cents2(8); //연산값 결과 instance Cents sum; //지금까지 배운것으로는 cents1, cents2 두개를 연산을 하고싶은경우 함수를 만드는것 밖에 없다. add(cents1, cents2, sum); cout &lt;&lt; sum.getCents() &lt;&lt; endl; //함수의 반환형을 cents로 만들수도 있다. cout &lt;&lt; add(cents1, cents2).getCents() &lt;&lt; endl; //이렇게 함수로 만들면 기본자료형에서 산술연산자를 사용한것보다 복잡해진다. //함수 이름을 operator + 로 바꾸면 연산자만 사용해서 출력이 가능하다. cout &lt;&lt; (cents1 + cents2).getCents() &lt;&lt; endl; //+말고 - * / % 다 가능하지만 //안되는 연산자가 있다. ?: :: sizeof . .* //연산자오버로딩을 해도 연산자 우선순위는 바뀌지 않는다. //수학시간에 배운 직관적인것들만 오버로딩 하는것이 좋다. //위험한 코드보다 불편한 코드가 좋다. //+함수가 Cents를 반환하는데 class 밖에 잇는것이 보기 불편하므로 class 내부함수로 만들어 줄수있다. return 0;}입출력 연산자 오버로딩 하기// 입출력 연산자 오버로딩 하기#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;class Point{private: double m_x, m_y, m_z; public: Point(double x = 0.0, double y = 0.0, double z = 0.0) :m_x(x), m_y(y), m_z(z) {} double getx() { return m_x; } double gety() { return m_y; } double getz() { return m_z; } void print() { cout &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \", \" &lt;&lt; m_z &lt;&lt; endl; } //멤버 함수로 만들수없는 이유 - out 파라미터가 ostream이므로 멤버 함수로 만들수가없다. //out 구현 friend ostream&amp; operator &lt;&lt; (ostream &amp;out, const Point &amp;point) { cout &lt;&lt; \"(\" &lt;&lt; point.m_x &lt;&lt; \", \" &lt;&lt; point.m_y &lt;&lt; \", \" &lt;&lt; point.m_z &lt;&lt; \")\"; return out; //chaining하기 위해 리턴값을 가지고온다. } //in 구현 friend istream&amp; operator &gt;&gt; (istream &amp;in, Point &amp;point) { in &gt;&gt; point.m_x &gt;&gt; point.m_y &gt;&gt; point.m_z; return in; //chaining하기 위해 리턴값을 가지고온다. }};int main() { //이번에는 입출력 연산자를 오버로딩 하는방법에 대해 알아보자 //좌표 출력예제 사용 //x,y,z 좌표를 표시하기 위해 Point class를 만들었다. //좌표 출력을 하기위해 지금까지 배운방법으로는 print함수를 만들어 좌표를 찍었을것이다. Point p1(0.0, 0.1, 0.2), p2(10, 1, 40); p1.print(); // &lt;&lt;오버로딩을 사용하면 이렇게 구현이 가능하다 cout &lt;&lt; p1 &lt;&lt; \" \" &lt;&lt; p2 &lt;&lt; endl; // ostream으로 만들면 파일출력도 같은 함수로 만들수있다. // ofstream of(\"out.txt\"); //파일명 입력 // of &lt;&lt; p1 &lt;&lt; \" \" &lt;&lt; p2 &lt;&lt; endl; //파일 출력 내용 입력 // of.close(); Point p3, p4; cin &gt;&gt; p3 &gt;&gt; p4; cout &lt;&lt; p3 &lt;&lt; \" \" &lt;&lt; p4 &lt;&lt; endl; return 0;}단항 연산자 오버로딩 하기// 단항 연산자 오버로딩 하기#include &lt;iostream&gt;using namespace std;class Cents{private: int m_cents; public: Cents(int cents = 0) { m_cents = cents; } int getCents() const { return m_cents; } int&amp; getCents() { return m_cents; } Cents operator - () const { return Cents(-m_cents); } bool operator ! () const { // !연산자 오버로딩은 조건을 생각하고 해야한다. //돈이 있으면 true 돈이없으면 false로 두고싶다 return (m_cents == 0 ) ? false : true; } friend ostream&amp; operator &lt;&lt; (ostream &amp;out, const Cents &amp;cents) { cout &lt;&lt; cents.m_cents; return out; }};int main() { //이번시간엔 단항 연산자 오버로딩에 대해 알아보자 Cents cents1(6); Cents cents2(0); //단항연산자 //+3, -3, !a cout &lt;&lt; cents1 &lt;&lt; endl; //6 cout &lt;&lt; -cents1 &lt;&lt; endl; //-6 cout &lt;&lt; -Cents(10) &lt;&lt; endl; //-10 cout &lt;&lt; -Cents(-10) &lt;&lt; endl; //10 auto temp = !cents1; auto temp2 = cents1; cout &lt;&lt; !cents1 &lt;&lt; \" \" &lt;&lt; !cents2 &lt;&lt; endl; //1 0 출력 cents1은 돈이있으니 true인 1인 값 출력, cents2는 돈이없으니 false인 0값 출력 return 0;}비교 연산자 오버로딩 하기// 비교 연산자 오버로딩 하기#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;random&gt;using namespace std;class Cents{private: int m_cents; public: Cents(int cents = 0) { m_cents = cents; } int getCents() const { return m_cents; } int&amp; getCents() { return m_cents; } friend bool operator == (const Cents &amp;c1, const Cents &amp;c2) { return c1.m_cents == c2.m_cents; } //이걸 만들면 sort에서 오류가 발생한다. friend bool operator &gt; (const Cents &amp;c1, const Cents &amp;c2) { return c1.m_cents &gt; c2.m_cents; } //sort는 오른쪽이 작은지를 비교하는 연산자를 이용한다. friend bool operator &lt; (const Cents &amp;c1, const Cents &amp;c2) { return c1.m_cents &lt; c2.m_cents; } friend ostream&amp; operator &lt;&lt; (ostream &amp;out, const Cents &amp;cents) { cout &lt;&lt; cents.m_cents; return out; }};int main() { //이번엔 비교 연산자 오버로딩에 대해 알아보자 //if문 안에, sort사용시 크기 비교 등등에서 사용한다. Cents cents1(6); Cents cents2(6); cout &lt;&lt; boolalpha; if(cents1 == cents2) cout &lt;&lt; \"Equal\" &lt;&lt; endl; vector&lt;Cents&gt; vec(20); for (unsigned i = 0; i &lt; 20; ++i) { vec[i].getCents() = i; } random_device rd; mt19937 g(rd()); shuffle(vec.begin(), vec.end(), g); for (auto &amp;e : vec){ cout &lt;&lt; e &lt;&lt; \" \"; } cout &lt;&lt; endl; //그냥 실행하면 에러발생 //에러 원인 Cents는 크기비교가 불가능하므로 sort를 진행할수가없다. sort(begin(vec), end(vec)); for (auto &amp;e : vec){ cout &lt;&lt; e &lt;&lt; \" \"; } cout &lt;&lt; endl; return 0;}증감 연산자 오버로딩 하기//증감 연산자 오버로딩하기#include &lt;iostream&gt;using namespace std;class Digit{private: int m_digit; public: Digit(int digit = 0) { m_digit = digit; } //prefix Digit &amp; operator ++ () { ++m_digit; return *this; } //postfix 파라미터로 더미값이 들어간다. Digit operator ++ (int) { //현재값 저장 변수 Digit temp(m_digit); ++(*this); return temp; } Digit &amp; operator -- () { --m_digit; return *this; } //postfix 파라미터로 더미값이 들어간다. Digit operator -- (int) { //현재값 저장 변수 Digit temp(m_digit); --(*this); return temp; } friend ostream&amp; operator &lt;&lt; (ostream &amp;out, const Digit &amp;digit) { cout &lt;&lt; digit.m_digit; return out; }};int main() { //이번엔 증감 연산자 오버로딩에 대해 알아보자 //전위 먼저 계산후 출력 //후위 출력후 계산 Digit d(5); cout &lt;&lt; ++d &lt;&lt; endl; //1증가한 6출력 cout &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; d++ &lt;&lt; endl; //증가안함 cout &lt;&lt; d &lt;&lt; endl; //증가된 7 출력 cout &lt;&lt; --d &lt;&lt; endl; //1감소된 6출력 cout &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; d-- &lt;&lt; endl; //감소안함 cout &lt;&lt; d &lt;&lt; endl; //5출력 return 0;}첨자 연산자 오버로딩 하기// 첨자 연산자 오버로딩 하기#include &lt;iostream&gt;#include &lt;cassert&gt;using namespace std;class IntList{private: int m_list[10] = {1,2,3,4,5,6,7,8,9,10}; public: int &amp; operator [] (const int idx) { //assert로 방어코드를 사용하는것이 좋다. //많이 사용하기위해 만드는것이르모 방어적인 코드를 짜는것이 좋다. assert(idx &gt;= 0); assert(idx &lt; 0); return m_list[idx]; } const int &amp; operator [] (const int idx) const { return m_list[idx]; } void setItem(int idx, int val) { m_list[idx] = val; } int getItem(int idx) { return m_list[idx]; } int * getList() { return m_list; }};int main() { //이번엔 첨자 연산자 오버로딩에 대해 알아보자 //[] subscrpit operator //일반적인 배열 클래스 출력 방법 IntList my_list; my_list.setItem(3, 1); cout &lt;&lt; my_list.getItem(3) &lt;&lt; endl; my_list.getList()[3] = 10; cout &lt;&lt; my_list.getList()[3] &lt;&lt; endl; //set하랴 get하랴 힘들다 ()[]가 있는것도 불편하고 vector,array처럼 사용하기 위해 []연산자를 오버로딩 한다. IntList my_list2; my_list2[3] = 10; cout &lt;&lt; my_list2[3] &lt;&lt; endl; //const 자료형은 cosnt 오버로딩을 하여 처리 가능하다. const IntList my_list3; cout &lt;&lt; my_list3[1] &lt;&lt; endl; //주의사항 //포인터 사용시 IntList *list = new IntList; list[3] = 10; //오류 발생 (*list)[3] = 10; //작동된다. return 0;}괄호 연산자 오버로딩과 함수 객체// 괄호 연산자 오버로딩과 함수객체#include &lt;iostream&gt;using namespace std;class Accumulator{private: int m_counter = 0; public: int operator () (int i) { return (m_counter += i); }};int main() { //이번에는 괄호 연산자 오버로딩을 알아보자 //괄호 연산자는 함수에서 사용하므로 괄호 연산자를 오버로딩을 하면 객체가 함수인것처럼 구현을할 수 있다. //첨자와 오버로딩하고 거의 비슷하다. Accumulator acc; cout &lt;&lt; acc(10) &lt;&lt; endl; //0에서 10을 더함 cout &lt;&lt; acc(20) &lt;&lt; endl; //10인 상태에서 20을 더함 return 0;}형변환을 오버로딩 하기//형변환을 오버로딩 하기#include &lt;iostream&gt;using namespace std;class Cents{private: int m_cents; public: Cents(int cents = 0) { m_cents = cents; } int getCents() const { return m_cents; } void setCents(int cents) { m_cents = cents; } operator int() { cout &lt;&lt; \"casting\" &lt;&lt; endl; return m_cents; }};class Doller{private: int m_doller = 0;public: Doller(const int&amp; input) : m_doller(input) {} operator Cents() { //1Doller = 100Cents return Cents(m_doller * 100); }};void printInt(const int &amp;val){ cout &lt;&lt; val &lt;&lt; endl;}int main() { //이번에는 형변환 오버로딩을 알아보자 Cents cents(7); printInt(cents); //일반적으로 Cents는 int가 아니므로 자료형 오류가 발생한다. //이것과 같은 방식이다. int val = (int)cents; cout &lt;&lt; val &lt;&lt; endl; //자료형 끼리도 형변환 하는것을 만들수있다. Doller dol(2); Cents cents2 = dol; printInt(cents2); return 0;}복사 생성자, 복사 초기화 반환값 최적화//복사 생성자, 복사 초기화 반환값 최적화// return value Optimization RVO#include &lt;iostream&gt;#include &lt;cassert&gt;using namespace std;//분수 클래스class Fraction{private: int m_numerator; int m_denominator; public: Fraction(int num = 0, int den = 1) : m_numerator(num), m_denominator(den) { //분모가 0이 아닐때 작동 방지 assert(den != 0); } //복사 생성자 copy constructor //자기 자신과 똑같은 타입이 들어오는 생성자 Fraction(const Fraction &amp;fraction) : m_numerator(fraction.m_numerator), m_denominator(fraction.m_denominator) { cout &lt;&lt; \"Copy constructor called\" &lt;&lt; endl; } friend ostream &amp; operator &lt;&lt; (ostream &amp;out, const Fraction &amp;f) { cout &lt;&lt; f.m_numerator &lt;&lt; \" / \" &lt;&lt; f.m_denominator &lt;&lt; endl; return out; } };Fraction doSomrting(){ Fraction temp(1,2); cout &lt;&lt; &amp;temp &lt;&lt; endl; return temp;}int main() { //이번에는 복사 생성자, 복사 초기화 RVO에 대해 알아보자 Fraction frac(3, 5); Fraction fr_copy = frac; cout &lt;&lt; frac &lt;&lt; \" \" &lt;&lt; fr_copy &lt;&lt; endl; //경우에 따라 복사하는것을 막아 버리고싶을때가 있다. //이럴때는 복사하는곳을 private에 옮기면 된다. 보안성 문제를 유의할때 사용한다. //익명객체로 만들어서 넣는경우 복사생성자가 호출되지 않는다. Fraction fr_copy2(Fraction(3,10)); //Fraction fr_copy2(3,10);처럼 작동한다. Fraction result = doSomrting(); cout &lt;&lt; &amp;result &lt;&lt; endl; cout &lt;&lt; result &lt;&lt; endl; //디버그모드 복사생성자 출력 //릴리즈모드 복사생성자 미출력 //반환값 최적화라고 한다. RVO return 0;}변환 생성자, explicit, delete// 변환 생성자, explicit, delete// converting constructor#include &lt;iostream&gt;using namespace std;//분수 클래스class Fraction{private: int m_numerator; int m_denominator; public: Fraction(char) = delete; Fraction(int num = 0, int den = 1) : m_numerator(num), m_denominator(den) { assert(den != 0); } Fraction(const Fraction &amp;fraction) : m_numerator(fraction.m_numerator), m_denominator(fraction.m_denominator) { cout &lt;&lt; \"Copy constructor called\" &lt;&lt; endl; } friend ostream &amp; operator &lt;&lt; (ostream &amp;out, const Fraction &amp;f) { cout &lt;&lt; f.m_numerator &lt;&lt; \" / \" &lt;&lt; f.m_denominator &lt;&lt; endl; return out; } };void doSomrting(Fraction frac){ cout &lt;&lt; frac &lt;&lt; endl;}int main() { //이번에는 변환 생성자에 대해 알아보자 explicit, delete 키워드도 알아보자 Fraction frac(7); doSomrting(Fraction(7)); //그냥 숫자만 넣어도 정상적으로 작동한다.// doSomrting(7); //converting constructor //explicit 키워드를 생성자 앞에 넣어주면 오류를 발생시킨다. //생성자 파라미터를 똑바로 넣어라 라고 //delete를 사용하는 방법 //변환 생성자의 자료형 종류를 제한할수있다. //Fraction(char) = delete; //char형은 넣지말아라 라고 하는것이다. Fraction frac23('a'); //char형을 막아 놧으므로 오류발생 Fraction frac22(1); return 0;}대입 연산자 오버로딩, 깊은 복사, 얕은 복사// 대입 연산자 오버로딩, 깊은복사, 얕은 복사// Deep copy Shallow copy#include &lt;iostream&gt;#include &lt;cassert&gt;using namespace std;class MyString{public: char *m_data = nullptr; int m_length = 0; public: MyString(const char *source = \"\") { assert(source); m_length = strlen(source) + 1; m_data = new char[m_length]; for (int i = 0; i &lt; m_length; ++i) { m_data[i] = source[i]; } m_data[m_length - 1] = '\\0'; } MyString(const MyString &amp;source) { cout &lt;&lt; &amp;source &lt;&lt; endl; cout &lt;&lt; \"Copy Constructor\" &lt;&lt; endl; m_length = source.m_length; //메모리를 가지고있는경우 메모리를 새로 할당 받는 코드 if(source.m_data != nullptr) { m_data = new char[m_length]; for (int i = 0; i &lt; m_length; ++i) { m_data[i] = source.m_data[i]; } } //메모리를 가지고있지 않으면 널 포인터로 처리 else m_data = nullptr; } //얕은복사 //기본 생성자의 경우 //메모리를 새로 할당하지않고 m_data, m_length 자체를 복사해준것이다. //이런것을 얕은 복사라고 한다. //깊은복사 //메모리를새로 할당하고 m_data의 주소값은 복사를 하지않고 객체의 데이터만 복사를하는것이다. //이런것을 깊은 복사라고 한다. MyString&amp; operator = (const MyString &amp;source) { /* Shallow copy this-&gt;m_data = source.m_data; this-&gt;m_length = source.m_length; */ cout &lt;&lt; \"Assignment operator\" &lt;&lt; endl; if(this == &amp;source) //prevent self-assignment return *this; //자기 자신을 대입을 하는경우 진행을 막기위한 코드 delete [] m_data; //이미 대입받는 부분에 메모리 할당을 없애는 부분 m_length = source.m_length; if(source.m_data != nullptr) { m_data = new char[m_length]; for (int i = 0; i &lt; m_length; ++i) { m_data[i] = source.m_data[i]; } } else m_data = nullptr; return *this; } ~MyString() { delete [] m_data; } char* getString() { return m_data; } int getLength() { return m_length; }};int main() { //이번에는 대입 생성자에 대해 알아보자 //깊은 복사, 얕은 복사하는 방법에 대해 알아보자 //동적할당된 메모리에 대한 포인터를 멤버로 가지고 잇는 클래스의 경우에 복사 대입 시 깊은복사인지 얕은복사인지에 따라 대입연산자 구현이 까다로워진다. MyString hello(\"Hello\"); cout &lt;&lt; (int*)hello.m_data &lt;&lt; endl; cout &lt;&lt; hello.getString() &lt;&lt; endl; { MyString copy = hello; //copy가 hello를 복사 하는 코드 / 복사 생성자를 복사하는 코드 //copy가 생성이 되고있으면 복사 생성자로 작동 - 여기에 해당한다. //copy = hello인 경우에는 대입으로 작동한다. //복사 생성자가 없는경우 기본 복사생성자가 작동한다. //복사 생성자 역할 = 변수를 복사해준다. cout &lt;&lt; (int*)copy.m_data &lt;&lt; endl; cout &lt;&lt; copy.getString() &lt;&lt; endl; } cout &lt;&lt; hello.getString() &lt;&lt; endl; //생성자 소멸자만 있는경우 쓰레기값 오류가 발생한다. //원인 //copy할때 hello의 주소를 복사만 한것을 가져온것이다. //copy와 hello는 같은 주소를 가지고있는것이다. //copy영역에서 벗어나면서 소멸자가 실행이 되어 copy의 주소가 사라지게 된다. //근데 그전에 뭐라고 말했었나? copy는 hello의 주소를 복사한것이라고 //hello와 copy의 주소가같은데 copy의 주소를 삭제했다? //hello의 주소도 같이 사라질것이다. //그래서 hello의 주소가 존재하지않는데 hello에 접근하려고 하여 쓰레기값이 출력이 되는것이다. //동적 할당을 사용하는 경우에는 복사 생성자나 대입연산자를 오버로딩할때 주의해야한다. //use Assignment operator MyString str2; str2 = hello; //차이점 MyString str3 = hello; //Copy Constructor MyString str4; str4 = hello; //Assignment operator //헷갈림 방지 MyString str5(hello); //MyString str5 = hello; //가끔 복사 생성자를 구분하기 애매한경우 //Shallow copy를 막는 방법 //기본 복사 생성자를 막는것이 존재한다. //MyString(const MyString &amp;source) = delete; //임시방법이지 복사 생성자를 구현하는것이 좋다. return 0;} 이니셜라이져 리스트 initializer list// 이니셜라이저 리스트// initializer_list#include &lt;iostream&gt;#include &lt;cassert&gt;#include &lt;initializer_list&gt;using namespace std;class IntArray{private: unsigned m_length = 0; int *m_data = nullptr; public: IntArray(unsigned length) : m_length(length) { m_data = new int[length]; } IntArray(const initializer_list&lt;int&gt; &amp;list) : IntArray(list.size()) { int count = 0; for (auto &amp;e : list) { m_data[count] = e; ++count; } // for (unsigned count = 0; count &lt; list.size(); ++count) {// m_data[count] = list[count];// } //오류 발생원인 //initializer_list는 [] 연산자를 제공하지않아 사용하지못한다. } IntArray() ~IntArray() { delete [] this-&gt;m_data; } friend ostream &amp; operator &lt;&lt; (ostream &amp;out, IntArray &amp; arr) { for (unsigned int i = 0; i &lt; arr.m_length; ++i) { out &lt;&lt; arr.m_data[i] &lt;&lt; \" \"; } out &lt;&lt; endl; return out; } };int main() { //이번에는 이니셜라이저 리스트를 알아보자 //사용자 정의 자료형에서 생성자나 대입 연산자를 만들때 편하게 만들기 위해 사용하는 방법이다. int arr1[5] ={1,2,3,4,5}; int *arr2 = new int[5]{1,2,3,4,5}; auto il = {10,20,30}; IntArray int_arr {1,2,3,4,5}; //initializer_list 생성자 없으면 오류 발생 cout &lt;&lt; int_arr &lt;&lt; endl; //initializer_list 생성자 구현시 = 연산자 오버로딩도 같이 구현하는것이 좋다. initializer_list&lt;int&gt; test; test = int_arr return 0;}" }, { "title": "[C++] Chapter.8 객체지향의 기초", "url": "/posts/Cpp-Ch8/", "categories": "Language, C++", "tags": "c++", "date": "2022-09-24 22:20:19 +0900", "snippet": "객체지향 프로그래밍과 클래스// 객체지향 프로그래밍과 클래스// Object Oriented Programming#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;//Friend 출력 함수void printfri(const string &amp;name, const string &amp;address, const int &amp;age, const double &amp;height ,const double &amp;weight){ cout &lt;&lt; name &lt;&lt; \", \" &lt;&lt; address &lt;&lt; \", \" &lt;&lt; age &lt;&lt; \", \" &lt;&lt; height &lt;&lt; \", \" &lt;&lt; weight &lt;&lt; endl;}struct Friend{ string name; string address; int age; double height; double weight; //구조체 안에도 함수를 만들수있다. void printfri() { cout &lt;&lt; name &lt;&lt; \", \" &lt;&lt; address &lt;&lt; \", \" &lt;&lt; age &lt;&lt; \", \" &lt;&lt; height &lt;&lt; \", \" &lt;&lt; weight &lt;&lt; endl; } };//기능구현을 붙여주는경우 struct가 아닌 class로 만들어주는것이 일반적이다.//struct는 데이터를 묶어줄때만 사용하는것이 일반적이다.class Friend2{//class에서는 접근제어자를 사용한다.public: //access specifier 접근제어자 (public, private, protected) string name; string address; int age; double height; double weight; void printfri() { cout &lt;&lt; name &lt;&lt; \", \" &lt;&lt; address &lt;&lt; \", \" &lt;&lt; age &lt;&lt; \", \" &lt;&lt; height &lt;&lt; \", \" &lt;&lt; weight &lt;&lt; endl; } };//구조체를 이용한 함수void printfri(const Friend &amp;fri){ cout &lt;&lt; fri.name &lt;&lt; \", \" &lt;&lt; fri.address &lt;&lt; \", \" &lt;&lt; fri.age &lt;&lt; \", \" &lt;&lt; fri.height &lt;&lt; \", \" &lt;&lt; fri.weight &lt;&lt; endl; //fri.이 일일히 붙이는것도 피곤하다.}int main() { //이번 부터 객체 지향에서 대해서 공부해보자! //오늘부터 객체 지향이 왜 필요하고 좋은지 알아보자 //Friend : name, address, age, height, weight //친구에 대한 프로그래밍을 짠다고 가정을해보자 //해당 정보에 대한 변수화 시키는 작업 string name; string address; int age; double height; double weight; // printfri(name, address, age, height, weight); //여러명의 친구들을 가지고 프로그래밍을 하기 위해 벡터를 사용한다. vector&lt;string&gt; vec_name; vector&lt;string&gt; vec_address; vector&lt;int&gt; vec_age; vector&lt;double&gt; vec_height; vector&lt;double&gt; vec_weight; // printfri(vec_name[0], vec_address[0], vec_age[0], vec_height[0], vec_weight[0]); //함수의 파라미터가 vec가 아니므로 0번째 인덱스 값으로 예시로 만들었다. //제대로된 프로그램을 만들기 위해선 코드의 양이 점점 많아진다. //구조체화 Friend fri{\"Lee\", \"Seoul\", 17, 10.0, 20.0}; printfri(fri.name, fri.address, fri.age, fri.height, fri.weight); //이런식으로 만들게 되면 다른 사람이 추가가 되는경우 //또 다른 구조체를 만들어 출력을 해주어야한다. //불편하게 된다. //함수 파라미터를 구조체로 바꾸어 만들면 좀더 간결해진다. printfri(fri); //fri.를 없애기 위해 구조체 내부 함수 사용 fri.printfri(); //Object //Date , Function이 묶여잇는 구조 //friend 데이터, printfri() 함수 등등 //Class //Object를 구현하는 부분 //위에를 다시보면 Friend를 사용자 정의 자료형처럼 사용하고있다. //Friend를 정의하는것만으로는 메모리를 차지하지않는다. //struct안의 내용, class안의 내용을 구현한다고해서 메모리를 차지하지않는다. //Friend fri;처럼 선언을 해주어야지 실제로 메모리가 소모가 된다. //실제로 메모리를 차지하도록 정의하는것 = instanciation //변수 fri를 class의 instance라고 부른다. //변수 fri의 주소는 찍어볼수있지만, 구조체,클래스인 Friend의 주소는 찍어볼수없다. 왜냐? fri는 메모리 주소가 할당이 되어있고 Friend의 메모리 주소는 할당이 안되어있으니까 // cout &lt;&lt; &amp;Friend &lt;&lt; endl; cout &lt;&lt; &amp;fri &lt;&lt; endl; //여러명인 경우를 다시 생각해보자 //벡터의 자료형을 구조체,클래스로 만들어주면 된다. vector&lt;Friend&gt; my_friends; my_friends.resize(2); my_friends[0].printfri(); //친구들이 엄청 많은경우 반복문을 이용하여 출력이 가능하다. for (auto &amp;element : my_friends) element.printfri(); //구조체, 클래스 안에있는 데이터들은 멤버라고 부른다고 앞에서 말한적이있다. //대부분 협업에서는 멤버 변수앞에 m_를 붙여 멤버 변수라고 한눈에 알아보기 쉽게 표시를 해준다. //물론 회사마다 다를수 도있다. //struct와 class의 차이 //접근제어자 유무? return 0;}캡슐화, 접근지정자, 접근함수// 캡슐화, 접근지정자, 접근함수// Encapsulation// Access Specifiers// Access Functions#include &lt;iostream&gt;using namespace std;//날짜에 대한 Date classclass Date{//public: //Access specifier 접근 지정자 접근지정자가없는경우 기본값이 private로 지정이 된다. int m_month; int m_day; int m_year; public: void setDate(const int&amp; month, const int&amp; day, const int&amp; year) { m_month = month; m_day = day; m_year = year; } //setDate함수는 public, 멤버변수는 private이지만, 같은 클래스안에 있으면 public에 있는함수에서도 private멤버변수에 접근가능하다. void setMonth(const int&amp; month) { m_month = month; } void setDay(const int&amp; day) { m_day = day; } void setYear(const int&amp; year) { m_year = year; } //main에서 m_month에 접근이 불가능하므로 m_month값을 사용할수있게 가져오는 함수이다. int getMonth() { return m_month; } const int&amp; getDay() { return m_day; } //레퍼런스로 return할수도 있지만 get함수에서 멤버 변수값을 변경하지 못하도록 const int&amp;를 사용해준다. void copyFrom(const Date&amp; original) { m_month = original.m_month; m_day = original.m_day; m_year = original.m_year; //이런 방법도 잇지만 메모리 자체를 복사하는 방법도 존재하긴한다. //더 쉬운 방법도 많지만 실수하지않기 위해 수동으로 이렇게 값을 넣어주는게 좋다. //같은클래스의 인스턴스의 멤버변수도 접근이 가능하다. //original변수도 Date클래스의 변수이므로 m_month, m_day, m_year에 접근이 가능하다. }};int main() { //크고 복잡한 프로그램을 개발하면서 많은 변수 함수 클래스들을 정의하여 사용하게 된다. //복잡해 보이는것을 단순해보이도록 깔끔하게 분리, 정리를 잘 하는것도 좋은 프로그램을 만드는 중요하다. //class로 선언이 된경우 접근이 안된다. Date today; // today.m_year = 2025; //Date 전제 변경 함수사용 today.setDate(8, 4, 2025); //특정 날짜값 변경 함수 사용 today.setDay(20); //date 정보 가져오기 cout &lt;&lt; today.getMonth() &lt;&lt; endl; //set = 정보 바꾸기 = setters //get = 정보 가져오기 = getters //오류 제거방법 //public: 를 넣어준다. 접근 지정자 //public = class 외부에서 멤버변수에 접근 가능하게 해준다. //private = class 외부에서 멤버변수에 접근 불가능하게 해준다. //private로 막아버리면 값변경은 어떤식으로 진행이 되는지 궁금하지않나? //Access Function을 만들어서 접근을 가능하도록 해야한다. //프로그램이 커지는경우나 여러명이서 작업을 하는경우 access function을만들고 사용하는것이 장기적으로 좋다고한다. //today를 복사하기 Date copy; copy.copyFrom(today); //today / copy는 Date의 instance이다. //둘다 다른 메모리 주소를가지고 있지만 //같은클래스의 인스턴스의 멤버변수도 접근이 가능하다. // //getter, setter를 구현을해야하는 이유 //멤버 변수가public인경우에 /* copy.m_month = 12; today.m_month = 10; 등등 여러곳에서 사용이 된다고 할때 이렇게 많은곳에서 사용하다가 갑자기 변수명을 바꾸어야하는 경우가 발생하게 된다면 class에서 변경을하게되면 다른곳에서 사용하던곳에서도 일일히 다 바꿔주어야한다. 하지만 getter setter를 사용하게 되면 멤버변수가 바뀌면 getter setter에서만 변경하면 된다. 클래스 내부에서 해결이 가능하게 된다. */ //캡슐화 //접근지정자 //public, private, pro //접근함수 return 0;}생성자 Constructors// 생성자// Constructors#include &lt;iostream&gt;using namespace std;class Fraction{private: int m_numerator; //분자 int m_denominator; //분모 public: //생성자 Constructor Fraction(const int&amp; num_in, const int&amp; den_in = 1) { m_numerator = num_in; m_denominator = den_in; cout &lt;&lt; \"Fraction() constructor\" &lt;&lt; endl; } //파라미터가 존재하지않는 기본생성자를 만들어주는것도 가능하다. Fraction() {} void print() { cout &lt;&lt; m_numerator &lt;&lt; \" / \" &lt;&lt; m_denominator &lt;&lt; endl; }};class Second{public: Second() { cout &lt;&lt; \"Second class constructor\" &lt;&lt; endl; }};class First{ Second sec;public: First() { cout &lt;&lt; \"First class constructor\" &lt;&lt; endl; } };int main() { //객체 설계시 인스턴스들은 기본속성,기능들을 가지고 있으면 좋겟다 라는생각을가지게 된다. //이러한 속성,기능들을 생성자를 사용하면 된다. Fraction frac; frac.print(); //초기화가 되어있지않아 쓰레기값으로 분수가 만들어진다. //지금까지 배운내용으로 초기화 하는방법 //class의 멤버변수 접근지정자를 public으로 바꾸고 직접 초기화를 하는방법 //frac.m_numerator = 1; //frac.m_denominator = 2; //setter를 이용해서 초기화를 해줄 수 있다. //이번시간엔 생성자를 배우는 시간이므로 생성자를 만드는법을 배워보자 //생성자는 외부에서 호출하여 사용하려고 하는것이 아니고 인스턴스가 선언이 되면 동시에 처리가된다. Fraction frac2(1,2); frac2.print(); //생성자가없으면 쓰레기값 출력이되고 생성자가 실행이 되어 변수가 초기화가 되어 출력이 된다. //디버깅을 통해 찍어보면 어떤식으로 실행이되는지 육안으로 확인이 가능하다. //cpp의 단점? 결함? //생성자도 함수이므로 frac()으로 사용하는것이 맞으나, 생성자의 파라미터가 없는경우 괄호를 항상 빼도록 정의가 되어있다. //생성자의 파라미터가 생겼을때 오류가 발생한다. //이유 //원래 생성자는 빈값으로 기본값이 지정이 되어있다. /* Fraction() {} 아무 일도 안하는 default 생성자가 존재한다. */ //생성자의 파마리터가 기본값을 가지고 있으면 사용할때 조심해야한다. //{}와 ()의 차이 Fraction test {1,3}; //public인경우 {}로 초기화가능, private인경우 {}로 초기화 불가능하지만, 생성자가 존재한다면 {}사용 가능하다. 자료형 변환불가 Fraction test2(1.0,3); //자료형 변환 가능 //다중 클래스 사용 First fir; //Second 생성자가 먼저 실행이되고 //First 생성자가 실행이 된다. //멤버 class가 먼저 실행이 된다. //생성자를 private로 만들어 줄 수있다. //이러면 frist에서 second를 못사용하지않나? 생각이 들지만 사용하는 경우가 잇다고는 하더라 return 0;}생성자 멤버 초기화 목록// 생성자의 멤버 이니셜라이져 리스트// Member initializer List#include &lt;iostream&gt;using namespace std;class B{private: int m_b; public: B(const int&amp; m_b_in) : m_b(m_b_in) { }};class Something{private: int m_i = 100; double m_d = 100.0; char m_c = 'F'; int m_arr[5] = {100,200,300,400,500}; //cpp11이상부터 배열도 선언가능 B m_b{1024}; public: Something() : m_i(1), m_d(3.14), m_c('a'), m_arr{1,2,3,4,5}, m_b(m_i -1) //이니셜라이즈 리스트 사용방법 줄바꿈해서 보기쉽게 하는것도 가능하다 {// m_i = 1;// m_d = 3.14;// m_c = 'a'; } void print() { cout &lt;&lt; \"m_i : \" &lt;&lt; m_i &lt;&lt; \", \" &lt;&lt; \"m_d : \" &lt;&lt; m_d &lt;&lt; \", \" &lt;&lt; \"m_c : \" &lt;&lt; m_c &lt;&lt; endl; for (auto &amp;e : m_arr) { cout &lt;&lt; e &lt;&lt; \" \"; } cout &lt;&lt; endl; }};int main() { //생성자 멤버 초기화 목록을 멤버 이니셜라이져 리스트라고한다. //이번에는 생성자 이니셜라이져 리스트를 배워보자 Something st; st.print(); //이니셜라이즈 리스트를 사용한 값이 출력이 된다. //class 멤버 변수 선언부에서 초기화를 할수도있다. //멤버변수 선언부에서 초기화를 하였고, 생성자에서도 초기화를 다시 진행을 해준다면 어느것이 우선으로 작동할까? 라는 의문이 생긴다. //둘다 초기화를하였을때 실행을 해보면 생성자 값이 출력되는것을 확인할수있다. //생성자 초기화 부분이 우선순위가 높다. return 0;}위임 생성자// 위임 생성자// Delegating Constructors#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Student{private: int m_id; string m_name; public: Student(const string&amp; name_in) : Student(0, name_in) //생성자에서 생성자를 불러와 사용한다. 위임 생성자 방식1 {} Student(const int&amp; id_in, const string&amp; name_in) : m_id(id_in), m_name(name_in) {} //모든 생성자 멤버변수를 초기화하는 코드를 하나만든다. 방식2 //생성자에서 init함수를 이용하여 처리를한다. void init(const int&amp; id_in, const string&amp; name_in) { m_id = id_in; m_name = name_in; } void print() { cout &lt;&lt; m_id &lt;&lt; \", \" &lt;&lt; m_name &lt;&lt; endl; }};int main() { //생성자가 다른생성자를 사용하는것을 위임생성자라고 한다. Student st1(0, \"Lee\"); st1.print(); //0, Lee 출력 //생성자 파라미터가 여러개 인경우 위임 생성자를 많이 사용한다. //학생번호는 고정값으로 두고 이름만 받아오고 싶은 경우 //생성자에서 생성자를 불러와 사용한다. Student st2(\"Park\"); st2.print(); //0, Park 출력 return 0;}소멸자// 소멸자// Destructor#include &lt;iostream&gt;using namespace std;class Simple{private: int m_id; public: //생성자 Simple(const int&amp; id_in) : m_id(id_in) { cout &lt;&lt; \"Constructor \" &lt;&lt; m_id &lt;&lt; endl; } //소멸자 //소멸자는 파라미터가 존재하지 않는다. ~Simple() { cout &lt;&lt; \"Destructor \" &lt;&lt; m_id &lt;&lt; endl; }};class IntArr{private: int *m_arr = nullptr; int m_length = 0; public: IntArr(const int length_in) { m_length = length_in; m_arr = new int[m_length]; cout &lt;&lt; \"Constructor\" &lt;&lt; endl; } int getLength() { return m_length; } ~IntArr() { if(m_arr != nullptr) delete [] m_arr; }};int main() { //생성자의 반대 개념인 소멸자를 배워보자 //생성자 = 생성이 될때 호출되는 함수 //소멸자 = 소멸이 될때 호출되는 함수 Simple s1(1); Simple s2(2); /* Constructor 1 s1 생성 Constructor 2 s2 생성 Destructor 2 s2 제거 Destructor 1 s2 제거 */ //동적할당 방식 선언 Simple *s3 = new Simple(3); delete s3; Simple *s4 = new Simple(4); delete s4; /* Constructor 3 s3 생성 Destructor 3 s3 제거 Constructor 4 s4 생성 Destructor 4 s4 제거 생성되고 delete되면서 사라진다. 소멸자는 instance가 메모리에서 해제될 때 내부에서 자동으로 호출된다. 동적 할당으로 만들어진 경우에는 자동으로 메모리가 해제되지 않기 때문에 delete로 해제할때만 소멸자가 호출되는것이다. 소멸자는 직접호출하는것을 권장하지 않는다. */ //언제 사용하는것인가? //cpp에서 많이 사용하는 경우는 delete할떄 많이 사용한다. while (true) { IntArr my_int_arr(100); //이렇게 하는경우 메모리 누수가 발생한다. //delete를 해줘야하는데 이럴때 소멸자에 delete를 사용해준다. } return 0;}this 포인터와 연쇄호출// this 포인터와 연쇄 호출// Chaining Member Functions#include &lt;iostream&gt;using namespace std;class Simple{private: int m_id; public: Simple(int id) { //setID는 Simple Instance가 공유된 함수를 사용하는 것이다. //내부적으로는 구분을 할때 this-&gt;를 사용한다. this-&gt;setID(id); //현재 주소를 가지고 있는 instance에서 setID를 사용한다.는 개념이다. //setID(id); //setID는 simple안에있는 함수이므로 this-&gt;가 생략이 되어있는것이다. //자기 자신의 주소를 알려주는 키워드 this cout &lt;&lt; this &lt;&lt; endl; } void setID(int id) { m_id = id; } int getID() { return m_id; }};class Calc{private: int m_val; public: Calc(int init_val) : m_val(init_val) {} Calc&amp; add(int val) { m_val += val; return *this; } Calc&amp; sub(int val) { m_val -= val; return *this; } Calc&amp; mul(int val) { m_val *= val; return *this; } void print() { cout &lt;&lt; m_val &lt;&lt; endl; }};int main() { //class를 붕어빵을 찍는 틀에 비유할수있다. //하나의 class로 부터 여러개의 instance가 나온다. //각 incstance를 비교,구분하는 방법을 알아보자 //class안에 this 포인터와 연쇄호출 용법을 알아보자 Simple s1(1), s2(2); //s1의 setID,getID , s2의 setID,getID는 다른것이 아니라 같은 함수를 이용하는것이다. cout &lt;&lt; \"s1 address : \" &lt;&lt; &amp;s1 &lt;&lt; endl; cout &lt;&lt; \"s2 address : \" &lt;&lt; &amp;s2 &lt;&lt; endl; //개념상 s1의 주소와, 값을 넣어주는것으로 작동이 된다. //Simple::setID(&amp;s1 , 1); //포인터가 들어가서 실행되는 것처럼 진행이 된다. //올바른 문법은 아니지만 실행되는 구조는 이러하다 //this포인터를 사용하는 용법 중 하나 //Chaining Member Functions Calc cal(10); cal.add(10); cal.sub(1); cal.mul(2); cal.print(); //cal.을 찍는것이 귀찮아진다. //함수의 반환형을 class의 주소로 반환하고 반환값을 자기 자신으로 하면된다. cal.add(10).sub(1).mul(2).print(); //작동 방식을 풀어서 본다면 이런식으로 흘러간다. Calc cal2(10); Calc &amp;temp1 = cal2.add(10); Calc &amp;temp2 = temp1.sub(1); Calc &amp;temp3 = temp2.mul(2); temp3.print(); return 0;}Class Code &amp; Header Filemain.cpp// 클래스 코드와 헤더파일#include &lt;iostream&gt;#include \"Calc.h\"using namespace std;int main() { //코드가 길어지면 보기 안좋다고 처음부터 말했엇다. //이번에는 헤더파일에 클래스를 만들고 정리, 관리하는법에 대해 알아보자 //헤더에 class의 선언부 정의부를 따로 분리하는것이 일반적이다. Calc cal(10); cal.add(10); cal.sub(1); cal.mul(2); cal.print(); Calc(10).add(10).sub(1).mul(2).print(); return 0;}Calc.h#pragma once#include &lt;iostream&gt;class Calc{private: int m_val; public: Calc(int init_val); Calc&amp; add(int val); Calc&amp; sub(int val); Calc&amp; mul(int val); void print() { using namespace std; cout &lt;&lt; m_val &lt;&lt; endl; }};Calc.cpp#include \"Calc.h\"Calc::Calc(int init_val): m_val(init_val){}Calc&amp; Calc::add(int val){ m_val += val; return *this;}Calc&amp; Calc::sub(int val){ m_val -= val; return *this;}Calc&amp; Calc::mul(int val){ m_val *= val; return *this;}클래스와 const// 클래스와 const#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Something{public: int m_val = 0; string m_str = \"Test\"; //copy constructor Something(const Something&amp; st_in) { m_val = st_in.m_val; cout &lt;&lt; \"Copy Constructor\" &lt;&lt; endl; } Something() { cout &lt;&lt; \"Constructor\" &lt;&lt; endl; } void setValue(int val) { m_val = val; } int getValue() { return m_val; } //const 멤버 함수 만드는 방법 int getValue2() const { return m_val; } const string&amp; getString() const { cout &lt;&lt; \"const version\" &lt;&lt; endl; return m_str; } string&amp; getString() { cout &lt;&lt; \"non-const version\" &lt;&lt; endl; return m_str; } };void print(Something st){ cout &lt;&lt; st.m_val &lt;&lt; endl; cout &lt;&lt; \"st's address : \" &lt;&lt; &amp;st &lt;&lt; endl;};//파라미터 객체를 복사하지않고 자체를 받는방법void print2(const Something &amp;st){ cout &lt;&lt; st.getValue2() &lt;&lt; endl; cout &lt;&lt; \"st's address : \" &lt;&lt; &amp;st &lt;&lt; endl;};int main() { //class에도 const키워드를 사용할 수 있다. //이번에는 class에서의 const 사용법을 알아보자 const int i = 0; //일반적인 const사용은 변수를 상수로 만들떄 사용했었다. Something st1; st1.setValue(3); //일반 인스턴스는 이렇게 값이 변경가능하다. const Something st2; //st2.setValue(3); //const instance는 값이 변경이 불가능하다. //Something의 m_val값을 바꾸려는것과 같은것이다. //값을 변경하는것 뿐만이아니라 가져오는 getValue에서도 오류가 발생한다. //이러한 이유는 멤버 함수도 const 함수가 존재 하기 때문이다. //컴파일러가 판단할때 멤버 함수가 const인지 아닌지 판단하고 사용하기 때문이다. cout &lt;&lt; st2.getValue2() &lt;&lt; endl; print(st1); //함수의 인수는 함수에 복사 되어 들어가는것이 맞는데 왜 함수 내부에선 생성자가 한번더 실행이 안되는가?? //class 내부에 default copy Constructor가 숨어져있다. cout &lt;&lt; &amp;st1 &lt;&lt; endl; //const를 이용하여 함수 오버로딩도 가능하다. Something st3; st3.getString(); const Something st4; st4.getString(); //특징 /* non-const는 값 변경 가능 cosnt는 값 변경 불가능 보통 멤버함수를 const로 만들면 반환형도 const로 만드는것이 일반적이다. */ return 0;}정적 멤버 변수// 정적 멤버 변수// static member variable#include &lt;iostream&gt;using namespace std;class Something{public: //static 멤버 변수는 initialize가 불가능하다 static int m_val; //static const인 경우에는 initialize가 가능하다. static const int m_val2 = 2; };int Something::m_val = 1; //static 변수는 파일 분리할때 cpp파일에 정의하는것이 좋다. header에 정의하면 컴파일 에러가 날수있다. 변수 중복에러 발생int main() { //instance가 존재 하지않아도 주소가 존재한다. cout &lt;&lt; &amp;Something::m_val &lt;&lt; \", \" &lt;&lt; Something::m_val &lt;&lt; endl; Something st1; Something st2; st1.m_val = 2; //정적 변수로 바꾸면 st1, st2의 멤버변수의 주소가 같아진다. cout &lt;&lt; &amp;st1.m_val &lt;&lt; \", \" &lt;&lt; st1.m_val &lt;&lt; endl; cout &lt;&lt; &amp;st2.m_val &lt;&lt; \", \" &lt;&lt; st2.m_val &lt;&lt; endl; //static memeber variable 사용하는이유 /* 상수 선언 디자인패턴 - 싱글턴 */ return 0;}정적 멤버 함수// 정적 멤버 함수// static member function#include &lt;iostream&gt;using namespace std;class Something{public: //inner class class _init { public: _init() { s_val2 = 987; } }; private: static int s_val2; int m_val; static _init s_initializer; public: Something() : m_val(123) {} static int s_val; static int getVaue1() { return s_val; } static int getVaue2() { return s_val2; } int temp() { return s_val2; }};int Something::s_val = 100;int Something::s_val2 = 1024;Something::_init Something::s_initializer;int main() { //정적 멤버 변수에 이어 정적 멤버 함수에 대해 알아보자 //public static member variable은 주소값이 하나여서 모든 Instance에서 접근이 가능하다. cout &lt;&lt; Something::s_val &lt;&lt; endl; Something st1, st2; cout &lt;&lt; st1.getVaue1() &lt;&lt; endl; cout &lt;&lt; st1.s_val &lt;&lt; endl; //private인 경우 접근이 불가능하다.// cout &lt;&lt; Something::s_val2 &lt;&lt; endl; //특정 instance와 상관없이 변수에 접근 할수있도록 해주는것이 static memeber function이다. cout &lt;&lt; Something::getVaue2() &lt;&lt; endl; //static getValue 함수로 인하여 접근이 가능하게 된다. //주의사항 //static 함수에서는 this-&gt;를 사용하지 못한다. // //멤버 함수의 포인터 가져오는 방법 //int (Something::*fptr1)() = st1.temp; //안되는 이유 //멤버 변수는 st1, st2의 주소가 다르다. //멤버 함수는 st1의 함수나 st2의 함수나 주소가 같다. //인스턴스(st1, st2)의 함수 주소를 가져오려고 하지말고 class(Something)의 함수주소를 가지고 오려고해야한다. int (Something::*fptr1)() = &amp;Something::temp; //fprt1은 temp의 포인터를 가지고있는것이다. //fprt1은 temp의 위치를 가지고있는것이다. //사용 방법 cout &lt;&lt; \" \" &lt;&lt; endl; cout &lt;&lt; (st2.*fptr1)() &lt;&lt; endl; //st2의 포인터를 넘겨주고 st2의 this-&gt;를 가져다가 temp의 포인터를 가져다 사용하는 형태이다. //non-static 함수는 인스턴스에 종속이 되어있는 형태로 작동하는것이므로 st2를 안주면(this-&gt;가 없으면) 사용이 불가능하다. //static member function pointer int (*fptr2)() = &amp;Something::getVaue2; //Something안에 있는함수이지만 인스턴스와 상관없이 실행시킬수있다. cout &lt;&lt; fptr2() &lt;&lt; endl; //static 멤버 변수는 생성자에서 초기화가 불가능하다. //inner class에서 초기화를 하는것처럼 구현이 가능하다. return 0;}친구 함수화 클래스 friend// 친구 함수와 클래스 friend#include &lt;iostream&gt;using namespace std;//전방선언 forward declarationclass B;//A에서 접근이 불가능하므로 일단 B는 있으니까 있는것처럼 행동해라고 알려주는것이다.//코드 읽을때 불편하지만 코드가 복잡해지는경우 선언을 할 수 밖에 없는 상황이 발생한다.//부득이하게 사용하는 경우가 많다.//전방선언의 불편한점//코드가 어디에 정의가 되어있는지 일일히 찾아봐야한다.class A;class A{private: int m_val = 1; //class B가 A보다 뒤에있으므로 B의 존재를 몰라서 오류가 발생한다. friend void doSomething(A&amp; a, B&amp; b); //내부함수 사용방법1 //함수가 존재하는 class자체를 friend화 하는방법 //friend class B; friend void B::doSomethingB(A&amp; a); //B는 전방선언이 되었으나 B의 존재만 알려주는것이지 B안에 무엇이 잇는지는 몰라 오류가 발생한다. //A와 B의 위치를 바꾸고 A를 전방선언을 해도 B안에서 A::m_val에 접근을 하지못하다. //이럴때 함수의 정의부 구현부를 나누어 구현하면 해결이 된다.};class B{private: int m_val = 2; friend void doSomething(A&amp; a, B&amp; b); public: void doSomethingB(A&amp; a) { cout &lt;&lt; a.m_val &lt;&lt; endl; }};void doSomething(A&amp; a, B&amp; b){ //일반적으로 A::m_val는 private변수라 접근이 불가능하다. cout &lt;&lt; a.m_val &lt;&lt; endl; //friend를 이용하면 접근이 가능하게 된다. //특정 클래스의 private meeber에 접근이 가능하게 된다. cout &lt;&lt; b.m_val &lt;&lt; endl;}int main() { //복잡한 프로그램에서는 여러개의 클래스가 서로 상호작용을 깔끔하게 해주는것이 좋다. //이때 friend 키워드를 활용을하면 좀더 깔끔하게 상호작용을 구현할 수 있다. A a; B b; //외부함수의 경우 doSomething(a, b); //외부 함수 b.doSomethingB(a); return 0;}익명객체// 익명객체// anonymous object#include &lt;iostream&gt;using namespace std;class A{public: int m_val; A(const int&amp; input) : m_val(input) { cout &lt;&lt; \"Constructor\" &lt;&lt; endl; } ~A() { cout &lt;&lt; \"Destructor\" &lt;&lt; endl; } void print() { cout &lt;&lt; \"Hello!\" &lt;&lt; endl; cout &lt;&lt; m_val &lt;&lt; endl; }};class Cents{private: int m_cents; public: Cents(int cents) : m_cents(cents) {} int getCents() const { return m_cents; }};Cents add(const Cents&amp; c1, const Cents&amp; c2){ return Cents(c1.getCents() + c2.getCents());}int main() { //익명객체 사용법을 알아보자 //지금까지 배운 사용법 A a(1); //a라는 이름을가진 A객체 사용 a.print(); //A자체 함수를 실행하는방법 //이름없이 바로 사용한다. A(2).print(); //재사용 불가 A(2).print(); //사용할때마다 생성자 소멸자가 실행이된다. //R value처럼 작동이 된다. //응용 cout &lt;&lt; add(Cents(6), Cents(8)).getCents() &lt;&lt; endl; //14출력 //나중에 오퍼레이터 오버로딩할때 유사성을 다시 확인해보자 cout &lt;&lt; int(6) + int(8) &lt;&lt; endl; return 0;}클래스 안에 포함된 자료형 nested types// 클래스 한에 포함된 자료형// Nested types#include &lt;iostream&gt;using namespace std;//enum fruitType//{// APPLE,// BANANA,// CHEERY,//};class Fruit{ public: //Fruit에서만 사용하는 자료형을 enum을 내부에 구현하여 Fruit에서만 사용하게 만들수있다. //여러 클래스에서 사용하게 만들고싶은경우에는 밖으로 빼서 사용한다. enum fruitType { APPLE, BANANA, CHEERY, }; private: fruitType m_type; public: Fruit(fruitType type) : m_type(type) {} fruitType getType() { return m_type; }};int main() { //클래스 구현할때 기능에 맞춰서 특정한 자료형을 만들어서 사용하는경우가 발생한다. //특정 클래스안에 특정 자료형을 선언할 수 있다. Fruit apple(Fruit::APPLE); if(apple.getType() == Fruit::APPLE) cout &lt;&lt; \"Apple\" &lt;&lt; endl; return 0;}실행 시간 측정하기// 실행시간 측정하기#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;chrono&gt; //시간 재주는 라이브러리using namespace std;class Timer{ using clock_t = chrono::high_resolution_clock; using second_t = chrono::duration&lt;double, ratio&lt;1&gt;&gt;; chrono::time_point&lt;clock_t&gt; start_time = clock_t::now(); //시작 후 현재 시간 체크 public: void elapsed() { chrono::time_point&lt;clock_t&gt; end_time = clock_t::now(); //완료 후 현재시간 cout &lt;&lt; chrono::duration_cast&lt;second_t&gt;(end_time - start_time).count() &lt;&lt; endl; //시간 변환 부분 }};int main() { //프로그램이 얼마나 빨리 작동하는지 궁금할떄 시간이 얼마나 걸리는지 측정해보는 경우가 생긴다. //이번에는 시간을 어떻게 측정해야하는지 알아보자 random_device rnd_device; mt19937 mersenne_engine{rnd_device()}; vector&lt;int&gt; vec(1000000); for (unsigned int i = 0; i &lt; vec.size(); ++i) { vec[i] = i; } shuffle(begin(vec), end(vec), mersenne_engine); // for (auto &amp;e : vec) {// cout &lt;&lt; e &lt;&lt; \" \";// } cout &lt;&lt; endl; Timer timer; sort(begin(vec), end(vec)); timer.elapsed(); // for (auto &amp;e : vec) {// cout &lt;&lt; e &lt;&lt; \" \";// } cout &lt;&lt; endl; //Debug보다 releases모드가 더 빠르다. //시간을 잴때는 여러번 재 봐야한다. //여러개의 프로그램을 띄워보고 측정을 해본다. - 멀티스래딩 관련 측정 return 0;}" }, { "title": "[C++] Chapter.7 함수", "url": "/posts/Cpp-Ch7/", "categories": "Language, C++", "tags": "c++", "date": "2022-09-24 22:20:19 +0900", "snippet": "매개변수와 실인자의 구분//매개변수와 인자의 구분#include &lt;iostream&gt;using namespace std;int foo(int x, int y);//x,y 는 foo의 파라미터이다.int foo(int x, int y){ return x + y;}//매개변수 함수가 어떤 기능하는지 조절해주는 기능//함수가 끝나면 지역변수 처럼 사라진다.int main() { //매개변수 = parameter //인자 = argument int x = 1, y = 2; foo(6, 7); //6,7은 인자이다. //argument, actual parameters foo(x, y+1); //x , y+1도 인자이다. //x = 1 , y+1 = 3 foo함수의 파라미타 x에는 1이 전달, 파라미터 y에는 3이 전달되는것이다. //파라미터 : 함수를 만들때 사용하는 값 //인자 : 함수를 사용할때 넣는 값 return 0;}값에 의한 전달// 값에 의한 인수 전달// Passing Arguments by values// Call by Value#include &lt;iostream&gt;using namespace std;void doSomething(int y){ cout &lt;&lt; \"In func value : \" &lt;&lt; y &lt;&lt; \"\\nIn func value address : \" &lt;&lt; &amp;y &lt;&lt; endl;}int main() { doSomething(1); //리터럴 값 1이 doSomething의 y로 복사가 되는것이다. //더 자세하게 말하자면 doSomething에서 int y 가 선언이 되고 1값이 복사가 되는것이다. int x = 2; cout &lt;&lt; \"In main value : \" &lt;&lt; x &lt;&lt; \"\\nIn main value address : \" &lt;&lt; &amp;x &lt;&lt; endl; doSomething(x); //x가 전달이 되는것 처럼 보이지만 실제로 전달되는것은 x안에 있는 값인 6이 전달이 되는것이다. //x자체가 전달이 되는것이라면 main과 doSomething에서의 변수 주소가 같아야하지만, //mian과 doSomething에서의 변수 주소가 다르게 출력 되는것을 출력결과로 통해 알수있다. doSomething(x + 1); //call by value의 장점 //main과 function에서의 변수 주소가 달라서 function안에서 무슨짓을해도 main에 영향을 주지않는다. //코드가 복잡할수록 함수는 자기 할일만하는 것이 제일 깔끔하다. //하지만, 특별한 경우에는 함수가 외부에 영향을 주도록 해야하는 경우도 발생한다. //다음 단계인 이것은 참조에 의한 전달에서 설명을 한다. return 0;}참조에 의한 인수전달// 참조에 의한 인수 전달// Passing Arguments by Reference// Call by Reference#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;//&amp;키워드가없는경우 y에 몇을 더해도 함수밖에서 값이 변하지 않는다.void addOne(int &amp;y){ y = y + 1; cout &lt;&lt; \"func y vlaue : \" &lt;&lt; y &lt;&lt; \"\\ny address : \" &lt;&lt; &amp;y &lt;&lt; endl; //main의 인자값과 주소가 같다.}void getSinCos(double degrees, double &amp;sin_out, double &amp;cos_out){ static const double pi = 3.141592; double radians = degrees * pi / 180.0; sin_out = sin(radians); //sin함수는 cmath안에 들어잇는함수이다. cos_out = cos(radians); //cos함수는 cmath안에 들어잇는함수이다.}void foo(const int &amp;x){ cout &lt;&lt; x &lt;&lt; endl;}//int *&amp;ptr 해석//int형 포인터의 ptr변수의 참조값void ptrfoo(int *&amp;ptr){ cout &lt;&lt; ptr &lt;&lt; \", \" &lt;&lt; &amp;ptr &lt;&lt; endl;}//배열 전달//배열의 크기가 지정이 되어야한다.void printElement(int (&amp;arr)[4]){ //이건잘사용하지않는다. //대부분 동적할당을 사용하여 사용하고, 배열은array, vector를 변수를 사용한다.}int main() { int x = 5; cout &lt;&lt; \"mian x vlaue : \" &lt;&lt; x &lt;&lt; \"\\nx address : \" &lt;&lt; &amp;x &lt;&lt; endl; addOne(x); cout &lt;&lt; \"main x vlaue : \" &lt;&lt; x &lt;&lt; \"\\nx address : \" &lt;&lt; &amp;x &lt;&lt; endl; //함수에 의한 값변화 출력 확인하기 //값은 변화 하였지만 주소값은 동일하다. //참조에서 배운 함수 자체에 인자를 전달한것이가 때문이다. //참조에 의한 전달은 변수자체를 넘기는것이라 복사가 이뤄지지 않는다. double sin(0.0); double cos(0.0); getSinCos(30.0, sin, cos); //c나 cpp에서는 출력값이 하나만 지정가능하지만, //call by reference를 이용하여 마치 sin과 cos값이 반한값이 나오는 것처럼 구현이 가능하다. //(getsincos의 반환값은 void이지만 반환값이 double인 것처럼) //c, cpp에선 반환값(리턴값)이 하나만 지정이 가능하여, 매개변수를 여러개 지정하는경우가 많다. //인자가 많아지는경우 첫번쨰는 입력값, 출력으로 나가는값을 뒤로 두는것이 일반적이다. //그래서 일반적으로 입력값을 const로 막아둔다. //홍정모 강사께선 한번 계산되고 더이상 값이 변경이 되지않는 값은 const로 막아둔다고 하신다. cout &lt;&lt; \"sin value : \" &lt;&lt; sin &lt;&lt; \", cos value : \" &lt;&lt; cos &lt;&lt; endl; foo(6); //함수의파라미터가 참조값인 경우 리터럴을 발을수없지만, const로 지정하면 리터럴값도 받을수있다. //요즘에는 const로 입력값을 받는다고한다. //포인터에 대한 참조를 보낼수있다.. int a = 5; int *ptr = &amp;a; ptrfoo(ptr); cout &lt;&lt; ptr &lt;&lt; \", \" &lt;&lt; &amp;ptr &lt;&lt; endl; //배열에 대한 참조 전달 int arr[]{1,2,3,4}; printElement(arr); return 0;}주소에 의한 인수전달// 주소에 의한인수 전달// Passing Arguuments by Address// Call by Address#include &lt;iostream&gt;using namespace std;void foo(int *ptr){ cout &lt;&lt; \"func vlaue : \" &lt;&lt; *ptr &lt;&lt; \"\\nfunc adress value : \" &lt;&lt; ptr &lt;&lt; \"\\nfunc ptr adress value : \" &lt;&lt; &amp;ptr &lt;&lt; endl; *ptr = 10;}void foo2(const int *ptr){ cout &lt;&lt; \"func vlaue : \" &lt;&lt; *ptr &lt;&lt; \"\\nfunc adress value : \" &lt;&lt; ptr &lt;&lt; \"\\nfunc ptr adress value : \" &lt;&lt; &amp;ptr &lt;&lt; endl; // *ptr = 10; //const 변수인 경우 값 변경불가.}//포인터에 의한 인자 전달void getSinCos(double degrees, double *sin_out, double *cos_out){ *sin_out = 1.0; *cos_out = 2.0; }//const 용법 설명void foo3(const int *val1 , int *const val2){ //val1 int x = 1; val1 = &amp;x; //주소 값변경가능// *val1 = 10; //변수 값 변경 불가능 //val2// val2 = &amp;x; //주소값 변경 불가능 //굳이 사용 안한다. //주소를 바꿔봣자 값에 의한 전달, 즉 함수가 끝나면 없어지기 때문에 주소값을 바꿔도 호출부분에서 크게 해가될부분이 없기때문이다.}int main() { //주소(포인터)를 이용한 매개변수 전달을 배워보자 int val = 5; cout &lt;&lt; \"main vlaue : \" &lt;&lt; val &lt;&lt; \"\\nmain adress value : \" &lt;&lt; &amp;val &lt;&lt; endl; cout &lt;&lt; val &lt;&lt; endl; foo(&amp;val); int *ptr = &amp;val; cout &lt;&lt; val &lt;&lt; endl; foo(ptr); cout &lt;&lt; &amp;ptr &lt;&lt; endl; //함수안의 주소값과 main의 주소값이 다르다. /* 주소값이 다른이유 typedef int* pint void foo(pint ptr) { } 이렇게 보면 매개변수가 pint변수인 foo함수가 된다. //형태로 추륵해보면 값에 의한 전달과 같다. //주소 값을 값에 의한 전달(call by value)로 전달하는것이라 그렇다. //포인터도 그냥 변수다. 단지 주소값을 가지고있을뿐;; */ //포인터에 의한 인수 전달도 참조처럼 함수의 반환값이 여러개 인것처럼 구현이가능하다. double sin, cos; //참조와 달리 함수를 사용할때 &amp;를 사용해야한다. getSinCos(30, &amp;sin, &amp;cos); cout &lt;&lt; \"sin : \" &lt;&lt; sin &lt;&lt; \", cos : \" &lt;&lt; cos &lt;&lt; endl; //실용적인측면에서 그냥 call by ref를사용하는것이 편하다. //착각이 되는것 /* call by ref와 같은 작동을 해서 ref는 함수 내부와 main과 같은 변수지만, pointer는 함수 내부와 main과 다른 변수이다. */ // return 0;}다양한 반환값들(값, 참조, 주소, 구조체, 튜플)// 다양한 반환값들(값, 참조, 주소, 구조체, 튜플)// Return Values#include &lt;iostream&gt;#include &lt;array&gt;#include &lt;tuple&gt;using namespace std;//return by valueint getValue(int x){ int value = x * 2; return value;}//return by adressint* getValue2(int x){ int value = x * 2; return &amp;value;}//return by referenceint&amp; getValue3(int x){ int value = x * 2; return value;}//ref 사용 예시int&amp; get(array&lt;int, 100&gt;&amp; arr, int idx){ return arr[idx];}//구조체struct S{ int a, b, c, d;};S getStruct(){ S my_s{1,2,3,4}; return my_s;}tuple&lt;int, double&gt; getTuple(){ int a = 10; double d = 3.14; return make_tuple(a,d);}int main() { //이번에는 반환값을 어떻게 받을지 살펴보자 int value = getValue(3); //3을 복사해서 getValue 함수안의 int x값에 초기화가 되고 //함수안에서 value = x * 2가 되어서 //value가 6으로 반환하여 6이 전달되어 value에 복사가 되어 초기화가 된다. //복사 및 변수 생성이 여러번 일어나는 단점이 발생한다. //구조체나 클래스를 사용하는경우 데이터가 많아 복사 및 생성이 많아지면 메모리 소모가 커지므로 안좋다. //주소값 반환 형식 int value2 = *getValue2(3); //*을이용하여 값을받는경우는 권장하지않는다. //함수가 실행이 끝나고 함수내부 데이터는 사라지므로 사라질 변수를 가져오는것은 안전하지않다. cout &lt;&lt; value2 &lt;&lt; endl; //값은 출력이 된다. //Address of stack memory associated with local variable 'value' returned 경고문 출력됨 cout &lt;&lt; value2 &lt;&lt; endl; int *val = getValue2(3); //이 방법은 더 위험하다. //함수 내 변수의 값는 소멸이 되었지만, 메모리 주소를 받아오는것이라 //값은 존재하지않지만 주소값만 가져오는 경우 발생가능성이 크다. cout &lt;&lt; *val &lt;&lt; endl; cout &lt;&lt; *val &lt;&lt; endl; //쓰레기값 출력 //함수내부의 value변수가 소멸이 되고 주소값만 남아있는 상태에서 value의 값을 가져오려고 해서 문제가 발생하는것이다. //참고값 반환 형식 int val2 = getValue3(5); cout &lt;&lt; val2 &lt;&lt; endl; //문제가 된는경우 int &amp;val3 = getValue3(5); //ref값을 받는경우 위험하다. //원인은 주소값과 마찬가지로 함수내에서 사라질 변수의 값을 가져오는 행위이므로 위험하다. cout &lt;&lt; val3 &lt;&lt; endl; //출력 잘됨 cout &lt;&lt; val3 &lt;&lt; endl; //쓰레기값 출력 //함수내부의 value변수가 소멸이 되고 주소값만 남아있는 상태에서 value의 값을 가져오려고 해서 문제가 발생하는것이다. //참조 반환을 유용하게 쓰는방법 예시 array&lt;int, 100&gt; my_arr; my_arr[30] = 10; //30번째 값을바꾼다. cout &lt;&lt; my_arr[30] &lt;&lt; endl; //10 출력 //배열의 값을 바꾸는방식을 함수로 만들수있다. get(my_arr, 30) = 1024; cout &lt;&lt; my_arr[30] &lt;&lt; endl; //1024 출력 //get함수를 보면 //my_arr 메모리주소가 잡혀있고 함수에 넣어 해당 인덱스값의 배열값을 리턴을한다. //이렇게 사용하는것이 생각보다 많다. //반환값 여러개 받는방법 //1. 구조체 사용 S my_s = getStruct(); my_s.a = 1; //단점 //함수 하나 만들떄마다 구조체를 따로 만들어야한다. //메모리 소모가 커진다. //2. 튜플 사용 tuple&lt;int, double&gt; my_tp = getTuple(); int a = get&lt;0&gt;(my_tp); double d = get&lt;1&gt;(my_tp); //튜플값 가져오는 방법 cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; get&lt;0&gt;(my_tp) &lt;&lt; endl; cout &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; get&lt;1&gt;(my_tp) &lt;&lt; endl; //위 방법들이 다 불편하여 새로나온 방식 //cpp 17이상 부터 사용가능한 예시 auto[a1, d1] = getTuple(); //a1 변수 ,d1변수를 생성하여 각각 튜플값을 넣는 방식이다. cout &lt;&lt; a1 &lt;&lt; endl; cout &lt;&lt; d1 &lt;&lt; endl; return 0;}인라인 함수// 인라인 함수#include &lt;iostream&gt;using namespace std;int min(int x, int y){ return x &gt; y ? y : x;}inline int min2(int x, int y){ return x &gt; y ? y : x;}int main() { //프로그램을 빠르게 만들기 위해 최적화를 한다. //인라인 함수를사용하여 최적화를 진행한다. //인라인 함수를 배워보자 cout &lt;&lt; min(5, 6) &lt;&lt; endl; cout &lt;&lt; min(3, 2) &lt;&lt; endl; //프로그램이 실행되면 //min 함수가 호출되기 전에 메모리에 저장이 되어있다가 호출하게되면 //함수 내부에서 변수를 x,y를만들고 크기 비교연산을 거쳐 출력을 하게 되는 방식을 거치게 된다. //복잡한 프로그램에서는 실제 계산 하는부분보다 변수 생성 하고 값을넣어주는 부분들이 더 시간이 많이 걸리는 경우가 발생한다. //이럴때 인라인 함수를 사용한다. //헤더 파일에서 함수를 선언할때 많이 사용한다. //인라인 함수를 사용하게 되면 //x &gt; y ? y : x; cout &lt;&lt; min2(5,6) &lt;&lt; endl; //인라인 함수를 호출하면 cout &lt;&lt; ( 5&gt;6 ? 6 : 5 ) &lt;&lt; endl; //컴파일러 입장에서 보면 이것과 같은 행위로 바뀌게 된다. //이렇게 되면 함수가호출될일도 없고 변수가 생길일도 없고 지울필요도 없어지게 되어 속도가 향상이 된다. //inline 키워드 //컴파일러에게 함수를 inline으로 사용하라고 권장하는 뉘앙스이다. //모든 함수를 inline으로 한다고해서 모두 빨라지는것은 아니다. //inline에 의존하여 최적화를 하는것은 좋은 방법은 아니다. //단점 //비슷한 inline함수가 많아지면 //컴파일된 프로그램이 커지게 된다. //오히려 메모리 소모가 많아져 inline을 사용한 효과를 못볼수있다. return 0;}함수 오버로딩// 함수 오버로딩// Function Overloading#include &lt;iostream&gt;using namespace std;int add_int(int x, int y){ return x + y;}int add_double(double x, double y){ return x + y;}int add(int x, int y){ return x + y;}int add(double x, double y){ return x + y;}void print(unsigned int val){}void print(float val){}int main() { //동일한 이름의 함수를 만드는것을 함수 오버로딩이라고 한다. //이번시간엔 오버로딩에 대해 알아보자 add_int(1,2); add_double(1.0, 2.0); //이런식으로 기능은 비슷한데 이름이 다르게 되면 귀찮다. //함수 매개변수는 다른데기능은 비슷한 경우 오버로딩을 사용한다. add(1, 2); add(3.0, 4.0); //주의사항 //함수 사용 판정은 이름만 가지고 판단하는것이 아니고 //매개변수가 다르면 다른 함수라고 판단한다. //컴파일 할때 결정이 된다. //매개변수가 같은 경우에는 오버로딩이 작동 되지않는다. //반환형으로는 함수 구별이 안된다. //typedef로 지정한 경우에도 같은 함수로 취급한다. /* typedef int my_int; int add2(my_int x) { return x + y; } int add2(int x) { return x + y; } */ //함수가 애매한경우 //함수의 모호성이 생기는 경우// print(0);// print(3.14); //void print(unsigned int val){} //void print(float val){} //함수오버로딩을 사용하는경우 매개변수를 정확,명확 하게 정의하여 사용을 해야한다. return 0;}매개변수의 기본값// 매개변수의 기본값// Default Parameters#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//Default Parameter//매개변수에 값을지정해준다.void print(int x = 0){ cout &lt;&lt; x &lt;&lt; endl;}//여러 값 지정가능//모두 지정하지않거나 한개, 두개, 세개 모두 지정가능하다.//두개를지정하는경우 맨 오른쪽은 기본값이 있어야한다.void print(int x, int y, int z = 20){ cout &lt;&lt; \"x value : \" &lt;&lt; x &lt;&lt; endl; cout &lt;&lt; \"y value : \" &lt;&lt; y &lt;&lt; endl; cout &lt;&lt; \"z value : \" &lt;&lt; z &lt;&lt; endl;}//선언부void print2(int x, int y = 30);//구현부void print2(int x, int y){ }void printstr(string str){ }void printstr(char ch = 'a'){ }void test(int x){ }void test(int x, int y = 20){ }int main() { //매개변수가 여러개 있을때 매번 매개변수를 다 넣어주는것은 귀찮을수잇다. //매개변수에 기본값을 설정하여 코드의 효율성을 높일수있다. print(10); //10으로 출력 print(); //함수에서 지정한값으로 출력 print(10, 1,2); print(1,2); //주의사항 //선언부 구현부로 나누어 함수를 만들수 있는다것을 앞에서 배웠다. //기본값을 선언부나 구현부 둘중 한곳에서만 해주어야한다. //보통 선언부에 기본값을 넣어준다. //선언부는 보통 헤더파일에 모아서 관리를 하므로 선언부에 기본값을 지정하면 관리하기가 편해진다. print2(10); //오버로딩에서의 기본값 printstr(); //char형 함수 printstr(\"abc\"); //string 함수 //오버로딩과 기본값으로 인한 모호성 //오버로딩된 함수의 기본값으로 사용할 수 없다. //test(10); //test(x), test(x, y) 인지 구분이 불가능하다. test(10, 20); return 0;}함수 포인터// 함수 포인터#include &lt;iostream&gt;#include &lt;array&gt;#include &lt;functional&gt;using namespace std;int func(){ return 5;}int goo(){ return 10;}void printNum(const array&lt;int, 10&gt; &amp;arr, bool print_even){ for (auto element : arr) { if(print_even &amp;&amp; element % 2 == 0) cout &lt;&lt; element &lt;&lt; \" \"; else if(!print_even &amp;&amp; element % 2 != 0) cout &lt;&lt; element &lt;&lt; \" \"; } cout &lt;&lt; endl;}//함수 포인터 함수bool isEven(const int&amp; number){ if(number % 2 == 0) return true; return false;}bool isOdd(const int&amp; number){ if(number % 2 != 0) return true; return false;}void printNum(const array&lt;int, 10&gt; &amp;arr, bool(*check_func)(const int&amp;)){ for (auto element : arr) { if(check_func(element) == true) cout &lt;&lt; element &lt;&lt; \" \"; } cout &lt;&lt; endl;}void printNum(const array&lt;int, 10&gt; &amp;arr, std::function&lt;bool(const int&amp;)&gt; check_func){ for (auto element : arr) { if(check_func(element) == true) cout &lt;&lt; element &lt;&lt; \" \"; } cout &lt;&lt; endl;}int main() { //지금까지 배운 포인터는 변수에 관한 포인터였다. //이번에는 함수에 관한 포인터를 배워보자. //함수 이름으로 출력 시도 cout &lt;&lt; func &lt;&lt; endl; //주소값 출력 //함수도 포인터이다. // func(); //함수 호출시 주소를 알아내고 그 주소에 있는 함수를 사용하는것이다. //함수도 주소를 가지고 사용을 해보자 //함수의 포인터 선언 방법 int (*funcptr)() = func; //funcptr = 변수명 cout &lt;&lt; funcptr() &lt;&lt; endl; //func()이 실행이되어 5출력 //다른 함수로 바꿔줄수도있다. funcptr = goo; cout &lt;&lt; funcptr() &lt;&lt; endl; //goo()이 실행이되어 10출력 //함수 포인터를 매개변수로 만들수도 있다. array&lt;int, 10&gt; my_arr {0,1,2,3,4,5,6,7,8,9}; for (auto element : my_arr) { if(element % 2 == 0) cout &lt;&lt; element &lt;&lt; \" \"; } cout &lt;&lt; endl; //일반적인 함수 printNum(my_arr, true); printNum(my_arr, false); //함수 포인터 사용한 함수 printNum(my_arr, isEven); printNum(my_arr, isOdd); //함수 매개변수를 이용하면 변수명이 길어지므로 typedef, using을 이용하여 코드를 줄일수있다. /* typedef bool(*check_func)(const int&amp;); using check_func_t = bool()(const int&amp;); */ //cpp11 이후 functional 라이브러리를 사용하면 더욱더 편해진다. std::function&lt;bool(const int&amp;)&gt; funcptr2 = isEven; printNum(my_arr, funcptr2); funcptr2 = isOdd; printNum(my_arr, funcptr2); //이번에는 간단하게 어떻게 사용하지 기본적인것만 보여주느라 더욱더 복잡해보인다. //나중에 유용하게 사용하는 방법을 다시 알려준다고 한다. return 0; } 스택과 힙// 스택과 힙#include &lt;iostream&gt;using namespace std;int main() { //메모리중에는 스택과 힙이 존재한다. //이번에는 스택과 힙을 알아보자 //기본적인 구조 /* Heap = Stack = Data = 초기화가 된 data segment BSS = 초기화가 안된 data segment Code = 프로그래머가 작성하는 코드 */ //stack //사진 첨부 확인 //코드에서 호출순서대로 스택에 쌓이고 //함수가 끝나면(return이 실행이 되면) 스택이 마지막에 쌓인것부터 제거가 된다. //스택 프레임에는 실행이되고 어디로 돌아가야하는지에 대한 정보도 들어가있다. //스택 단점 //빠르지만 크기가 작다. //동적메모리 할당 //지역변수은 스택에 저장이 된다. //오버플로우 발생할 가능성이 존재한다. //이것을 보완하기위해 힙을 추가적으로 사용한다. //힙 //동적 메모리가 할당이 되면 힙에 추가가 된다. //단점 = 스택은 순서에 따라 쌓이지만, 힙은 어디에 생성이 되는지 알기가 힘들다. //메모리 누수 발생 가능성있다. return 0;}std::vector를 스택처럼 사용하기// std::vector를 스택처럼 사용하기#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void printStack(const vector&lt;int&gt; &amp;stack){ for (auto &amp;e : stack) { cout &lt;&lt; e &lt;&lt; \" \"; } cout &lt;&lt; endl;}int main() { //vector의 사용법을 좀더 알아보는 시간을가져보자 vector&lt;int&gt; v {1,2,3}; //vector는 size와 capacity가 존재한다. //size(크기) //전체 용량중 실제 사용하는 크기만 존재한다. //capacity(용량) //실제로는 코드내부에서 용량 갯수만큼 메모리를 가지고있다, //벡터를 잘 사용하는 방법 //내부에서 이뤄지는 new와 delete를 얼마나 적게 호출할 것인가 이다. for (auto &amp;e : v) { cout &lt;&lt; e &lt;&lt; \" \"; } cout &lt;&lt; endl; cout &lt;&lt; \"size is \"&lt;&lt; v.size() &lt;&lt; endl; cout &lt;&lt; \"capacity is \"&lt;&lt; v.capacity() &lt;&lt; endl; //사이즈 변경// v.resize(10);//// for (auto &amp;e : v) {// cout &lt;&lt; e &lt;&lt; \" \";// }// cout &lt;&lt; endl;//// cout &lt;&lt; \"size is \"&lt;&lt; v.size() &lt;&lt; endl;// cout &lt;&lt; \"capacity is \"&lt;&lt; v.capacity() &lt;&lt; endl;// //size = 10, capacity = 10 v.resize(2); for (auto &amp;e : v) { cout &lt;&lt; e &lt;&lt; \" \"; } cout &lt;&lt; endl; cout &lt;&lt; \"size is \"&lt;&lt; v.size() &lt;&lt; endl; cout &lt;&lt; \"capacity is \"&lt;&lt; v.capacity() &lt;&lt; endl; //size = 2, capacity = 3 //크기가 2로 줄어 3을 출력하지못한다. //cout &lt;&lt; v.at(2) &lt;&lt; endl; //강제로 포인터를 가져온다. int *ptr = v.data(); cout &lt;&lt; ptr[2] &lt;&lt; endl; //3이 출력이 된다. //사이즈를 줄였지만 실제로는 1,2,3을 모두 가지고있지만 없는척 하고있는것이다. //원래 사이즈를 조절할때 //v의 1,2,3에서 1,2로 줄일때 1,2를 새로운 메모리로 복사를 하고 1,2,3을데이터를 delete를 하게된다. //vector에서는 속도를 높이고자 이런 행위를 하지않는다. //크기를 줄일때 속도저하를 없애기위해 용량은 그대로 3개의 크기를 가지고 2개의 크기만 보여주는것이다. //용량만 늘리는 방법 v.reserve(1024); for (auto &amp;e : v) { cout &lt;&lt; e &lt;&lt; \" \"; } cout &lt;&lt; endl; cout &lt;&lt; \"size is \"&lt;&lt; v.size() &lt;&lt; endl; cout &lt;&lt; \"capacity is \"&lt;&lt; v.capacity() &lt;&lt; endl; //size = 2, capacity = 1024 //reserve를 하는경우 //원소를 추가를할때 공간이 많이 남아있으면 메모리 교체를 할필요없고 원래 할당된 공간에 넣어주기만 하면 빠르기때문에 reserve를 사용한다. //stack처럼 사용하는 방법 vector&lt;int&gt; stack; //stack에서 데이터가 쌓이는 과정을 push, 데이터가 삭제되는 과정을 pop이라고 한다. stack.push_back(3); printStack(stack); stack.push_back(5); printStack(stack); stack.push_back(5); printStack(stack); stack.pop_back(); printStack(stack); stack.pop_back(); printStack(stack); stack.pop_back(); printStack(stack); //장점 capacity를 지정하여 사용하면 공간에 new delete을 안하게되어 속도가 빠르다. //단점 capacity가 너무 크면 메모리가 낭비가 될 수 있다. return 0;}재귀적 함수 호출// 재귀적 함수 호출// Recursive Function Call#include &lt;iostream&gt;using namespace std;void countDown(int cnt){ cout &lt;&lt; cnt &lt;&lt; endl; if(cnt &gt; 0) countDown(cnt - 1); //자기 자신 호출 부분}int sumTo(int num){ if(num &lt;= 0) return 0; else if(num == 1) return 1; else return sumTo(num - 1) + num;}//0//1 1 2 3 5 8 13 21long long fibonacci(int num){ if(num == 0) return 0; else if(num == 1) return 1; else //3이상 숫자일떄 return fibonacci(num - 1) + fibonacci(num - 2);}int main() { //오늘은 재귀 함수를 배워볼것이다. //재귀함수는 함수에서 자기자신을 다시 호출하는것이다. //예제 숫자 세기 countDown(5); //그냥 실행하면 -로 넘어가서 재귀함수 실행시 종료 조건이 있어야한다. //안그러면 무한루프와 같아진다. 스택에 많이 쌓여 오버플로우 발생할 수 있다. //재귀 운영방식 //스택과 힙에서 설명한것처럼 함수도 메모리에 쌓이는데 cout &lt;&lt; \"--------\" &lt;&lt; endl; cout &lt;&lt; sumTo(10) &lt;&lt; endl; //재귀에 좋은 예시 //피보나치 수열 구현 long long num; cin &gt;&gt; num; cout &lt;&lt; fibonacci(num) &lt;&lt; endl; return 0;}방어적 프로그래밍의 개념// 방어적 프로그램밍의 개념// Defensive Programming#include &lt;iostream&gt;using namespace std;int main() { //많은 사용자들이 사용하는 프로그램은 누가 사용하든지 정상적으로 만들어야한다. //방어적 프로그래밍에 대해 알아보자 //syntax error //문법 오류 //문법 오류는 대부분 컴파일러에서 다 잡아준다. //semantic error //문맥 오류 int x; cin &gt;&gt; x; if(x &gt;= 5) cout &lt;&lt; \"x is greater than 5\" &lt;&lt; endl; //5보다 커야하지만 5일때도 출력되는 오류 발생 //violated assumption //가정 오류 //개발 의도가 아닌 다른 방식으로 작동하여 발생하는 오류 string hello = \"Hello, my name is Lee\"; int idx; cin &gt;&gt; idx; cout &lt;&lt; hello[idx] &lt;&lt; endl; //입력 받은 숫자의 위치의 문자열 츨력하는 예시 //오류발생 //문자열의 크기를 벗어난 숫자를 입력하는경우 오류발생 //오류가 발생할 수 있는곳을 미리 방지해야한다. //이러한 오류가 많이 발생하면 판매량이 줄어든다. while (true) { cout &lt;&lt; \"Input from 0 to \" &lt;&lt; hello.size() - 1 &lt;&lt; endl; cin &gt;&gt; idx; if(0 &lt;= idx &amp;&amp; idx &lt;= hello.size()-1) { cout &lt;&lt; hello[idx] &lt;&lt; endl; break; } else cout &lt;&lt; \"The number is incorrect. try again\"&lt;&lt; endl; } //이런식으로 작성해야 오류 발생가능성을 줄일 수 있다. //방어적 프로그래밍은 손이 많이간다. //출시되는 모든 프로그램은 이런식으로 방어장치를 가지고 있어야한다. return 0;}단언하기 assert// 단언하기 assert#include &lt;iostream&gt;#include &lt;cassert&gt;#include &lt;array&gt;using namespace std;void printValue(const array&lt;int, 5&gt;&amp; arr, const int&amp; idx){// assert(idx &gt;= 0);// assert(idx &lt;= arr.size() -1); //여기서 오류발생 cout &lt;&lt; arr[5] &lt;&lt; endl; }int main() { //이번시간엔 assert를 배워보자 //assert는 디버깅할때 사용하는 키워드이다. //assert(false); //assert 특징 //releases러 실행하는 경우 작동하지 않는다. //debug모드에서 소프트웨어를 테스트할때 사용한다. //이것도 방어적 프로그래밍중에 하나이다. int num = 5; //num이 5일때만 진행한다. assert(num == 5); // array&lt;int, 5&gt; my_arr{1,2,3,4,5}; // printValue(my_arr, 5); //컴파일 타임 오류 //static assert int x = 5; assert(x == 5); //assert는 일반 변수에 논리 연산자 사용가능 // static_assert(x==5); //static_assert는 일반변수에 논리연산자 사용불가능 const int y = 10;// static_assert(y == 5); static_assert(y == 5, \"y should be 5\"); //오류 메세지도 같이 출력가능하다. return 0;}명령줄 인수// 명령줄 인수// Command Line Arguments#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(int argc, char *argv[]) { //이번엔 명령줄 인수에 대해 알아보자 //main에 매개변수 넣는 방법 //argc = 갯수 , argv = 내용 for (int cnt = 0; cnt &lt; argc; ++cnt) { string aargv_single = argv[cnt]; cout &lt;&lt; argv[cnt] &lt;&lt; endl; } //실행시 terminal에 파일 경로 &amp; 이름이 출력이 된다. //파일 위치로 이동하여 해당 exe파일을 terminal에 명령어로 컴파일된 파일을 실행 시켜보자 //파일 위치에서 실행을 하게되면 ide에서 나온 출력물과 달리 해당 파일의 이름만 출력하게 된다. //windows //해당 위치로 이동하여 파일이름.exe 123 123 123 입력후 엔터 ///파일경로 //123 //123 //123 출력 //Mac //해당 위치로 이동하여 ./파일이름 123 123 123 입력후 엔터 ///파일경로 //123 //123 //123 return 0;}생략부호 Ellipsis // 생략부호 Ellipsis#include &lt;iostream&gt;#include &lt;cstdarg&gt; //for ellipsisusing namespace std;//cnt = 받을 갯수 , ... 생략기호double findAverage(int cnt, ...){ double sum = 0; va_list list; va_start(list, cnt); for (int arg = 0; arg &lt; cnt; ++arg) { sum+= va_arg(list, int); } va_end(list); return sum / cnt;}int main() { //이번에는 생략부호를 배워보자 //함수를 구현할때 매개변수가 정해져있지않앗으면 좋겟다 생각을 할수있다. //이때 생략부호를 사용하면된다. cout &lt;&lt; findAverage(1,1,2,3,\"Hello\", \"c\") &lt;&lt; endl; //함수의 cnt값이 1이므로 1만 가져오고 2,3,Hello,c는 무시한다. cout &lt;&lt; findAverage(3,1,2,3) &lt;&lt; endl; //cnt값이 3개 이므로 1,2,3을 모두가져와 평균을내준다. cout &lt;&lt; findAverage(5,1,2,3,4,5) &lt;&lt; endl; cout &lt;&lt; findAverage(10,1,2,3,4,5) &lt;&lt; endl; //cnt가 10인데 인수가 5개밖에 없으므로 오류가 발생한다. //파라미터가 생략이 되어있으므로 초급자에게는 위험할수있다. //파라미터 갯수가 지정 되어있지 않을뿐이지 함수 내부에서 자료형을 지정을 해주어야한다. return 0;}" }, { "title": "[C++] Chapter.15 의미론적 이동과 스마트포인터", "url": "/posts/Cpp-Ch15/", "categories": "Language, C++", "tags": "c++", "date": "2022-09-24 22:20:19 +0900", "snippet": "이동의 의미와 스마트 포인터main.cpp// 이동의 의미와 스마트 포인터// Move semantics, Smart pointers#include &lt;iostream&gt;#include \"Resource.hpp\"#include \"AutoPtr.hpp\"using namespace std; void doSomething(){// Resource *res = new Resource; //동적할당 초기화 // delete res; //동적할당 메모리 제거 //RAII = resource acquisition is initialization //메모리를 할당 받는곳에서 삭제도 같이하는 것을 RAII라고 한다. //예전에 흔히 발생하던 실수 //1. delete 코드를 안적는 경우 //2. delete 호출하기전에 함수를 종료하는경우 early return //스마트 포인터를 사용하면 delete를 할필요가없어진다. //모든 메모리를 개발자가 직접 관리하는것은 힘들다. //항상 관리를 자동으로 해주는 클래스를 하나 만들어서 관리하는것도 잇다. //수동으로 메모리를 관리하는 포인터를 dull pointer라고 한다. //AutoPtr 사용해보자 AutoPtr&lt;Resource&gt; res = new Resource; try { if(1) throw -1; } catch (...) { //생성자 출력후 예외처리가 진행되었지만 //메모리가 제거가 되어 소멸자도 출력이 되는것을 확인할수있다. } return;}int main() { //이번에는 스마트 포인터에 대해 알아보자 //C언어의 단점이 동적 메모리를 직접 관리(new, delete)를 해주어야한다는것이다. //C++에서 스마트 포인터를 사용하여 이러한 단점을 보완하였다. //스마트 포인터를 위한 개념인 이동에 대하여도 알아보자 // doSomething(); //AutoPtr의 한계 1 AutoPtr&lt;Resource&gt; res1(new Resource); AutoPtr&lt;Resource&gt; res2; cout &lt;&lt; std::boolalpha; cout &lt;&lt; res1.m_ptr &lt;&lt; endl; //res1 주소 cout &lt;&lt; res2.m_ptr &lt;&lt; endl; //nullptr주소 res2 = res1; //move semantics //문제 발생 //res1, res2의 주소가 같아짐 //메모리 주소에 대한 소유권이 res1,res2 둘다 가지고있다. cout &lt;&lt; res1.m_ptr &lt;&lt; endl; cout &lt;&lt; res2.m_ptr &lt;&lt; endl; //res1 메모리 제거후 res2를 지우는데 //res1과 res2의 주소가 같았으므로 //res2를 제거할때 이미 제거된 주소를 다시 지우려고 하고있으므로 오류가 발생한다. //해결방법 //resource의 소유권을 넘겨주는 방식으로 만들어야한다. //res1 - nullptr //res2 = res1의 주소 //소유권 이전하는것을 move semantics라고 한다. //syntax vs semantics //syntax - 문법 //semantics - 의미 /* int x = 1 , y = 2; x + y; +에 대한 syntax - 둘을 더한다. +에 대한 semantics - 둘을 더한다. string str1(\"Hello\"), str2(\"World\"); x + y; +에 대한 syntax - 둘을 더한다. +에 대한 semantics - 문자열을 추가한다. 숫자와 문자열의 +기호는 같지만 의미가 다르다. */ //C++ semantics 종류 //value semantics (copy semantics) //reference semantics (pointer) //move semantics (move) //AutoPtr의 한계 2 //함수의 파라미터로 사용하는 경우 //함수에게 소유권이 이전이 되므로 함수가 종료가 된후 메모리가 삭제가 되어 밖에서 메모리에 접근이 불가능하게 된다. return 0;}Resource.hpp#pragma once#include &lt;iostream&gt;class Resource{public: int m_data[100]; public: Resource() { std::cout &lt;&lt; \"Resource constructor\" &lt;&lt; std::endl; } ~Resource() { std::cout &lt;&lt; \"Resource destoryed\" &lt;&lt; std::endl; }};AutoPtr.hpp#pragma once#include &lt;iostream&gt;//이미 STL에 std::auto_ptr&lt;T&gt;가 존재한다. C++11이상부터 잘 사용안하다가 C++17이상부터는 삭제 되었다.//비슷하게 구현을 한것이다.//복잡한 경우 작동하지 않는 경우가 발생하여 삭제가 되었다고 한다.template&lt;class T&gt;class AutoPtr{public: T *m_ptr = nullptr; public: AutoPtr(T *ptr = nullptr) : m_ptr(ptr) { } ~AutoPtr() { if(m_ptr != nullptr) delete m_ptr; } //소유권을 넘겨주기 위한 생성자 //복사 생성자가 아니다 AutoPtr(AutoPtr &amp;a) { m_ptr = a.m_ptr; //소유권을 넘겨주는 코드 a.m_ptr = nullptr; //소유권을 넘긴 객체는 nullptr화 } AutoPtr&amp; operator = (AutoPtr &amp;a) { //자기자신의 경우 자기자신 반환 if(&amp;a == this) return *this; delete m_ptr; m_ptr = a.m_ptr; a.m_ptr = nullptr; return *this; } T&amp; operator*() const { return *m_ptr; } T* operator-&gt;() const { return m_ptr; } bool isNull() const { return m_ptr == nullptr; } };오른쪽-값 참조// 오른쪽-값 참조// R-Value Reference#include &lt;iostream&gt;using namespace std;int getResult(){ return 100 * 100;}void doSomething(int &amp;lref){ //함수내부에서 lref는 함수 밖에서도 적용이 되어야하므로 move semantics로 가져오게 되면 문제가 발생한다. cout &lt;&lt; \"L-Value ref\" &lt;&lt; endl;}void doSomething(const int &amp;lref){ //함수내부에서 lref는 함수 밖에서도 적용이 되어야하므로 move semantics로 가져오게 되면 문제가 발생한다. cout &lt;&lt; \"L-Value ref\" &lt;&lt; endl;}void doSomething(int &amp;&amp;rref){ //함수내부에서 R-Value이므로 move해서 막써도 상관이 없다. cout &lt;&lt; \"R-Value ref\" &lt;&lt; endl;}int main() { //이번에는 오른쪽값 참조(R-Value Reference)에 대해 알아보자 //지금까지 사용한 L-Value Reference와 비교하면서 알아볼것이다. int x = 5; //=를 기준으로 L-Value = x, R-Value = 5 //x는 메모리공간을 가지고있으며, 5는 사라지는 값이다. int y = getResult(); const int cx = 6; const int cy = getResult(); //L-Value references int &amp;lr1 = x; //Modifiable L-Values// int &amp;lr2 = cx; //Non-modifiable Values// int &amp;lr3 = 5; //R-Values //참조인경우 메모리가 존재한다는것을 전재로 받기 때문에 메모리 주소가 없는 R-Value값은 넣지 못한다. const int &amp;lr4 = x; //Modifiable L-Values const int &amp;lr5 = cx; //Non-modifiable Values const int &amp;lr6 = 5; //R-Values //R-Value references //R-Value만 가질 수 있다. //곧 사라지는것들만 가질 수 있다. // int &amp;&amp;rr1 = x; //Modifiable L-Values// int &amp;&amp;rr2 = cx; //Non-modifiable Values int &amp;&amp;rr3 = 5; //R-Values int &amp;&amp;rrr = getResult(); // const int &amp;&amp;rr4 = x; //Modifiable L-Values// const int &amp;&amp;rr5 = cx; //Non-modifiable Values const int &amp;&amp;rr6 = 5; //R-Values //헷갈리는 요인 cout &lt;&lt; rr3 &lt;&lt; endl; rr3 = 10; cout &lt;&lt; rr3 &lt;&lt; endl; //곧 사라질 것들만 가진다고 하였는데, 저장이 되고 값도 수정이 가능하다 //R-Value를 자기 자신만 변경가능하고 자기자신만 접근 가능하다 라고 생각하면된다. //클래스나 함수의 데이터를 rr3에 이전을 해도 문제가 없고 다시 사용을 할수있게 해준다. // L/R Value reference parameters //이해를 위한 함수 사용 doSomething(x); //L-Value doSomething(5); //R-Value doSomething(getResult()); //R-Value doSomething(cx); return 0;}이동 생성자와 이동 대입main.cpp// 이동 생성자와 이동 대입// Move constructors &amp; Move assignment#include \"Timer.hpp\"#include \"AutoPtr.hpp\"#include \"Resource.hpp\"AutoPtr&lt;Resource&gt; generateResource(){ AutoPtr&lt;Resource&gt; res(new Resource(10000000)); return res;}int main() { //이번에는 이동 생성자와 이동 대입에 대해 알아보자 //move semantics가 구체적으로 어떤식으로 작동하는지 생성자와 대입으로 살펴보자 using namespace std; streambuf* orig_buf = cout.rdbuf(); //console에 출력물이 많아지면 출력하는 시간이 길어질수있다. //시간 성능을 정확하게 측정을 하고싶다면 출력을 막아줘야한다.// cout.rdbuf(NULL); //cout log 출력 막는 방법 //disconnect cout from buffer Timer timer; { AutoPtr&lt;Resource&gt; main_res; main_res = generateResource(); } std::cout.rdbuf(orig_buf); //move semantics 사용시 속도가 엄청 빨라진다. //깊은 복사하는부분이 출력이 되지않는다. timer.elapsed(); return 0;}Resource.hpp#pragma once#include &lt;iostream&gt;class Resource{public: int *m_data = nullptr; unsigned m_length = 0; public: Resource() { std::cout &lt;&lt; \"Resource default constructor\" &lt;&lt; std::endl; } Resource(unsigned length) { std::cout &lt;&lt; \"Resource length constructor\" &lt;&lt; std::endl; this -&gt; m_data = new int[length]; this -&gt; m_length = length; } Resource(const Resource &amp;res) { std::cout &lt;&lt; \"Resource copy constructor\" &lt;&lt; std::endl; Resource(res.m_length); for (unsigned i = 0; i &lt; m_length; ++i) { m_data[i] = res.m_data[i]; } } ~Resource() { std::cout &lt;&lt; \"Resource destoryed\" &lt;&lt; std::endl; if(m_data != nullptr) delete [] m_data; } Resource &amp; operator = (Resource &amp; res) { std::cout &lt;&lt; \"Resource copy assignment\" &lt;&lt; std::endl; if(&amp;res == this) return *this; if(this -&gt; m_data != nullptr ) delete [] m_data; m_length = res.m_length; m_data = new int[m_length]; for (unsigned i = 0; i &lt; m_length; ++i) { m_data[i] = res.m_data[i]; } return *this; } void print() { for (unsigned i = 0; i &lt; m_length; ++i) std::cout &lt;&lt; m_data[i] &lt;&lt; \" \"; std::cout &lt;&lt; std::endl; }};AutoPtr.hpp#pragma once#include &lt;iostream&gt;template&lt;class T&gt;class AutoPtr{public: T *m_ptr; public: AutoPtr(T *ptr = nullptr) : m_ptr(ptr) { std::cout &lt;&lt; \"AutoPtr default constructor\" &lt;&lt; std::endl; } ~AutoPtr() { std::cout &lt;&lt; \"AutoPtr destructor\" &lt;&lt; std::endl; if(m_ptr != nullptr) delete m_ptr; } AutoPtr(const AutoPtr &amp;a) { std::cout &lt;&lt; \"AutoPtr copy constructor\" &lt;&lt; std::endl; //deep copy m_ptr = new T; *m_ptr = *a.m_ptr; //모든객체의 값을 깊은 복사를 하므로 오래 걸릴것이다. } AutoPtr&amp; operator = (const AutoPtr &amp;a) { std::cout &lt;&lt; \"AutoPtr copy assignment\" &lt;&lt; std::endl; if(&amp;a == this) return *this; if(m_ptr != nullptr) delete m_ptr; //deep copy m_ptr = new T; *m_ptr = *a.m_ptr; return *this; } // //R-Values reference// AutoPtr(AutoPtr &amp;&amp;a) : m_ptr(a.m_ptr)// {// std::cout &lt;&lt; \"AutoPtr move constructor\" &lt;&lt; std::endl;//// a.m_ptr = nullptr;// //R-Value라서 어차피 사라질 데이터인데 굳이? 없애는 작업이 필요한가?// //혹시 모르는 상황을 위해 확실하게 삭제를 해주는것이 좋다.//// }// // //R-Values reference// AutoPtr&amp; operator = (AutoPtr &amp;&amp;a)// {// std::cout &lt;&lt; \"AutoPtr move assignment\" &lt;&lt; std::endl;// // if(&amp;a == this)// return *this;// // if(!m_ptr) delete m_ptr;// // //shallow copy// m_ptr = a.m_ptr;// a.m_ptr = nullptr;// // return *this;// } T&amp; operator*() const { return *m_ptr; } T* operator-&gt;() const { return m_ptr; } bool isNull() const { return m_ptr == nullptr; } };std::movestd::unique_ptrstd::shared_ptr순환 의존성 문제와 std::weak_ptr" }, { "title": "[C++] Chapter.14 예외처리", "url": "/posts/Cpp-Ch14/", "categories": "Language, C++", "tags": "c++", "date": "2022-09-24 22:20:19 +0900", "snippet": "예외처리의 기본// 예외 처리의 기본// Exception Handing#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;//ch가 존재하는 문자열인지 확인 하는 함수int findFirstChar(const char * string, char ch){ for (std::size_t idx = 0; idx &lt; strlen(string); ++idx) { if(string[idx] == ch) return idx; } //ch가 존재하지않는다면 -1 반환 //예외처리 부분 return -1;}double divide(int x, int y, bool &amp;success){ //0으로 나눌수없으므로 0.0을 반환 if(y == 0) { success = false; return 0.0; } success = true; return static_cast&lt;double&gt;(x) / y;}int main() { //이번에는 예외처리에 대해 알아보자 //좋은 프로그래머가 되기 위해 비정상적인 상황에 대해 안정적으로 실행이 되도록 만들어야 한다. //비정상적인 상황, 즉 예외적인 상황에 처리를 하는것을 예외처리라고 한다. //이번에는 기본적인 방법에 대해 알아보자 bool success; double result = divide(5, 3, success); if(!success) std::cerr &lt;&lt; \"An Error occurred\" &lt;&lt; std::endl; //오류 발생시 오류문구 출력 else std::cout &lt;&lt; \"Result is \" &lt;&lt; result &lt;&lt; std::endl; //정상 작동시 결과 값 출력 std::ifstream input_file(\"temp.txt\"); //파일 존재 유무 확인 if(!input_file) std::cerr &lt;&lt; \"Cannot open file\" &lt;&lt; endl; //파일이 없는경우 오류 문구 출력 //이 예외처리 방식은 깔끔하지 않아보이지만 전통적인 C++방식으로는 이런식으로 많이 작성했다. //1. 퍼포먼스 측면에서 좋다. //2. 대체방법이 없었다. //다음에 배울 예외처리는 관점이 약간 달라진다. //다음에 배울 throw, try-catch방식은 깔끔해보이지만 //퍼포먼스가 낮아진다. //퍼포먼스 중요한 경우 잘 사용하지 않는다. //예외처리를 사용하는경우 //예측할수없는경우 //서버의 경우 - 네트워크의 경우 - 갑자기 다운 되는 경우 //예외처리를 안사용하는 분야도 존재하지만, 사용을 해야한다면 반드시 모든 오류 상황에 대해 예외처리를 해주어야한다. //기초적인 문법 //try, catch, throw //throw - 오류를 던진다! //catch - 오류를 받는다! double x; cin &gt;&gt; x; try { if(x &lt; 0.0) throw std::string(\"Negative input\"); //음수의 경우 오류 메시지를 날려준다. cout &lt;&lt; sqrt(x) &lt;&lt; endl; } //throw된 정보를 받는다. catch(std::string error_message) { //error_message에 throw로 날려준 string값을 catch하여 가져온다. cout &lt;&lt; error_message &lt;&lt; endl; } //주의사항 //auto casting이 안된다. //throw와 오류를 받는 catch에 자료형이 같게 만들어줘야한다. try { throw -1.0; //throw -1.0; 인경우 double형이므로 catch에서 오류 발생 } catch (int x) { cout &lt;&lt; \"Catch integer\" &lt;&lt; x &lt;&lt; endl; } catch (double x) { cout &lt;&lt; \"Catch double\" &lt;&lt; x &lt;&lt; endl; } catch(std::string error_message) { //error_message에 throw로 날려준 string값을 catch하여 가져온다. cout &lt;&lt; error_message &lt;&lt; endl; } //catch문이 여러개를 사용할수있다. //해당 오류에 관한 자료형의 catch가 없는경우 오류를 받아줄수있는곳이 없으므로 오류가 컴파일 오류가 발생한다. //throw와 catch의 자료형 타입이 같아야한다. return 0;}예외처리와 스택 되감기// 예외처리와 스택 되감기// stack Unwinding#include &lt;iostream&gt;using namespace std;//추가 문법//void last() throw(int) exception specifier//exception specifier//함수 정의,선언시//throw(data type)을 붙여주면//data type에 대한 예외처리를 할수도있다.라고 알려주는것이다.//항상 data type에 맞춘다는 문맥이 아니라 할 수 있다 라는 문맥이 강하다.//불필요한것이 아닌가? 라는 견해가 많다고 한다.//()에 아무것도 없는경우 이 함수는 throw를 하지않을것이다라는 험수를 구현하는것이다.void last(){ cout &lt;&lt; \"last\" &lt;&lt; endl; cout &lt;&lt; \"Throws exception\" &lt;&lt; endl; throw -1; //-1인 경우 디버그로 찍어보면 스탭으로 찍어보면 throw이후 first를 출력한다. //frist를 출력하는 이유를 알아보자 cout &lt;&lt; \"End last\" &lt;&lt; endl;}void third(){ cout &lt;&lt; \"third\" &lt;&lt; endl; last(); //last에서 throw발생후 여기를 와서 catch를 찾으니 없어서 스택에서 unwinding발생 //thrid를 호출한 second로 돌아감 //오류를 잡지 못해 실행 안함 cout &lt;&lt; \"End third\" &lt;&lt; endl;}void second(){ cout &lt;&lt; \"second\" &lt;&lt; endl; try { third(); } catch (double) { //unwinding에 의해 second에 진입후 catch를 만났는데 throw값이 int type이므로 double type이므로 무시하고 second를 호출한 first로 넘어간다. cerr &lt;&lt; \"second caught double exception\" &lt;&lt; endl; } //오류를 잡지 못해 실행 안함 cout &lt;&lt; \"End second\" &lt;&lt; endl;}void first(){ cout &lt;&lt; \"first\" &lt;&lt; endl; try { second(); } catch (int) { //unwinding에 의해 second의 catch 조건이 double이므로 무시하고 first() catch에 도착한후 int type인것을 체크하고 같은 type이므로 catch실행 cerr &lt;&lt; \"first caught int exception\" &lt;&lt; endl; } //오류잡고 나서 다음 코드실행 cout &lt;&lt; \"End first\" &lt;&lt; endl;}int main() { //함수가 함수를 호출하는 구조가 구현이 된다면 스택에 함수가 쌓일것이다. //이러한 구조에서 예외처리를 하게 되면 스택이 되감아가면서 예외를 어디서 catch를 해야하는지 찾는다. //이러한 행위를 스택 되감기(Stack Unwinding)라고 한다. cout &lt;&lt; \"Start\" &lt;&lt; endl; try { first(); } catch (int) { //cout, cerr, clog의 차이는 거의없다. //방송 채널에 비유해서 생각하면 된다. //cout - 출력을 버퍼에 담고 바로 출력 안하는 경우가 존재한다. 예시 - endl과 '\\n'를 사용할때의차이 //cerr - 출력을 버퍼를 통하지않고 endl과 '\\n'가 없어도 출력한다. //clog - 기록용 cerr &lt;&lt; \"main caught int exception\" &lt;&lt; endl; } //가능한 발생가능한 오류들에 대해 예외처리를 하였지만, 진짜 생각지도 못한 경우에 오류가 발생하는경우 처리가 안되어 런타임에러가 발생한다. //예제로 설명을 하자면 int error, double error 예외상황에 대해 예외처리를하였지만, 생각지도못한 char type이 나온다면 어떻게 해야하는가? //이런 경우에 대한 최후의 보루같은 방식이 존재한다. //uncaught exceptions //잡지못한 오류를 잡는 방법 catch(...) //catch-all handler { cerr &lt;&lt; \"main caught ellipses exception\" &lt;&lt; endl; } //모든 오류를 잡는다. //최후의 보루방법 cout &lt;&lt; \"End main\" &lt;&lt; endl; return 0;}예외 클래스와 상속// 예외 클래와 상속#include &lt;iostream&gt;using namespace std;//예외 처리 클래스class Exception{public: void report() { cerr &lt;&lt; \"Exception report\" &lt;&lt; endl; }};class ArrayExcption : public Exception{public: void report() { cerr &lt;&lt; \"Array Exception\" &lt;&lt; endl; }};class MyArray{private: int m_data[5]; public: int &amp; operator [] (const int &amp; idx) { //기본 자료형의 throw 방식 //if (idx &lt; 0 || idx &gt;= 5) throw -1; //class throw 방식 if (idx &lt; 0 || idx &gt;= 5) throw ArrayExcption(); //Exception의 객체를 만들어서 던져주는 형식 return m_data[idx]; }};void doSomething(){ MyArray my_arr; try { my_arr[100]; } catch (const int &amp; x) { cerr &lt;&lt; \"Exception \" &lt;&lt; x &lt;&lt; endl; }// catch (Exception &amp; e) {// e.report();// }// catch (ArrayExcption &amp; e) {// e.report();// } //객체 잘림으로 인하여 Exception.report()가 실행이 된다. //ArrayExcption이 발생해야하지만, 이미 Excepion에서 먼저 잡혀서 Exception.report()가 실행이 된다. //대응 방법 catch (ArrayExcption &amp; e) { cout &lt;&lt; \"doSomething()\" &lt;&lt; endl; e.report(); throw e; //rethrow main()에서 받기위한 throw } catch (Exception &amp; e) { cout &lt;&lt; \"doSomething()\" &lt;&lt; endl; e.report(); } //두개의 위치를바꿔준다. }int main() { //이번에는 예외클래스에 대해 알아보자 //지금까지는 기본자료형에 관하여 throw하는것을 배웟다면 이번에는 사용자 정의 자료형으로 throw를 해보자 doSomething(); //catch에서 받는 작업들을 정리 하기위해 예외 클래스를 만들 수 있다. //주의사항 예외처리 클래스를 상속 받을떄 주의 사항이 몇가지 발생한다. try { doSomething(); } catch (ArrayExcption &amp; e) { //doSomething()에서 이미 오류가 잡혀서 여기서 예외처리를 하지않는다. //여기서도 예외처리를 무조건 해야한다면 어떻게 해야하는가? //doSomething()에서 catch한것을 다시 throw해줄수있다. //rethrow라고 부른다. cout &lt;&lt; \"main()\" &lt;&lt; endl; e.report(); } catch(Exception &amp; e) { cout &lt;&lt; \"main()\" &lt;&lt; endl; e.report(); } return 0;}exception 소개// exception 소개#include &lt;iostream&gt;#include &lt;exception&gt;#include &lt;string&gt;using namespace std;//class CustomException : public exception{public: //exception의 what()을 오버라이딩 //사용자 정의 예외처리 클래스에서도 what을 작동하기 위해 오버라이딩해준다. const char * what() const noexcept override { return \"Custom exception\"; } //noexcept C++11이상부터는 붙여줘야한다고 한다. };int main() { //이번에는 STL에 존재하는 Exception class에서 대해 알아보자 //다양한 경우의 예외처리에 대해 이미 STL에 구현이 되어있다. //구현하는 시간을 단축하기위해 STL의 Exception class를 사용하자 try { //이미 구현 되어있는 string의 exception 확인방법// string s;// s.resize(-1); //execption만 가져다 사용하는방법// throw runtime_error(\"Bad thing happend\"); //직접 오류를 던져 줄수있다. throw CustomException(); //사용자 정의 예외처리 사용 } catch (exception &amp; e) { cerr &lt;&lt; e.what() &lt;&lt; endl; //Exception은 부모 클래스이다. //여러 많은 excecption중에 자식중 하나에서 오류가 발생하여 처리가되는것이다. //정확하게 어느 자식 클래스에서 잡아준것인지 알기 위해서는 typeid를 사용해보면된다. cout &lt;&lt; typeid(e).name() &lt;&lt; endl; //length_error출력 //length_error class에서 발생한 오류이다. 라고 정확하게 파악가능하다. } catch (length_error &amp; e) { cout &lt;&lt; \"Length error\" &lt;&lt; endl; cerr &lt;&lt; e.what() &lt;&lt; endl; } return 0;}함수 try// 함수 try#include &lt;iostream&gt;using namespace std;class A{private: int m_x;public: A(int x) : m_x(x) { if(x &lt;= 0) throw 1; }};class B : public A{public:// B(int x) : A(x)// {} //B생성자에서 예외처리 하는방법 - try용법 사용 B(int x) try : A(x) { } catch (...) { cout &lt;&lt; \"Catch in B constructor\" &lt;&lt; endl;// throw; //throw가 없지만 main에서도 예외처리를 한번더 한다. //생성자에서 예외처리를 하는경우 //throw가 없어도 rethrow를 해준것처럼 작동한다. }};void doSomething()try{ throw -1;}catch(...){ cout &lt;&lt; \"Catch in doSomething()\" &lt;&lt; endl;}//try문법은 이런식으로 사용한다.//일반적으로 일반 함수에 대해서는 잘 사용하지않고 - 알아보기 힘듬//생성자 예외처리에서 많이 사용한다.int main() { //이번에는 try()의 문법에 대해 알아보자 //생성자에서 발생하는 오류를 처리하는것도 중요하다 //초기화 리스트에서 발생하는 예외를 처리하는데 많이사용하는 try함수에 대해 알아보자 try {// doSomething(); B b(0); } catch (...) { cout &lt;&lt; \"Catch in main()\" &lt;&lt; endl; } return 0;}예외처리의 위험성과 단점// 예외처리의 위험성과 단점#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class A{public: ~A() { throw \"error\"; }};int main() { //이번에는 예외처리의 위험성과 단점에 대해 알아보자 // //1. 예외처리할때 메모리 처리가 안되어 메모리 누수 발생// //이 단점은 스마트포인터를 사용하면 해결이 된다.// try {// int *i = new int[1000000];//// unique_ptr&lt;int&gt; up_i(i);// //스마트 포인터 사용방법// //이것을 사용하면 메모리할당이 영역을 벗어나게 되면, throw를 만나면 알아서 삭제해준다.// throw \"error\";//// delete [] i; //throw가 되면 메모리가 삭제가 안된다.// } catch (...) {// cout &lt;&lt; \"Catch\" &lt;&lt; endl;// } //2. 소멸자 안에서 throw를 사용하지 못한다.// try {// A a;// } catch (...) {// cout &lt;&lt; \"Catch\" &lt;&lt; endl;// } //3. for문에서 예외처리를 반복적으로 하게되면 프로그램이 느려진다. //빈번하게 사용되는곳에서 예외처리를 하게되면 느려지게 된다. //4. 모든 오류를 에외처리하려고 하지말것 //모든 오류에 대해 예외처리를 만들지말고 if를 이용하여 오류를 거르는 작업부터 진행하자 // return 0;}" }, { "title": "[C++] Chapter.13 템플릿", "url": "/posts/Cpp-Ch13/", "categories": "Language, C++", "tags": "c++", "date": "2022-09-24 22:20:19 +0900", "snippet": "함수 템플릿// 함수 템플릿#include &lt;iostream&gt;#include \"Cents.hpp\"using namespace std;//int getMax(int x ,int y)//{// return (x &gt; y) ? x : y;//}////double getMax(double x ,double y)//{// return (x &gt; y) ? x : y;//}////float getMax(float x ,float y)//{// return (x &gt; y) ? x : y;//}//템플릿 사용방법template&lt;typename T&gt;T getMax(T x, T y){ return (x &gt; y) ? x : y;}int main() { //이번시간부터 템플릿에 대해 알아볼것이다. //프로그래머의 단순작업을 줄여주기 위한 방법들이 여러가지가 존재한다. //그중 하나의기술인 템플릿에 대해 알아보자 //여러가지 자료형에 대해 비슷한코드를 사용하는것을 방지한다. //getMax가 여러가지자료형을사용하는 경우가 발생하는경우 하나하나 만들고 하나 수정하면 모든함수를 수정해야하는 불상사가 발생한다. //템플릿을 사용하면 수월해진다. cout &lt;&lt; getMax(1, 2) &lt;&lt; endl; cout &lt;&lt; getMax(1.2, 2.5) &lt;&lt; endl; cout &lt;&lt; getMax(1.2f, 2.7f) &lt;&lt; endl; cout &lt;&lt; getMax('a', 'c') &lt;&lt; endl; //컴파일러가 알아서 자료형을 맞춰서 실행한다. //사용자 정의 타입도 사용가능하다. //class 타입의 함수 사용 cout &lt;&lt; getMax(Cents(5), Cents(9)) &lt;&lt; endl; //&lt; , &lt;&lt; 오버로딩이 필요하다. //템플릿을 사용할때 사용하기위해 필요한 기능들이 구현이 되어있어야한다. //instantiation //객체 인스턴스 - 객체가 데이터를 가지고 존재하는것 //템플릿 인스턴스 - 자료형이 정해져있지않고 함수를 호출할때 자료형이 정해질때 //~~형으로 인스턴스화 되었다라고 말할수있다. return 0;}클래스 템플릿main.cpp// 클래스 템플릿#include \"Myarray.hpp\"int main() { //이전에는 함수를 템플릿으로 만들어 관리하는법에 대해 알아보았다. //이번에는 클래스를 템플릿으로 만들어 관리하는 방법에 대해 알아보자 //오류발생 //template arguments of 'Myarray' //Myarray my_arr(10); Myarray&lt;double&gt; my_arr(10); //타입을 지정해주어야한다. for (int i = 0; i &lt; my_arr.getLength(); ++i) { my_arr[i] = i * 0.5; } my_arr.print(); Myarray&lt;char&gt; my_arr2(10); //타입을 지정해주어야한다. for (int i = 0; i &lt; my_arr.getLength(); ++i) { my_arr2[i] = i + 65; } my_arr2.print(); return 0;}Myarray.h#pragma once#include &lt;assert.h&gt;#include &lt;iostream&gt;//변경사항 - int말고 다른 자료형도 들어가게 만들어라template&lt;typename T&gt;//데이터 처리하는 부분에서 int자료형을 T로 고쳐주는 작업이 필요class Myarray{private: int m_length; //길이는 T로 변경하면 안된다. //int *m_data; //int type을 담기 위한 포인터 T *m_data; //T type을 담기 위한 포인터 public: Myarray() { m_length = 0; m_data = nullptr; } Myarray(int length) //길이는 건드리지 않는다. { //m_data = new int [length]; m_data = new T [length]; //데이터 처리부분 자료형 수정 m_length = length; } ~Myarray() { reset(); } void reset() { delete [] m_data; m_data = nullptr; m_length = 0; } //int &amp; operator[] (int index) T &amp; operator[] (int index) //반환형 수정 { assert(index &gt;= 0 &amp;&amp; index &lt; m_length); return m_data[index]; } int getLength() { return m_length; } void print();};//template&lt;typename T&gt;//void Myarray&lt;T&gt;::print()//{// for (int i = 0; i &lt; m_length; ++i)// std::cout &lt;&lt; m_data[i] &lt;&lt; \" \";// // std::cout &lt;&lt; std::endl;////}Myarray.cpp//// Myarray.cpp// 13_2//// Created by YdO_ObY on 2022/10/15.//#include \"Myarray.hpp\"//링킹에러 발생 template&lt;typename T&gt;void Myarray&lt;T&gt;::print(){ for (int i = 0; i &lt; m_length; ++i) std::cout &lt;&lt; m_data[i] &lt;&lt; \" \"; std::cout &lt;&lt; std::endl;}//cpp에 바디부분을 만들어서 include하면 오류가 발생하는 이유//빌드를 하게되면 main에서 컴파일러가 Myarray에서 &lt;&gt;안에 있는타입으로 인스턴스로 만들어야하는것은 알수있다.//하지만 main에서 print()를 호출을 할때 Myarray.cpp에서 컴파일할때 자료형을 무엇으로 잡아야하는지 모르기 때문에 발생하는 현상이다.//cpp을 main에서 include하면 에러가 사라지긴하나, cpp include는 웬만해서는 사용하지말아라.//해결방법//컴파일 타입을 명시적으로 알려주면 된다.//explicit instantiation//함수 하나만 설정하는 방법//template void Myarray&lt;char&gt;::print();//template void Myarray&lt;double&gt;::print();//class자체를 하는방법template class Myarray&lt;char&gt;;template class Myarray&lt;double&gt;;자료형이 아닌 템플릿 매개변수main.cpp// 자료형이 아닌 템플릿 매개변수// Non-type Parameters#include \"Myarray.hpp\"int main() { //함수, 클래스 템플릿은 자료형이 포함되지만 //여러가지 자료형을 일반화 하기위해 템플릿을 사용하였다. //이번에는 자료형이 아닌 경우에 템플릿을 사용하는 방법에 대해 알아보자 Myarray&lt;double, 100&gt; my_array; //array&lt;double, 100&gt; 처럼 100이 Non-type parameter이다. //예시는 크기를 위한 parameter로 구현하였지만 //알고리즘 구현할떄, 2차원, 3차원 구분을 위한 템플릿으로 많이사용한다. for (int i = 0; i &lt; my_array.getLength(); ++i) { my_array[i] = i +65; } my_array.print(); return 0;}Myarray.hpp#pragma once#include &lt;assert.h&gt;#include &lt;iostream&gt;//변경사항 - int말고 다른 자료형도 들어가게 만들어라template&lt;typename T, unsigned int T_SIZE&gt;//array의 크기를 지정해줄 non-type parameter를 만들어주는 방법class Myarray{private:// int m_length; 길이는 T_SIZE가 컴파일타임에 결정이 되므로 필요없다. T *m_data; //T type을 담기 위한 포인터 public: Myarray() { m_data = new T [T_SIZE]; //동적할당 크기 지정 } ~Myarray() { reset(); } void reset() { delete [] m_data; m_data = nullptr; } //int &amp; operator[] (int index) T &amp; operator[] (int index) //반환형 수정 { assert(index &gt;= 0 &amp;&amp; index &lt; T_SIZE); return m_data[index]; } int getLength() { return T_SIZE; } //Non-type parameter의 경우 //explicit instantiation로 인해 구현부를 나누게 되어버리면 //크기가 각 경우에 따라 추가가 되어야하므로 헤더에 구현하는것이 좋다. void print() { for (int i = 0; i &lt; T_SIZE; ++i) std::cout &lt;&lt; m_data[i] &lt;&lt; \" \"; std::cout &lt;&lt; std::endl; } };함수 템플릿 특수화main.cpp// 함수 템플릿 특수화// Specialization &lt;특수화&gt;#include \"Storage.hpp\"using namespace std;template&lt;typename T&gt;T getMax(T x, T y){ return (x &gt; y) ? x : y;}//Specialization 예시template&lt;&gt;//char type을 사용하는경우 아래 함수가 호출이 된다.char getMax(char x, char y){ cout &lt;&lt; \"Warning : comparing chars\" &lt;&lt; endl; return (x &gt; y) ? x : y;}//멤버 함수 Specializationint main() { // 이번에는 함수 템플릿에 대해 알아보자 cout &lt;&lt; getMax&lt;int&gt;(1, 2) &lt;&lt; endl; //자료형을 자동으로 잡아준다. //cout &lt;&lt; getMax&lt;double&gt;(1, 2) &lt;&lt; endl; //이런식으로 인스턴스를 강제로 double로 만들수있다. //문자의 경우 사용자를 위해 경고문을 띄워줄수있다. //특수한 경우 따로 함수를 만들수있다. cout &lt;&lt; getMax('a', 'b') &lt;&lt; endl; Storage&lt;int&gt; nValue(5); Storage&lt;double&gt; dValue(6.7); nValue.print(); //5 출력 dValue.print(); //6.7출력 return 0;}Storage.hpp#pragma once#include &lt;iostream&gt;template&lt;class T&gt;class Storage{private: T m_value; public: Storage(T value) { m_value = value; } ~Storage() {} void print() { std::cout &lt;&lt; m_value &lt;&lt; '\\n'; }};template&lt;&gt;void Storage&lt;double&gt;::print(){ std::cout &lt;&lt; \"Double Type\" &lt;&lt; '\\n'; std::cout &lt;&lt; std::scientific &lt;&lt; m_value &lt;&lt; '\\n';}//코드를 나누기위해 cpp에 옮기면 오류발생/* 해결 방법 1 그냥 헤더에 냅두기 해결 방법 2 cpp include 하기 대부분의 경우 방법 1을 이용한다. */클래스 템플릿 특수화main.cpp// 클래스 템플릿 특수화#include &lt;iostream&gt;#include &lt;array&gt;#include \"Storage8.hpp\"using namespace std;template&lt;typename T&gt;class A{public: A(const T &amp; input) {} void doSomething() { cout &lt;&lt; typeid(T).name() &lt;&lt; endl; } void test() {}};//char type specialization//코드양은 줄지않고 오히려 는다.//새로운 클래스를 하나 더 만드는것과 같다.template&lt;&gt;class A&lt;char&gt;{public: A(const char &amp; input) {} void doSomething() { cout &lt;&lt; \"Char type specialization\" &lt;&lt; endl; } };int main() { //이번에는 클래스 템플릿 특수화에 알아보자 A&lt;int&gt; a_int(1); A&lt;double&gt; a_double(3.14); A&lt;char&gt; a_char('a'); // A a_int2(1); //함수 템플릿의 경우 파라미터로 구분이 가능하지만, //클래스 템플릿의 경우 생성자 파라미터로 자료형 구분이 되지않는다. //C++17부터는 파라미터로 자료형 구분 가능 a_int.doSomething(); a_double.doSomething(); //특수화된 함수 호출 a_char.doSomething(); a_int.test(); // a_char.test(); //특수화된 클래스에 test()가 없으므로 오류발생 Storage8&lt;int&gt; intStorage; for (int cnt = 0; cnt &lt; 8; ++cnt) { intStorage.set(cnt, cnt); } for (int cnt = 0; cnt &lt; 8; ++cnt) { cout &lt;&lt; intStorage.get(cnt) &lt;&lt; '\\n'; } cout &lt;&lt; \"Sizeof Storage8&lt;int&gt; \" &lt;&lt; sizeof(Storage8&lt;int&gt;) &lt;&lt; endl; //32바이트 사용 Storage8&lt;bool&gt; boolStorage; for (int cnt = 0; cnt &lt; 8; ++cnt) { boolStorage.set(cnt, cnt &amp; 3); } for (int cnt = 0; cnt &lt; 8; ++cnt) { cout &lt;&lt; (boolStorage.get(cnt) ? \"true\" : \"false\") &lt;&lt; '\\n'; } cout &lt;&lt; \"Sizeof Storage8&lt;bool&gt; \" &lt;&lt; sizeof(Storage8&lt;bool&gt;) &lt;&lt; endl; //특수화가 적용된 경우 1바이트 사용 //특수화가 미적용 경우 8바이트 사용 return 0;}Storage8.hpp#pragma oncetemplate&lt;class T&gt;class Storage8{private: T m_array[8]; public: void set(int idx, const T&amp; value) { m_array[idx] = value; } const T&amp; get(int idx) { return m_array[idx]; }};template&lt;&gt;class Storage8&lt;bool&gt;{private: unsigned char m_data; public: Storage8() : m_data(0) {} void set(int idx, bool value) { unsigned char mask = 1 &lt;&lt; idx; if(value) m_data |= mask; else m_data &amp;= ~mask; } bool get(int idx) { unsigned char mask = 1 &lt;&lt; idx; return (m_data &amp; mask) != 0; }};템플릿을 부분적으로 특수화하기// 템플릿을 부분적으로 특수화 하기// Partial Specialization#include &lt;iostream&gt;//#include &lt;string&gt;using namespace std;template&lt;class T, int size&gt;//파라미터가 두가지인 템플릿class StaticArray_BASE{private: T m_array[size]; public: T * getArray() {return m_array;} T&amp; operator[](int idx) { return m_array[idx]; } void print() { for (int cnt = 0; cnt &lt; size; ++cnt) { cout &lt;&lt; (*this)[cnt] &lt;&lt; ' '; } cout &lt;&lt; endl; }};//클래스 내부 함수에서 특수화 하는방법//클래스를 상속 받는 방법template&lt;class T, int size&gt;class StaticArray : public StaticArray_BASE&lt;T, size&gt;{ };template&lt;int size&gt;class StaticArray&lt;char, size&gt; : public StaticArray_BASE&lt;char, size&gt;{public: void print() { for (int cnt = 0; cnt &lt; size; ++cnt) { cout &lt;&lt; (*this)[cnt]; } cout &lt;&lt; endl; }};//싱속을 받았으므로 클래스의 모든 함수를 오버라이딩하는것이 아닌 print만 오버라이딩 해주면 된다.//반복적으로 구현하는것이 없어지므로 편하다.//이런식으로 부분적으로 특수화가 가능하다.//클래스 외부 함수//template&lt;typename T, int size&gt;//void print(StaticArray&lt;T, size&gt; &amp; arr)//{// for (int cnt = 0; cnt &lt; size; ++cnt) {// cout &lt;&lt; arr[cnt] &lt;&lt; ' ';// }// cout &lt;&lt; endl;//}//문자형의 경우 빈칸없는 print로 Specialization//template&lt; int size&gt;//void print(StaticArray&lt;char, size&gt; &amp; arr)//{// for (int cnt = 0; cnt &lt; size; ++cnt) {// cout &lt;&lt; arr[cnt];// }// cout &lt;&lt; endl;//}int main() { //이번에는 부분적으로 특수화 하는 방법에 대해 알아보자 StaticArray&lt;int, 4&gt; int4; int4[0] = 1; int4[1] = 2; int4[2] = 3; int4[3] = 4; StaticArray&lt;char, 14&gt; char14;// char14[0] = 'H';// char14[1] = 'e';// char14[2] = 'l';// char14[3] = 'l';// char14[4] = 'o'; strcpy(char14.getArray(), \"Hello, World\"); //문자열 일일히 넣기 귀찮아서 복사로 대체 //xcode에선 strcpy_s가 존재하지않는다. //클래스 외부 함수// print(int4);//// print(char14); //문자열이 한칸씩 빈칸이 생김 //char인경우 빈칸을 없애고 싶다. //파라미터가 T, size로 두개이므로 특수화를 사이즈는 냅두고 자료형에만 줄수있다. //클래스 내부 함수 int4.print(); char14.print(); return 0;}포인터에 대한 템플릿 특수화// 포인터에 대한 템플릿 특수화#include &lt;iostream&gt;using namespace std;template&lt;class T&gt;class A{private: T m_value; public: A(const T &amp; input) : m_value(input) {} void print() { cout &lt;&lt; m_value &lt;&lt; endl; //포인터 값의 경우 주소값 출력 }};//포인터에 대한 템플릿template&lt;class T&gt;class A&lt;T*&gt;{private: T* m_value; public: A(T * input) : m_value(input) {} void print() { cout &lt;&lt; *m_value &lt;&lt; endl; //포인터의 경우 값을 출력 }};int main() { //이번에는 파라미터가 포인터의 경우 템플릿 특수화에 대해 알아보자 A&lt;int&gt; a_int(123); a_int.print(); int temp = 456; A&lt;int*&gt; a_int_ptr(&amp;temp); a_int_ptr.print(); double temp_d = 3.141592; A&lt;double*&gt; a_double_ptr(&amp;temp_d); a_double_ptr.print(); return 0;}멤버 함수를 한번 더 템플릿화 하기// 멤버 함수를 한번 더 템플릿화 하기// Templatize#include &lt;iostream&gt;using namespace std;//A class templatizetemplate&lt;class T&gt;class A{private: T m_value; public: A(const T &amp; input) : m_value(input) {} void print() { cout &lt;&lt; m_value &lt;&lt; endl; //포인터 값의 경우 주소값 출력 } //멤버 함수 템플릿 template&lt;typename TT&gt; void doSomething(const TT &amp; input) { cout &lt;&lt; typeid(T).name() &lt;&lt; \", \" &lt;&lt; typeid(TT).name() &lt;&lt; endl; }};int main() { //이번에는 클래스가 템플릿화되어있는 경우에 멤버함수에 추가적으로 멤버함수를 템플릿화 하는 방법에 대해 알아보자 A&lt;int&gt; a_int(123); a_int.print(); a_int.doSomething&lt;float&gt;(123); //T = int , TT = float a_int.doSomething(123.4); //파라미터로 구분이 되는경우 템플릿 파라미터 필요없다. //T = int , TT = double return 0;}" }, { "title": "[C++] Chapter.12 가상 함수들", "url": "/posts/Cpp-Ch12/", "categories": "Language, C++", "tags": "c++", "date": "2022-09-24 22:20:19 +0900", "snippet": "다형성의 기본 개념// 다형성의 기본 개념// 자식 클래스의 객체에 부모 클래스의 포인터를 사용한다면?#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Animal{protected: string m_name; public: Animal(string name) : m_name(name) {} string getName() { return m_name; } virtual void speak() const //virtual 키워드 사용 { cout &lt;&lt; m_name &lt;&lt; \" ??? \" &lt;&lt; endl; }};//cat은 animal의 일종이다.//Animal 상속//일반화된 Animal class로 구현한다.class Cat : public Animal{public: Cat(string name) : Animal(name) {} void speak() const { cout &lt;&lt; m_name &lt;&lt; \" Meow \" &lt;&lt; endl; }};class Dog : public Animal{public: Dog(string name) : Animal(name) {} void speak() const { cout &lt;&lt; m_name &lt;&lt; \" Woof \" &lt;&lt; endl; }};int main() { //지금까지 포인터에 대해 여러가지 측면을 살펴보았다. //상속과 포인터를 엮어서 한번 알아보자 Animal animal(\"My animal\"); Cat cat(\"my cat\"); Dog dog(\"my dog\"); animal.speak(); //??? cat.speak(); //Meow dog.speak(); //Woof //포인터 사용 Animal *ptr_animal1 = &amp;cat; Animal *ptr_animal2 = &amp;dog; ptr_animal1-&gt;speak(); //my cat - ??? ptr_animal2-&gt;speak(); //my dog - ??? //자식 클래스를 부모 클래스의 포인터로 캐스팅 하여 사용하게 되면 자기 자신이 부모 클래스인것으로 작동한다. //활용 가능 예시 Cat cats[] = {Cat(\"Cat1\"),Cat(\"Cat2\"), Cat(\"Cat3\"), Cat(\"Cat4\"), Cat(\"Cat5\")}; Dog dogs[] = {Dog(\"Dog1\"),Dog(\"Dog2\")}; for(int i = 0; i &lt; 5 ; ++i) cats[i].speak(); for(int i = 0; i &lt; 2 ; ++i) dogs[i].speak(); //이렇게 사용이 가능하지만, 상속받은 동물이 여러가지 인경우 for문을 여러개 만드는 불상사가 발생한다. //모두 Animal을 상속받는 객체 이므로 Animal을 활용하면 되지않을끼? Animal *my_animals[] = {&amp;cats[0],&amp;cats[1],&amp;cats[2],&amp;cats[3],&amp;cats[4], &amp;dogs[0],&amp;dogs[1]}; for (int i = 0; i &lt; 7; ++i) { my_animals[i] -&gt; speak(); } //virtual 키워드사용시 자식 클래스의 자신의 함수를 사용한다. //자식 클래스의 객체를 부모 클래스의 포인터에 넣어서 사용이 가능하다. //이것을 다형성이라고 한다. return 0;}가상 함수와 다형성// 가상 함수와 다형성// Virtual Functions, Polymorphism#include &lt;iostream&gt;using namespace std;class A{public: virtual void print() { cout &lt;&lt; \"A\" &lt;&lt; endl; }};class B : public A{public: void print() { cout &lt;&lt; \"B\" &lt;&lt; endl; }};class C : public B{public: void print() { cout &lt;&lt; \"C\" &lt;&lt; endl; }};class D : public C{public: void print() { cout &lt;&lt; \"D\" &lt;&lt; endl; }};int main() { //다형성을 구현할떄 상속과 virtual 키워드를 사용한다. //이번에는 virtual 용법, 가상 함수에 대해 알아보자 //현실적으로 상속의 깊이가 이렇게 깊지는 않다. A a;// a.print(); B b;// b.print(); C c;// c.print(); D d;// d.print(); //다형성 사용 //이번에는 참조사용, 이전에 포인터를 사용해 보았으니 참조도 사용해보자 A &amp;ref = b; ref.print(); //b를 넣엇지만, A로 작동한다. //virtual keyword 사용시 //B출력 //A의 함수가 virtual function이면서 B의 overrding된 함수가 존재 할때 자기 자신의 함수를 호출한다. A &amp;ref2 = c; ref2.print(); //C출력 //C는 B를 상속받앗는데 왜 C가 호출이되는가? //B는 가상함수가 아닌데 왜 C가출력이 되는가? B &amp;ref3 = c; ref3.print(); //A객체기 아닌 B의 객체로 c를 넣었을때도 C가 출력이 된다. //B는 가상 함수가 아닌데 왜 B가 아닌 C가 출력이 되는가? //이유 //가상 함수는 가장 상위클래스의 함수가 가상함수인경우 하위 클래스의 함수도 가상함수가 된다. //추가 내용 //오버로딩 할때 반환형이 다르면 컴파일 오류 발생 //오버로딩된 가상함수가 상위클래스의 함수와 구조가 다르다고 오류 발생 //virtual keyword는 호출할때 스택에 쌓이고 찾는게 아니라 //virtual table이라는 곳에 추가가 되면서 찾아쓰는 구조이다. //그러므로 느리다. //상속의 깊이가 깊고 가상함수가 구현이 되어있다면 속도가 현저히 느려진다. return 0;}override, final, 공변 반환값// override, final, 공변 반환값// Convariant#include &lt;iostream&gt;using namespace std;class A{public: void print(int x = 0) { cout &lt;&lt; \"A\" &lt;&lt; endl; } virtual A* getThis() { return this; }};class B : public A{public: void print(int x = 0) { cout &lt;&lt; \"B\" &lt;&lt; endl; } virtual B* getThis() { return this; }};class C : public B{public: void print(int x) { cout &lt;&lt; \"C\" &lt;&lt; endl; }};int main() { //이번에는 다형성을 사용할떄 유용한 override, final keyword에 대해 알아보자 //Convariant tpye도 알아보자 //앞에서본 예시와 다르게 함수에 파라미터가 추가가 되어있다. A a; B b; C c; A &amp;ref = b; ref.print(1); //파라미터가 다른경우 가상함수여도 부모의 클래스함수가 호출이 된다. //override keyword를 함수옆에 적어주면 B 호출 //override keyword //override를 사용하게 되면 함수 자체를 컴파일러에게 나 이 함수 상위클래스에있는 함수 overriding할꺼야 하고 박아버리는것이다. //그러면 컴파일러는 overriding function으로 인지를 하고 오류를 찾아준다. //상위 클래스 함수는 int인데 왜 넌 short야? 이거 고쳐 라고 알려준다. //B의 함수 파라미터를 int로 수정하면 오류가 사라지고 빌드 하면 B가 출력이 된다. //오버로딩할때는 override 키워드를 적어주는것이 좋다. 오류찾기도 쉬워지고 //final keyword //final keyword를 함수 이름 옆에 적어주면 하위 클래스에서 override를 못하게 막는 용법이다. //B에서 print() final인경우 C에서 print() 구현 불가 //A에서 print() final인경우 B,C 둘다 print() 구현 불가 //Convariant Return Type A &amp;ref2 = b; b.getThis() -&gt; print(); //B출력 //B의 getThis()실행 후 B 출력 ref2.getThis() -&gt; print(); //A출력 //B의 getThis()실행이 되지만 A 출력 //왜 A의 getThis()가 아니라 B의 getThis()가 호출이 될까? //ref2가 A이므로 B의 getthis()로 B의 포인터를 반환을 해주어도 내부적으로 A로 다시 바꾼후 호출하는 구조이다. cout &lt;&lt; typeid(b.getThis()).name() &lt;&lt; endl; //class B cout &lt;&lt; typeid(ref2.getThis()).name() &lt;&lt; endl; //class A return 0;}가상 소멸자// 가상 소멸자#include &lt;iostream&gt;using namespace std;class Base{public: virtual ~Base() { cout &lt;&lt; \"~Base()\" &lt;&lt; endl; }};class Derived : public Base{private: int *m_array;public: Derived(int length) { m_array = new int[length]; } ~Derived() { cout &lt;&lt; \"~Derived()\" &lt;&lt; endl; delete [] m_array; } };int main() { //이번에는 가상 소멸자에 대해 알아보자 //상속 구조에서 생성자는 자식클래스에서 자신의 생성자를 사용하지만 //소멸자는 가상 소멸자를사용하는것이좋다. // Derived derived(5); //자식 소멸자 호출후 부모 소멸자 호출 Derived *derived2 = new Derived(5); Base *base = derived2; delete base; //부모클래스는 자식클래스가 무엇으로부터 만들어졌는지 모르므로 //base포인터를 이용하여 제거를 시도를 한다. //~Base()만 실행이된다. //동물예시 //부모 클래스 - 동물 //자식 클래스 - 개, 고양이, 닭, 소 등등존재 //개 고양이 닭 소가 존재하는 Derived 객체를 Base 포인터에 넣어 다형성을 형성하였다고 하자. //그러면 동적할당을 제거할때 Derived에서 개, 고양이, 닭, 소 4개의 종류를 하나하나 지우는것보다 Base에서 한번에 지우는게 좋아보인다. //소멸자를 virtual로 만들면 //자식 소멸자 호출후, 부모 소멸자가 호출이 된다. return 0;}동적 바인딩과 정적 바인딩// 동적 바인딩과 정적 바인딩// binding#include &lt;iostream&gt;using namespace std;int add(int x, int y){ return x+y;}int substact(int x, int y){ return x-y;}int multiply(int x, int y){ return x*y;}int main() { //이번에는 동적 바인딩과 정적 바인딩에 대해 알아보자 //가상함수를 이용하는 다형성이 내부적으로 어떤식으로 실행이 되는지 이해하려면 동적 바인딩, 정적 바인딩의 차이를 이해하면된다. int x, y; cin &gt;&gt; x &gt;&gt; y; int op; cout &lt;&lt; \"0 : add, 1 : substact, 2: multiply\" &lt;&lt; endl; cin &gt;&gt; op; //static binding (early binding) int result; switch (op) { case 0: result = add(x, y); break; case 1: result = substact(x, y); break; case 2: result = multiply(x, y); break; } cout &lt;&lt; result &lt;&lt; endl; //변수명이나 함수명이 깔끔하게 빌드타임에 정의가 되어있는경우를 정적 바인딩이라고 한다. //Dynamic binding (late binding) int(*func_ptr)(int, int) = nullptr; //function pointer //함수에 대한 포인터 //컴파일 타임에 변수가 결정이 되어있지 않다. switch (op) { //op가 결정이 되고나서 func_ptr의 주소가 결정이 된다. case 0: func_ptr = add; break; case 1: func_ptr = substact; break; case 2: func_ptr = multiply; break; } cout &lt;&lt; func_ptr(x,y) &lt;&lt; endl; //func_ptr에 저장된 함수 주소가 할당이 된 함수를 실행 하는방법 - 간접적인 방법 //차이점 /* 속도 정적바인딩이 더빠르다. 변수가 다 정해져있으므로 빠르다. 동적 바인딩은 함수가 안정해져있고, 함수를 실행할때도 포인터의 주소를 거쳐서 함수를 호출하기 때문에 느리다. 속도는 느리지만, 동적 바인딩을 사용하면 프로그래밍이 유연해진다. 자유도가 높아진다. */ return 0;}가상 함수 테이블// 가상 함수 표// Virtual Tables#include &lt;iostream&gt;using namespace std;class Base{public: virtual void fun1() {}; void fun2() {};};class Derived : public Base{public: void fun1() {}; void fun3() {};};int main() { //이번에는 가상함수 표에 대해 알아보자 //이전에 다형성 사용시 가상함수는 느릴수도있는 이유가 스택에 쌓여서 진행하는것이 아니라, 가상함수표에 쌓이고 찾아오는 방식이라고 하였다. //가상함수가 선언이 되면 함수 포인터가 생성이되고 가상함수표를 만들고 동적 바인딩을 한다. //가상함수가 없으면 함수 포인터도 존재하지않고 정적 바인딩을 한다. /* Base - virtual fun1(), virtual fun2(), FunctionPointer *_vptr; Derived - virtual fun1(), FunctionPointer *_vptr; 부모 클래스의 경우 Base 객체를 만들고 fun1을 호출하게 되면 가상함수에 관한 포인터를 이용하여 가상함수 표를 찾는다. 여기서 가상함수표에는 fun1()과 같은 포인터와 func2()과 같은 포인터를 가지고있다. 가상함수표에서 fun1() 포인터를 찾고 그 포인터가 가르키고 있는 fun1()에 접근하여 fun1()을 실행한다. 자식 클래스의 경우 Derived 객체를 만들고 fun1을 호출하게 되면 가상함수에 관한 포인터를 이용하여 가상함수 표를 찾는다. 여기서 가상함수표에는 fun1()과 같은 포인터와 fun2()과 같은 포인터를 가지고있다. Derived에는 가상함수가 fun1()밖에 없는데 어떻게 fun2()도 가지고있냐? 부모쪽에서 fun2()가 가상함수이므로 만들어져 있던 것이다. 가상함수표에서 fun1() 포인터를 찾고 그 포인터가 가르키고 있는 fun1()에 접근하여 fun1()을 실행한다. 여기까지는 부모클래스가 자기자신의 객체를 만들어서 사용하는것과 같다. 하지만, 자식클래스에 없는 가상함수 fun2()를 호출하게 된다면 어떻게 될까?? 가상함수표에서 fun2() 포인터를 찾고 그 포인터가 가르키고 있는 부모 클래스에 존재하는fun2()에 접근하여 fun2()을 실행한다. 자식클래스로 만들어진객체를 부모클래스의 포인터,참조로 넣어도 가상함수 표는 유지가 되기 때문에 다형성으로 사용 가능한것이다. */ cout &lt;&lt; sizeof(Base) &lt;&lt; endl; cout &lt;&lt; sizeof(Derived) &lt;&lt; endl; //가상 함수가아닌경우 //1 //1 출력 //가상 함수가 아닌경우 최소한의데이터만 생성하므로 1이 발생 //가상 함수인경우 //8 //8 출력 //가상함수를 사용하면 함수포인터가 발생한다고 하였다. //그래서 포인터의 크기가 출력이 된것이다. return 0;}순수 가상 함수, 추상 기본 클래스, 인터페이스 클래스// 순수 가상함수, 추상기본클래스, 인터페이스클래스#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Animal{protected: string m_name; public: Animal(string name): m_name(name) {} string getName() {return m_name; } virtual void speak() const = 0; //Pure virtual function //바디가 없고 등호 = 0 으로 사용한다. //자식 클래스에서 이 함수를 반드시 구현해라 라는의미이다. };class Cat : public Animal{public: Cat(string name) : Animal(name) {} void speak() const { cout &lt;&lt; m_name &lt;&lt; \" Meow \" &lt;&lt; endl; }};class Dog : public Animal{public: Dog(string name) : Animal(name) {} void speak() const { cout &lt;&lt; m_name &lt;&lt; \" Woof \" &lt;&lt; endl; }};class Cow : public Animal{public: Cow(string name) : Animal(name) {} void speak() const { cout &lt;&lt; m_name &lt;&lt; \" Moooo \" &lt;&lt; endl; } };int main() { //이번에는 순수 가상 함수, 추상기본 클래스, 인터페이스 클래스에 대해알아보자. //지금까지는 다형성에서 가상함수를 구현할때 자식클래스에서 자신에게 적합한 함수를 오버라이딩하는 관점에 대해 배웠다. //이번에는 설계관점에서 기본클래스에서 자식 클래스에 제약을 만들고 강제하는 방법에대해 알아보자. /* 1.순수 가상 함수 Pure Virtual Function 바디가 존재하지 않음 자식 클래스에서 반드시 오버라이딩 필요 2.추상 클래스 Abstract Calss 순수가상 함수가 포함된 클래스이다. 3.인터페이스 클래스 Interface Class 순수 가상 함수로만 이루어진 클래스이다. */ //앞에선 Animal 예시를 가져와 고쳐보자 //Animal ani(\"Hi\"); //순수 가상함수가 존재하는 추상클래스는 인스턴스를 만들지 못한다. Cow cow(\"hello\"); //speak()가 구현이 안되어있어서 오류 발생 //speak()가 추상적이야~ 라고 오류를 뱉는다. cow.speak(); return 0;}인터페이스 클래스 예시// 순수 가상함수, 추상기본클래스, 인터페이스클래스#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//인터페이스 클래스 예시class IErrorLog{public: //순수 가상 함수 virtual bool reportError(const char * errorMessage) = 0; virtual ~IErrorLog() {}};class FileErrorLog : public IErrorLog{public: bool reportError(const char * errorMessage) override { cout &lt;&lt; \"Writing error to a file\" &lt;&lt; endl; return true; }};class ConsoleErrorLog : public IErrorLog{public: bool reportError(const char * errorMessage) override { cout &lt;&lt; \"Printing error to a console\" &lt;&lt; endl; return true; }};//인터페이스라고 부르는이유//외부에서 사용할때 기능을 예측하는 인터페이스 역할을 한다.//인터페이스 클래스의 자식들은 무조건 순수 가상함수를 구현을 해주어야한다.void doSomething(IErrorLog &amp; log){ log.reportError(\"RunTime error!\");}int main() { cow.speak(); FileErrorLog file_log; ConsoleErrorLog console_log; doSomething(file_log); doSomething(console_log); //파라미터가 IErrorLog이지만 FileErrorLog,ConsoleErrorLog 둘다 IErrorLog의 상속을 받는 관계이므로 사용이 가능하다. //재사용이 유용하다. return 0;}가상 기본 클래스와 다이아몬드 상속 문제// 가상 기본 클래스와 다이아몬드 상속 문제// virtual base class// the diamond problem#include &lt;iostream&gt;using namespace std;class PoweredDevice{public: int m_i; PoweredDevice(int power) { cout &lt;&lt; \"PoweredDevice: \" &lt;&lt; power &lt;&lt; endl; }};class Scanner :virtual public PoweredDevice{public: Scanner(int scanner, int power) : PoweredDevice(power) { cout &lt;&lt; \"Scanner: \" &lt;&lt; scanner &lt;&lt; '\\n'; }};class Printer : virtual public PoweredDevice{public: Printer(int printer, int power) : PoweredDevice(power) { cout &lt;&lt; \"Printer: \" &lt;&lt; printer &lt;&lt; '\\n'; }};class Copier : public Scanner, public Printer{public: Copier(int scanner, int printer, int power) : Scanner(scanner, power), Printer(printer, power), PoweredDevice(power) { }};int main() { //이번에는 가상 기본 클래스와 다이아몬드 상속문제에 대해 알아보자 //앞에서 다중상속 부분에서 상속을 할때 다이아몬드 구조로 만들면 위험해진다고 했엇다. //다이아몬드 문제를 해결하기 위해 가상 기본 클래스를 이용한다. Copier cop(1,2,3); cout &lt;&lt; &amp;cop.Scanner::PoweredDevice::m_i &lt;&lt; endl; cout &lt;&lt; &amp;cop.Printer::PoweredDevice::m_i &lt;&lt; endl; //주소가 같다 // 상속 받는 클래스에 vietual을 붙여주면 주소가 같아진다. return 0;}객체 잘림과 reference wrapper// 객체 잘림과 reference_wrapper// object slicing#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;functional&gt;using namespace std;class Base{public: int m_i = 0; virtual void print() { cout &lt;&lt; \"I'm Base\" &lt;&lt; endl; }};class Derived : public Base{public: int m_j = 1; virtual void print() override { cout &lt;&lt; \"I'm Derived\" &lt;&lt; endl; }};void doSomething(Base &amp; b){ b.print();}void doSomething2(Base b){ b.print();}int main() { //이번에는 상속관계에서 객체 잘림 현상에 대해 알아보자 //상속의 구조를 보았을때 부모보다 자식의 정보가 더 많이 가지고있다. //자식 클래스에는 일반화된 구조의 부모에서 추가적인 기능을 구현을 하기 때문에 추가적인 변수 함수들이 존재한다. //만약에 부모의 객체에 자식의 객체를 강제로 대입하게 되면 자식클래스보다 부모클래스의 정보가 적기 때문에 사라지게 된다. //이것을 객체 잘림이라고 한다. //객체 잘림을 방지하기 위한 방법이 reference_wrapper이다. Derived d; Base &amp;b = d; //부모 클래스에 자식객체를 대입하여 다형성 발생 b.print(); //Derived print; Base b2; b2 = d; //&amp;를 사용 안하게 되면 단순 복사 대입이므로 //b에는 d의 정보를 담을수가없다. //m_j가 추가된 정보를 가질수가없어서 사라지게 된다. // b2.m_j = 10; 사용불가 b2.print(); //Base 출력 //복사하는 과정에서 자식클래스의 정보를 가져오지못하여 오버로딩된 함수를 사용하지못하고 자기자신의 함수를 호출한다. doSomething(d); //파라미터가 참조 변수이므로 Derived 출력 doSomething2(d); //파라미터가 참조 변수가 아니므로 복사 대입이 발생하여 //마찬가지로 Base가 출력이 된다. //흔한 실수 예시 vector vector&lt;Base&gt; my_vec; my_vec.push_back(b); my_vec.push_back(d); for (auto &amp; ele : my_vec) { ele.print(); } //모든 객체가 Base출력 /* vector&lt;Base&amp;&gt; my_vec; my_vec.push_back(b); my_vec.push_back(d); for (auto &amp; ele : my_vec) { ele.print(); } vector에선 &amp;사용 불가 */ vector&lt;Base*&gt; my_vec2; my_vec2.push_back(&amp;b2); my_vec2.push_back(&amp;d); for (auto &amp; ele : my_vec2) { ele-&gt;print(); } //Base Derived 둘다 출력 성공 //참조를 사용하는 방법 //functional Library 사용 vector&lt;reference_wrapper&lt;Base&gt;&gt; my_vec3; //vector&lt;Base&amp;&gt; my_vec3 처럼 작동한다. my_vec3.push_back(b2); my_vec3.push_back(d); for (auto &amp; ele : my_vec3) { ele.get().print(); } return 0;}동적 형변환// 동적 형변환// Dynamic Casting#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Base{public: int m_i = 0; virtual void print() { cout &lt;&lt; \"I'm Base\" &lt;&lt; endl; }};class Derived1 : public Base{public: int m_j = 1024; virtual void print() override { cout &lt;&lt; \"I'm Derived\" &lt;&lt; endl; }};class Derived2 : public Base{public: string m_name = \"Dr. Two\"; virtual void print() override { cout &lt;&lt; \"I'm Derived\" &lt;&lt; endl; }};int main() { //이번에는 동적 형변환에 대해 알아보자 //다형성을 사용할때 종종 자식클래스의 포인터를 부모클래스의 포인터로 바꾸고 나중에 다시 자식클래스의 포인터로 바꿔야하는 경우가생긴다. //이때 사용하는것이 동적 형변환이다. Derived1 d1; Base *base = &amp;d1; //base에 d1의 주소를 넣어주었다. //base-&gt;m_j에 접근불가 //base를 다시 Derived1으로 형변환을 해야하는 경우가 발생한다면. 동적 형변환을 사용하면 된다 //동적 형변환은 이런식으로 구현한다. auto *base_to_d1 = dynamic_cast&lt;Derived1*&gt;(base); cout &lt;&lt; base_to_d1-&gt;m_j &lt;&lt; endl; //Derived1으로 형변환을 하여서 m_j에 접근이 가능하게 되었다. //동적형변환을 하는경우는 되도록 안하게 구현하는것이 좋다. //변수의 자료형이 왔다 갔다 하는것이 많아지면 코드도 복잡해지고 나중에 유지보수도 힘들어진다. auto *base_to_d2 = dynamic_cast&lt;Derived2*&gt;(base); //그냥 출력하게 되면 오류가 발생한다. //이유 //동적 형변환이 실패가 되면 nullptr을 반환한다. if(base_to_d2 != nullptr) cout &lt;&lt; base_to_d2-&gt;m_name &lt;&lt; endl; else cout &lt;&lt; \"Failed\" &lt;&lt; endl; //원인 //Dervied1의 주소를 가진 base가 Derived2로 형변환을 하게 되어 오류가 발생한것이다. //정적 형변환도 되긴하지만 오류를 발생하지않는다. auto *base_to_d3 = static_cast&lt;Derived1*&gt;(base); cout &lt;&lt; base_to_d3-&gt;m_j &lt;&lt; endl; auto *base_to_d4 = static_cast&lt;Derived2*&gt;(base); cout &lt;&lt; base_to_d4-&gt;m_name &lt;&lt; endl; return 0;}유도 클래스에서 출력 연산자 사용하기// 유도 클래스에서 출력 연산자 사용하기#include &lt;iostream&gt;using namespace std;class Base{public: Base() {} //멤버 함수가 아니므로 오버라이딩 불가 friend ostream&amp; operator &lt;&lt; (ostream&amp; out, const Base &amp;b) { //print()를 만들고 print에서 출력하도록 한다. return b.print(out); } virtual ostream&amp; print(ostream&amp; out) const { out &lt;&lt; \"Base\"; return out; } };class Derived : public Base{public: Derived() {} virtual ostream&amp; print(ostream&amp; out) const override { out &lt;&lt; \"Derived\"; return out; } };int main() { //다형성은 여러가지로 유용하지만 모든경우에 다형성을 사용할수없다. //대표적인 예시 - 출력 연산자 //출력 연산자는 오버라이딩이 불가능하다. //다형성으로 출력 연산자를 사용하는 방법 Base b; cout &lt;&lt; b &lt;&lt; '\\n'; Derived d; cout &lt;&lt; d &lt;&lt; '\\n'; Base &amp;bref = d; cout &lt;&lt; bref &lt;&lt; '\\n'; //자식 클래스의 print()를 이용하여 마치 &lt;&lt; operator가 오버라이딩 된것처럼 작동한다. return 0;}" }, { "title": "[C++] Chapter.11 상속", "url": "/posts/Cpp-Ch11/", "categories": "Language, C++", "tags": "c++", "date": "2022-09-24 22:20:19 +0900", "snippet": "상속의 기본(1)// 상속의 기본 1// Inheritance#include &lt;iostream&gt;using namespace std;class Mother{private: int m_i; public: Mother(const int &amp; i_in) : m_i(i_in) { cout &lt;&lt; \"Mother constructor\" &lt;&lt; endl; } void setValue(const int&amp; i_in) { m_i = i_in; } int getValue() { return m_i; }};//객체지향의 상속//부모의 사망으로 인한 상속 개념이 아니다.//Mother를 상속 받는 Child class//상속은 이렇게 받는다.class Child : public Mother //상속 : public말고 private도 가능하다.{private: double m_d; public: //생성자 Child(const int &amp; i_in, const double &amp; d_in) // : m_i(i_in), m_d(d_in) 초기화가 안됨 Public이여도 안된다. //생성자가 존재하는 이유 메모리가 할당될때 초기화를 해줘라지, 메모리가 할당된후 값을 복사해줘가아니다. //m_i가 초기화 안되는이유 - Child를 생성할때 m_i의 메모리가 존재 하지않기 때문에 //왜 메모리가없는가? 상속 관계일때 생성자의 생성순서를 알아야하는데 다음에 배우도록하자. : Mother(i_in) , m_d(d_in) { //초기화 리스트를 안사용하고 직접 접근한다.// Mother::setValue(i_in);// m_d = d_in; } //Child를 만드려는 이유를 생각을 해보자 //왜 Child가 필요한가? //Mother에서 구현해도 되는데 Child class를 왜 만들었지? //기능을 분담을 하려고 //상속은 왜 받앗는가? //Mother의 m_i를 사용하기 위해 //애초에 Child는 m_d 멤버 변수와, Mother의 m_i를 같이 이용하기 위해 만든 class이므로 //생성자에서 Motehr의 m_i와 자신의 멤버변수인 m_d를 같이 만든다. //Mother에 같은 이름으로 구현이 되어있는 함수 //과연 누구의 것을 실행할까? //자기 클래스에 잇는것을 우선으로 실행한다.. void setValue(const double &amp; d_in) { m_d = d_in; } double getValue() { return m_d; } void setValue(const int &amp; i_in, const double &amp; d_in) { //Mother에 있는 m_i에 i_in을 넣어줄것이다. //m_i = i_in; //public변수의 경우 접근이 가능하다. //private는 자식에게 접근을 허용되지 않는다. //protect 키워드를 사용한다. //private상태이면서 자식에게는 허용하는 접근제어자이다. //private인 상태에서 사용하는 방법 - 부모의 함수를 실행하여 m_i에 값을 넣는다. Mother::setValue(i_in); m_d = d_in; }};class Daughter : public Mother{ };class Son : public Mother{ };//여러 클래스에서 상속을 받을 수 있다.//상속받은 클래스 - Derived class//상속한 클래스 - general class//클래스안에 같은 기능이 있는경우(일반화 해야하는 경우) 상속 클래스를 만든다.int main() { //객체 지향에서 가장 중요한 상속에 대해 알아보자 //상속 //is-a relationship Mother mother(1024);// mother.setValue(1024); cout &lt;&lt; mother.getValue() &lt;&lt; endl; Child child(1022, 128);// child.setValue(128); cout &lt;&lt; child.getValue() &lt;&lt; endl; //Child는 empty class 이지만 Mother와 같이 실행이 잘 된다. //Child는 Mother에 있는 것들을 기본적으로는 모두 사용 가능하다. (동기) //캡슐화를 통하여 사용하지 못하게할 수 있다. cout &lt;&lt; child.Mother::getValue() &lt;&lt; endl; //1022 출력 //Child에서 생성자를 만들고 정상작동 하였으나, Mother에도 생성자를 만드니 오류가 발생한다. //Child에서 생성이 될때 내부적으로 Mother의 생성자도 생성한다. //그래서 오류가 발생한 것이다. //Mother에 기본생성자를 만드는 방법 //Child가 Mother에 넣으면서 생성자를 호출 하는 방법 //: Mother(i_in) , m_d(d_in) 붙여주기 //이번에는 상속에 대해 간단하게만 알아보았다. //어떤 오류가 발생하는지, 어떻게 상속을 구현하는지만 정리해두자 //다음에 상속2에서 더 자세한 설명을 한다. return 0;}상속의 기본(2)main.cpp// 상속의 기본(2)// Inheritance//#include &lt;iostream&gt; //Student 안에 Person안에 이미 라이브러리를 받아와서 삭제가능#include \"Student.hpp\"#include \"Teacher.hpp\"using namespace std;int main() { //이번에는 좀더 구체적인 사례를 보고 상속을 더 깊게 알아보자 //중복 되는 부분은 코드를 한곳에 몰아놓고 재사용하여 작업량을 줄이는것이 중요하다. //학생도 이름이 존재하고, 교사도 이름이 존재한다. //이름이 중복으로 존재한다. //일반화를 하면 //학생과 교사는 사람이다. //앞에서 말한 상속 is-a 관계가 여기서 나온다. //Student is Person //Teacher is Person //일반화 - 공통적인 부분을 묶는것 //Person 헤더를 만들어 학생과 교사의 공통부분을 묶어준다. //Studnet, Teacher의 생성자에서 m_name에서 오류가 발생한다. //의미 //m_name은 Person안에 있는 멤버변수 이므로 m_name의 관리 책임은 person에 있다. //생성자 호출순서로 인해 Student가 생성이 될때 m_name 메모리가 아직 할당이 되어있지 않아 Person을 호출하여 간접적으로 초기화 하는방향으로 진행 해야한다. //Person에서 m_name을 초기화 해주어야한다. //Studnet, Teacher안에 iostream, string 라이브러리가 존재하므로 main에서 include없이 사용가능하다 Student std(\"Jack Jack\"); std.setName(\"Jack Jack2\"); Teacher teacher(\"Dr. H\"); teacher.setName(\"Dr. K\"); cout &lt;&lt; std.getName() &lt;&lt; endl; cout &lt;&lt; teacher.getName() &lt;&lt; endl; //상속을 받으면 멤버 함수가 아닌데 멤버함수처럼 사용이 가능하다. cout &lt;&lt; std &lt;&lt; endl; cout &lt;&lt; teacher &lt;&lt; endl; std.doNothing(); teacher.doNothing(); //상속을 사용 하지않았다면 각각의 클래스에 doNothing함수를 구현을 했어야한다. std.study(); teacher.teach(); //study와 teach는 각 클래스의 고유 멤버 함수이다. //서로 사용 불가능하다. Person ps; ps.setName(\"Test\"); cout &lt;&lt; ps.getName() &lt;&lt; endl; // ps.study();// ps.teach(); //자식 클래스에 구현 되어있는것은 부모 클래스에선 사용 불가능하다. return 0;}Student.hpp/* 학생 정보 헤더파일 */#pragma once//#include &lt;string&gt;//#include &lt;iostream&gt;#include \"Person.hpp\"class Student : public Person{private: //std::string m_name; //학생 이름 //Person에 있는 내용이므로 삭제한다. int m_intel; //학생 학습 능력치 public: Student(const std::string &amp; name_in = \"No Name\", const int &amp; intel_in = 0) //: m_name(name_in), m_intel(intel_in) : Person(name_in), m_intel(intel_in) {} //Name은 Person에 있는 변수를 사용하는것이므로 함수를 옮긴것이다. //Intel은 Student의 고유 멤버 변수이다. //중복이 되지않은 기능이므로 Person에 옮길수없다. void setIntel(const int &amp; intel_in) { m_intel = intel_in; } int getIntel() { return m_intel; } void study() { std::cout &lt;&lt; getName() &lt;&lt; \" is studing\" &lt;&lt; std::endl; } friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; out, const Student &amp; student) { //const 함수가 아니라 오류 발생 //Person의 함수에서 const 함수로 수정하면 오류가 사라진다. //일반화의 장점 한곳에서 수정을 하였는데 Student, Teacher의 같은 오류가 같이 사라졌다. out &lt;&lt; student.getName() &lt;&lt; \", \" &lt;&lt; student.m_intel; return out; } };Teacher.hpp/* 교사 정보 헤더파일 */#pragma once//#include &lt;string&gt; Person에서 이미 받아온 라이브러리 이므로 삭제해도 된다. 뭐 그냥 냅둬도 되는데 깔끔하게 보이기 위해 지우는 습관을 들여놓자#include \"Person.hpp\"class Teacher : public Person{private: //std::string m_name; //교사 이름 //Person에 있는 내용이므로 삭제한다. public: Teacher(const std::string &amp; name_in = \"No Name\")// : m_name(name_in) : Person(name_in) {// this-&gt;getName();// this-&gt;setName(\"TR\"); //getName, setName 정상적으로 작동한다. } void teach() { std::cout &lt;&lt; getName() &lt;&lt; \" is teaching\" &lt;&lt; std::endl; } friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; out, const Teacher &amp; teacher) {// out &lt;&lt; teacher.m_name; out &lt;&lt; teacher.getName(); return out; } };Person.hpp#pragma once#include &lt;string&gt;#include &lt;iostream&gt;class Person{private: std::string m_name; //public으로 안하는 이유 - 상속받는 곳에서 모두 사용하게 되면 어디서 뭐가 언제 바뀌었는지 확인이 불가능한 경우가 발생한다. // public: //defalut 생성자가 없어서 오류 발생 //default 생성자 생성 or 생성자에 기본값 넣어주기// Person()// : m_name(\"No Name\")// {} //default 값 설정 Person(const std::string &amp; name_in = \"No Name\") : m_name(name_in) {} //Studnet와 Teacher의 공통 함수인 getName, setName을 가져와서 자식 클래스에서 부모의 m_name을 건드리던것을 아예 없애 버렸다. //부모에서만 m_name을 건드리게끔 수정을 하였다. void setName(const std::string &amp; name_in) { m_name = name_in; } std::string getName() const { return m_name; } void doNothing() const { std::cout &lt;&lt; m_name &lt;&lt; \" is doing nothing\" &lt;&lt; std::endl; } };유도된 클래스들의 생성 순서// 유도된 클래스들의 생성 순서#include &lt;iostream&gt;using namespace std;//class Mother//{//private:// int m_i;////public:// double m_d;//// Mother() : m_i(1)// {// cout &lt;&lt; \"Mother construction\" &lt;&lt; endl;// }//};////////Child는 Mother로부터 유도가 되었다. 고 말할수있다.//class Child : public Mother//{//public:// double m_dc;//// Child() : m_dc(1.0) // : m_d(1024) 생성자 초기화는 안되었던거 앞에서 확인을 하였다 .// {// cout &lt;&lt; \"Child construction\" &lt;&lt; endl;//// //public인 경우 접근이 아주 쉽다.//// this-&gt;m_d = 10.0;//// //상속을 받은 멤버 변수를 명확하게 보여주기 위해 작성가능//// Mother::m_d = 1024.0;// }////////};class A{public: A() { cout &lt;&lt; \"A Constructor\" &lt;&lt; endl; }};class B : public A{public: B() { cout &lt;&lt; \"B Constructor\" &lt;&lt; endl; }};class C : public B{public: C() { cout &lt;&lt; \"C Constructor\" &lt;&lt; endl; }};int main() { //상속의 문법을 확인을 해보았으니, 생성이 어떤식으로 일어나는지 알아보자 //생성자 초기화는 안되었던거 앞에서 확인을 하였다. 왜 안되는지 한번 알아보자 // // Child c1; //부모 생성자 생성후 자식 생성자 생성 //디버깅로 확인을해보면 Child 생성자부분으로 이동후, 생성자는 생성하지 않고 Mother생성자로 이동을 한다. //Child에서 Mother의 생성자를 호출하지 않아도 Mother의 default 생성자를 호출하는것이다. //내부적으로 자식 클래스에서 부모클래스의 생성자를 호출한다. //순서 //부모의 클래스 초기화 후, 자기자신(자식) 클래스를 초기화를 한다. //자식 생성자에서 부모클래스의 멤버변수의 초기화를 진행하지 못하는이유 //자식클래스에서는 부모클래스 메모리가 할당이 안되어있기 때문에 초기화를 못하는것이다. //그래서 앞에서 부모의 생성자를 이용하여 초기화를 했던것이다. //부모의 생성자를 자식 클래스에서 호출이 가능한가? //m_i를 그러면 하드코딩 방식으로만 해야하는가? , 값을 받아와서 초기화하는것은 불가능한것인가? //아니다 앞에서 이미 사용을해보았지만, 부모의 생성자를 이용하여 초기화 값을 원하는대로 조정이 가능하다. //사실은 자식 생성자의 initializer list에서는 Mother()가 숨어져있는것이다. /* Child() : Mother(), m_dc(10) 처럼 말이다. */ //상속의 깊이가 존재하는경우 ABC 다단구조의 경우 생성자 생성 방식 살펴보기 C c; //생성자 생성 순서 //1. A의 생성자 생성 //2. B의 생성자 생성 //3. C의 생성자 생성 B b; //생성자 생성 순서 //1. A의 생성자 생성 //2. B의 생성자 생성 //소멸자는 생성자 생성순서와 반대로 진행이 된다. return 0;}유도된 클래스들의 생성과 초기화// 유도된 클래스들의 생성과 초기화#include &lt;iostream&gt;using namespace std;class Mother{private: int m_i;public: Mother(const int &amp; i_in = 0) : m_i(i_in) { cout &lt;&lt; \"Mother construction\" &lt;&lt; endl; }};class Child : public Mother{public: float m_d; Child() : m_d(1.0f), Mother(1024) { cout &lt;&lt; \"Child construction\" &lt;&lt; endl; }};class A{public: A(int a) { cout &lt;&lt; \"A : \" &lt;&lt; a &lt;&lt; endl; } ~A() { cout &lt;&lt; \"Destructor A\" &lt;&lt; endl; }};class B : public A{public: B(int a, double b) : A(a) { cout &lt;&lt; \"B : \" &lt;&lt; b &lt;&lt; endl; } ~B() { cout &lt;&lt; \"Destructor B\" &lt;&lt; endl; }};class C : public B{public: C(int a, double b, char c) : B(a, b) { cout &lt;&lt; \"C : \" &lt;&lt; c &lt;&lt; endl; } ~C() { cout &lt;&lt; \"Destructor C\" &lt;&lt; endl; }};int main() { //이전에 생성자의 생성자 호출 순서를 알아보았고, 이번에는 생성과 초기화를 알아보자 cout &lt;&lt; sizeof(Mother) &lt;&lt; endl; //크기 4 //멤버변수 int크기 cout &lt;&lt; sizeof(Child) &lt;&lt; endl; //크기 8 //자기 자신의 크기 float 4 + 부모의 크기 4로 인해 8의 크기가 된다. //Child에서 메모리 할당 될때 Mother도 모두 받을수있는 메모리를 할당 받는다. C c(1024, 3.14, 'a'); //생성자 생성 순서 //A -&gt; B -&gt; C //소멸자 생성 순서 //C -&gt; B -&gt; A return 0;}상속돠 접근 지정자//상속과 접근 지정자#include &lt;iostream&gt;using namespace std;class Base{public: int m_public;protected: int m_protected;private: int m_private;};class Derived : protected Base{public: Derived() { //public, protected,private 모두 사용가능 m_public = 123; m_protected = 123;// m_private = 123; 불가능 }};class GrandChild : public Derived{public: GrandChild() { //Derived : private Base인 경우 접근 불가 Derived::m_public = 123;// Derived::m_protected; }};int main() { //상속을 사용할때 public을 왜써야하는지 의문을 가졋을것이다. //이번에는 상속에 관한 접근지정자에 대해 알아보자 Base base; base.m_public = 123;// base.m_protected = 123; 불가능 //상속된곳에서는 사용가능 // base.m_private = 123; 불가능 Derived derived; //상속 접근제어자가 protected인 경우 public인 멤버변수에도 접근이 불가능하다.// derived.m_public = 123;// derived.m_protected = 123; 불가능// derived.m_private = 123; 불가능 return 0;}유도된 클래스에 새로운 기능 추가하기//유도된 클래스에 새로운 기능 추가하기#include &lt;iostream&gt;using namespace std;class Base{private: int m_value; public: Base(int value) : m_value(value) { }};class Derived : public Base{public: Derived(int valus) : Base(value) { //Base의 값을 변경을 하고자한다. } //Base의 값을 변경을 하고자한다. void setValue(int value) {// Base::m_value = value; //private라서 오류가 발생한다. //protected로 변경하면 정상작동 //private로 된 상태에서 접근을 할수있다. //public get,set함수를 만들어서 접근을 하게 만들순있지만 //이렇게하면 상위 함수를 거치기 때문에 퍼포먼스가 떨어지는 경우가 발생한다. }};int main() { //이번에는 유도된 클래스(자식클래스)에 새로운 기능을 추가할때 생각해야하는것이 무엇이 있는지 알아보자 return 0;}상속받은 함수를 오버라이딩 하기// 상속받은 함수를 오버라리딩 하기#include &lt;iostream&gt;using namespace std;class Base{protected: int m_value; public: Base(int value) : m_value(value) {} void print() { cout &lt;&lt; \"I'm Base\" &lt;&lt; endl; } friend std::ostream &amp; operator &lt;&lt; (std:: ostream &amp; out, const Base &amp;b) { cout &lt;&lt; \"This is base output\" &lt;&lt; endl; return out; }};class Derived : public Base{private: double m_d;public: Derived(int value) : Base(value) {} void print() { Base::print(); //부모 함수 호출 cout &lt;&lt; \"I'm Derived\" &lt;&lt; endl; } friend std::ostream &amp; operator &lt;&lt; (std:: ostream &amp; out, const Derived &amp;d) { cout &lt;&lt; static_cast&lt;Base&gt;(d); //operator 오버로딩사용하는방법 //캐스팅이 되는이유 - 자식 클래스메모리를 할당받을때 부모의 내용에 대한 메모리를 가지고있기때문에 캐스팅이 가능하다. cout &lt;&lt; \"This is derived output\" &lt;&lt; endl; return out; }};int main() { //이번에는 상속관계에서의 오버라이딩을 알아보자 Base base(5); base.print(); cout &lt;&lt; base; Derived derived(7); derived.print(); cout &lt;&lt; derived; //자식클래스에는 print함수가 없으므로 Base의 print()를 호출함 //자식클래스에 print()가 있는경우 Derived의 print()를 호출함 //특수한 경우 자식 클래스에서 기능 수행을 하는데 부모 클래스의 기능을 수행을하고 추가적으로 자기자신의 기능을 수행하게 하고싶은 경우가 발생한다. //기능은 비슷하므로 함수 이름을 같게 만드려고 한다. //이때 함수안에 부모 함수 호출을 하게 만들면 된다. // return 0;}상속 받은 함수를 감추기//상속받은 함수를 감추기#include &lt;iostream&gt;using namespace std;class Base{protected: int m_i; public: Base(int value) : m_i(value) {} void print() { cout &lt;&lt; \"I'm Base\" &lt;&lt; endl; }};class Derived : public Base{private: double m_d;public: Derived(int value) : Base(value) {} //이걸 사용하면 Derived안에서 Base의 m_i 멤버변수는 public으로 작동한다. using Base::m_i; private: //이걸 사용하면 Derived에서 print함수 사용 불가능하다. using Base::print; //괄호 필요없음 함수 이름만 적으면 된다. //정리할때 using 붙는것들을 앞에 모두 구현하고 정리를 하는것이 좋다. //부모에서는 접근되지만 자식에서만 접근 불가능하게 하는방법 2 private: //아예 지우는것도 자식 클래스에서 접근 불가능하게 만들 수 있다. void print() = delete;};int main() { //이번에는 상속된 기능을 막는방법에 대해 알아보자 //앞에선 상속을 하는 이유는 부무클래스의 기능을 사용하기 위해 상속을이용하엿따. Derived derived(7); derived.m_i = 123; //변경 불가 왜냐? protected로 되어있으므로 안된다. // derived.print(); //부모에게 받은 public함수 이므로 사용이 가능하다 return 0;}다중 상속// 다중 상속// Multiple Inheritance#include &lt;iostream&gt;using namespace std;class USBDevice{private: long m_id; public: USBDevice(long id) : m_id(id) {} long getID() { return m_id; } void plugAndPlay() {}};class NetworkDevice{private: long m_id; public: NetworkDevice(long id) : m_id(id) {} long getID() { return m_id; } void networking() {}};class USBNetworkDevice : public USBDevice, public NetworkDevice{public: //id가 다른경우 USBNetworkDevice(long usb_id, long net_id) : USBDevice(usb_id), NetworkDevice(net_id) {} //id가 같은경우 사용 가능 USBNetworkDevice(long id) : USBDevice(id), NetworkDevice(id) {}};int main() { //이번에는 다중상속에 대해 알아보자 USBNetworkDevice my_device(3.14, 6.022); //각각의 부모클래스의 기능이 사용가능하다. my_device.networking(); my_device.plugAndPlay(); //문제 발생 //중복되는 함수를 사용할때 오류가 발생한다. // my_device.getID(); //어디서온 함수를 사용할것인가?를 모르기 때문에 오류가 발생한다. my_device.USBDevice::getID(); my_device.NetworkDevice::getID(); //이렇게 범위 결정 연산자를 사용하여 명확하게 구분을지어주면 해결이 된다. //다중상속을 다이아몬드 구조로 짜게 되면 위험할수도 있다. return 0;}" }, { "title": "[C++] Chapter.10 객체들 사이의 관계에 대해", "url": "/posts/Cpp-Ch10/", "categories": "Language, C++", "tags": "c++", "date": "2022-09-24 22:20:19 +0900", "snippet": "객체들의 관계// 객체들의 관계// Object Relationship#include &lt;iostream&gt;using namespace std;int main() { //객체지향 프로그래밍을 할때 기능들을 정의를한다. //기능들이 수행할떄 어떤 객체가 어떤 영향을 주는지, 무슨 일을 하는지 설계를 해야한다. //여러 클래스를 구현함으로써 프로그래밍 언어로서 객체들을 만든다. //클래스들 간의 관계가 많은 프로그램에 같은 패턴을 보여주는데 패턴에 대해 알아보자 //관계 종류 /*구성 Composition Part-of 두뇌는 육체의 일부이다. 두뇌는 육체없이 존재 불가 두뇌는 육체의 전체를 알지 못한다. 관계의 형태 - 전체/부품 관계 전체(육체) / 부품(두뇌) 다른클래스에 속하는가? - No 두뇌는 다른 육체에 속할 수 없다. 멤버의 존재를 클래스가 관리 하는가? - Yes 육체 클래스가 두뇌를 관리를 한다. 방향성 - 단방향 육체는 두뇌를 알고 있지만, 두뇌는 육체를 다알지는 못한다. */ /*집합 Aggregation Has-a 어떤 사람이 자동차를 가지고 있다. 사람이 자동차의 소유원이 사라져도 자동차는 존재한다. 관계의 형태 - 전체/부품 관계 전체(사람) / 부품(자동차) 다른클래스에 속하는가? - Yes 자동차를 다른사람에게 파는것, 가족과 공유하는것 가능 멤버의 존재를 클래스가 관리 하는가? - No 사람이 자동차를 팔아도 자동차는 존재한다. 방향성 - 단방향 */ /*연계 Association Uses-a 환자는 의사의 치료를 받는다. 의사는 환자로부터 치료비를 받는다. 서로 사용하는 관계 / 도움을 주는관계 하나의 환자를 하나의 의사만 보는것이아니라 여러 환자들이 여러 의사를 만날수있다. 반대로 여러 의사들이 여러 환자들을 치료할 수 있다. 관계의 형태 - 용도 외엔 무관 의사와 환자 관계는 치료 용도 외엔 마주할일이 없다. 다른클래스에 속하는가? - Yes 한명의 의사에 여러 환자 존재 가능 한명의 환자에 여러 의사 존재 가능 멤버의 존재를 클래스가 관리 하는가? - No 방향성 - 단방향 / 양방향 서로 영향을 줄수있디. */ /*의존 Dependency Depends-on 나는 다리가 부러져 목발을 짚었다. 치료가 완료 된후에 목발이 사라지는것이 아니다. 관계의 형태 - 용도 외엔 무관 치료가 완료되면 목발 사용 필요 없음 일시적으로 사용용도 다른클래스에 속하는가? - Yes 치료가 끝난후 다른 환자에게 목발 주는것 가능 멤버의 존재를 클래스가 관리 하는가? - Yes 코드에서 확인 멤버에서 필요할때 사용하고 필요없을때 제거한다. 방향성 - 단방향 */ //상속 //상속 부분에서 다룰예정 //검은색 클래스 //파란색 멤버 클래스 //아래로 내려갈수록 관계가 느슨해진다. //관계는 예시로만 보지말자 //해당 관계에 대한 예시를 다른 관계로 프로그래밍이 가능하므로 /* 구성 - 장기를 이식하는경우 구성관계에서 집합관계가 된다 집합 - 게임에서 교환불가 아이템을 만들면 아이템에 대한 관계가 집합관계에서 구성관계가 된다. 연계 - 학원선생님 - 연계 / 과외선생님 - 집합 의존 - ? 예시가 생각이 안난다. */ //예시는 관계가 이런식이구나 라고 알아두기만하자 return 0;}구성 관계#pragma once#include &lt;string&gt;//#include &lt;iostream&gt;//Position2D에서 가져올것이므로 삭제 가능#include \"Position2D.h\"class Monster{private: std::string m_name; //몬스터 이름 // int m_x; //몬스터 x좌표// int m_y; //몬스터 y좌표 //몬스터의 좌표는 많은기능을 포함가능하다. //좌표만 다른클래스로 만들면 좋지않을까? ㅖ public: Monster(const std::string name_in, const int&amp; x_in, const int&amp; y_in) : m_name(name_in), m_x(x_in), m_y(y_in) { } void moveTo(const int&amp; x_target, const int&amp; y_target) { m_x = x_target; m_y = y_target; } friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; out, const Monster &amp; monster) { out &lt;&lt; monster.m_name &lt;&lt; \", \" &lt;&lt; monster.m_x &lt;&lt; \", \" &lt;&lt; monster.m_y &lt;&lt; std::endl; return out; } };main.cpp// 구성관계// Composition#include &lt;iostream&gt;#include \"Monster.h\"using namespace std;int main() { //이번에는 앞에서 본 여러 관계중 구성 관계에 해대 알아보자 //게임 예시로 몬스터 클래스로 설명한다. Monster mon1(\"Salson\", Position2D(0, 0)); // while(1) //game loop Monster mon2(\"Parsival\", Position2D(0, 0)); cout &lt;&lt; mon1 &lt;&lt; endl; //event mon1.moveTo(Position2D(1,1)); cout &lt;&lt; mon1 &lt;&lt; endl; //Position2D에 대한 클래스가 몬스터 클래스 말고 유저 클래스에서도 사용가능하다. //몬스터 클래스가 Position2D를 사용하는 관계를 구성관계라고 한다. //location이 몬스터의 일부이다. //몬스터와 좌표의 관계 //전체(몬스터) / 부품(좌표) //Position2D자체는 다른 클래스에 속할수잇지만 //몬스터의 Position2D - m_location은 다른 클래스에 속하지 못한다. //멤버의 존재 관리 - 몬스터 소멸시 좌표도 같이 소멸해야한다. //단방향 - //몬스터 클래스가 작업할때 Position2D안에 set함수가 있다는것을 알지만 //Position2D가 작업할때 몬스터에 대한 정보는 모르고 몬스터가 set함수 사용했네? set함수 호출해야지 한다. //쉽게 설명하자면 코드로 다시 넘어가서 //몬스터 클래스에서는 Position2D에 대한 멤버 함수를 사용한다 - moveTo/m_location.set(pos_target); //Position2D 클래스에서는 몬스터에 대한 멤버 변수를 사용하지 않는다. - 왜냐? 몬스터에 대한 정보를 모르니까 return 0;}Monster.h#pragma once#include &lt;string&gt;//#include &lt;iostream&gt;//Position2D에서 가져올것이므로 삭제 가능#include \"Position2D.h\"class Monster{private: std::string m_name; //몬스터 이름 // int m_x; //몬스터 x좌표// int m_y; //몬스터 y좌표 //몬스터의 좌표는 많은기능을 포함가능하다. //좌표만 다른클래스로 만들면 좋지않을까? Position2D m_location; //몬스터 클래스가 Position2D를 사용하는 관계를 구성관계라고 한다. //location이 몬스터의 일부이다. //Position2D를 서브클래스라고 한다. //m_x, m_y에 대한 서브클래스 - Position2D //중요한점 몬스터 클래스에서는 moveTo()에서 Position2D.set()을 이용하여 움직인다를 알고있지만 //몬스터 클래스 입장에서는 set()함수를 호출만 할뿐이지 내부적으로 set()이 어떤식으로 작동을 하는지 알 필요는없다. //기능을 분리시키고 상위 클래스는 작동이 된다 안된다만 알면되고 어떻게 작동이 되는지는 몰라도 된다. //오히려 모를수록 좋다. 여러곳에서 기능에 신경을 쓰게 되면 복잡해진다. public: Monster(const std::string name_in, const Position2D&amp; pos_in) : m_name(name_in), m_location(pos_in) {} void moveTo(const Position2D&amp; pos_target) { m_location.set(pos_target); } friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; out, const Monster &amp; monster) { out &lt;&lt; monster.m_name &lt;&lt; \", \" &lt;&lt; monster.m_location &lt;&lt; std::endl; return out; } };Position2D#pragma once#include &lt;string&gt;//#include &lt;iostream&gt;//Position2D에서 가져올것이므로 삭제 가능#include \"Position2D.h\"class Monster{private: std::string m_name; //몬스터 이름 // int m_x; //몬스터 x좌표// int m_y; //몬스터 y좌표 //몬스터의 좌표는 많은기능을 포함가능하다. //좌표만 다른클래스로 만들면 좋지않을까? Position2D m_location; //몬스터 클래스가 Position2D를 사용하는 관계를 구성관계라고 한다. //location이 몬스터의 일부이다. //Position2D를 서브클래스라고 한다. //m_x, m_y에 대한 서브클래스 - Position2D //중요한점 몬스터 클래스에서는 moveTo()에서 Position2D.set()을 이용하여 움직인다를 알고있지만 //몬스터 클래스 입장에서는 set()함수를 호출만 할뿐이지 내부적으로 set()이 어떤식으로 작동을 하는지 알 필요는없다. //기능을 분리시키고 상위 클래스는 작동이 된다 안된다만 알면되고 어떻게 작동이 되는지는 몰라도 된다. //오히려 모를수록 좋다. 여러곳에서 기능에 신경을 쓰게 되면 복잡해진다. public: Monster(const std::string name_in, const Position2D&amp; pos_in) : m_name(name_in), m_location(pos_in) {} void moveTo(const Position2D&amp; pos_target) { m_location.set(pos_target); } friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; out, const Monster &amp; monster) { out &lt;&lt; monster.m_name &lt;&lt; \", \" &lt;&lt; monster.m_location &lt;&lt; std::endl; return out; } };집합 관계main.cpp// 집합 관계// Aggregation#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include \"Lecture.hpp\"using namespace std;int main() { //구성 관계에서는 클래스가 멤버변수의 모든것을 꽉 쥐고 있는 관계라면 그것보다 느슨한 집합관계를 보면서 비교를 해보자 //예시 학교구조 //선생, 학생, 수업 //Teacher이나 Student에서 비슷한 기능이 많다. 중복된 기능이 많은데 //상속, 템플릿을 배우고 나면 중복되는 부분을 제거할 수 있다. //Composition Relationship //test {// Lecture lec1(\"Introduction to Computer Programming\");// lec1.assignTeacher(Teacher(\"Prof. Hong\"));// lec1.registerTeacher(Student(\"Jack Jack\", 0));// lec1.registerTeacher(Student(\"Dash\", 1));// lec1.registerTeacher(Student(\"Violet\", 2));////// Lecture lec2(\"Computational Thinking\");// lec2.assignTeacher(Teacher(\"Prof. Good\"));// lec2.registerTeacher(Student(\"Jack Jack\", 0)); // cout &lt;&lt; lec1 &lt;&lt; endl;// cout &lt;&lt; lec2 &lt;&lt; endl;//// lec2.study();//// cout &lt;&lt; lec1 &lt;&lt; endl;// cout &lt;&lt; lec2 &lt;&lt; endl; //구성관계에선 lec1의 Jack Jack과 lec2의 Jack Jack 학습능력이 달라진다. //같은학생이지만 값이 달라지는 현상 발생 } //같은학생이 존재하지만 과목에따라 학생의 주소가 달라지는 문제가 발생한다. 같은 데이터가 아니다. { //학생 객체를 따로 생성 Student *std1 = new Student(\"Jack Jack\", 0); Student *std2 = new Student(\"Dash\", 1); Student *std3 = new Student(\"Violet\", 2); //교사 객체 따로 생성 Teacher *teacher1 = new Teacher(\"Prof. Hong\"); Teacher *teacher2 = new Teacher(\"Prof. Good\"); //main의 로컬 변수이므로 main이 종료가 되면 소멸이 된다. //main이 아닌 다른 파일에서도 사용을 해야한다면 동적할당으로 구현을 해야한다. Lecture lec1(\"Introduction to Computer Programming\"); lec1.assignTeacher(teacher1); lec1.registerTeacher(std1); lec1.registerTeacher(std2); lec1.registerTeacher(std3); Lecture lec2(\"Computational Thinking\"); lec2.assignTeacher(teacher2); lec2.registerTeacher(std1); cout &lt;&lt; lec1 &lt;&lt; endl; cout &lt;&lt; \"----------lec1\" &lt;&lt; endl; cout &lt;&lt; lec2 &lt;&lt; endl; cout &lt;&lt; \"----------lec2\" &lt;&lt; endl; lec2.study(); cout &lt;&lt; lec1 &lt;&lt; endl; cout &lt;&lt; \"----------lec1\" &lt;&lt; endl; cout &lt;&lt; lec2 &lt;&lt; endl; cout &lt;&lt; \"----------lec2\" &lt;&lt; endl; //포인터를 사용한후에 같은 학생에서 학습능력이 같이증가한다. //동적할당 제거 delete std1; delete std2; delete std3; delete teacher1; delete teacher2; //Lecture가 학생정보, 교사정보를 공유하고있다. //항상 이렇게 처리를 할순없다. //분산처리를 하는경우 컴퓨터마다 처리를 하므로 컴퓨터마다 정보를 가지고있어야한다. //각각의 기기들이 같은 데이터를 가지고 있어야하므로 업데이트를 해주는 동기화 작업이 필요하다. } return 0;}Lecture.h/* 과목 정보 헤더파일 */#pragma once#include &lt;vector&gt;#include \"Student.hpp\"#include \"Teacher.hpp\"class Lecture{private: std::string m_name; //과목 이름 // Teacher teacher; //교사 이름//// std::vector&lt;Student&gt; student; //학생 목록 //Lecture instance가 소멸이 되면 해당 과목의 teacher, student도 소멸하게 된다. //구성 관계에서 즁요한 특징중 하나였다. //과목의 객체의 멤버 변수가 각각 메모리주소를 다르게 쓰다보니 같은 학생의 경우 다른 학생으로 인식을 하는경우가 발생하는것을 막기 위해 //교사와 학생의 주소값을 사용하면된다. Teacher *teacher; //교사 이름 std::vector&lt;Student*&gt; student; //학생 목록 public: Lecture(const std::string &amp; name_in) : m_name(name_in) {} ~Lecture() { } void assignTeacher(Teacher *const teacher_input) { teacher = teacher_input; } void registerTeacher(Student *const student_input) { student.push_back(student_input); //&amp;student_input != &amp;student[0] 주소가 다르다. //student_input는 복사해서 들어가기 때문에 } void study() { std::cout &lt;&lt; m_name &lt;&lt; \" Study \" &lt;&lt; std::endl &lt;&lt; std::endl; //&amp; 사용하지않는경우 //값이 증가하지않는다.// for (auto &amp; e : student) {// e.setIntel(e.getIntel() + 1);// } for (auto e : student) { (*e).setIntel((*e).getIntel() + 1); } //이땐 &amp;를사용해도 된다.// for (auto &amp; e : student) {// e-&gt;setIntel(e-&gt;getIntel() + 1);// } } friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; out, const Lecture &amp; lecture) { out &lt;&lt; \"Lecture name : \" &lt;&lt; lecture.m_name &lt;&lt; std::endl; // out &lt;&lt; \"Teacher name : \" &lt;&lt; lecture.teacher &lt;&lt; std::endl;////// for (auto e : lecture.student) {// out &lt;&lt; e &lt;&lt; std::endl;// } out &lt;&lt; \"Teacher name : \" &lt;&lt; *lecture.teacher &lt;&lt; std::endl; for (auto e : lecture.student) { out &lt;&lt; *e &lt;&lt; std::endl; } return out; } };Teacher.h/* 교사 정보 헤더파일 */#pragma once#include &lt;string&gt;class Teacher{private: std::string m_name; //교사 이름 public: Teacher(const std::string &amp; name_in = \"No Name\") : m_name(name_in) {} void setName(const std::string &amp; name_in) { m_name = name_in; } std::string getName() { return m_name; } friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; out, const Teacher &amp; teacher) { out &lt;&lt; teacher.m_name; return out; } };Student.h/* 학생 정보 헤더파일 */#pragma once#include &lt;string&gt;#include &lt;iostream&gt;class Student{private: std::string m_name; //학생 이름 int m_intel; //학생 학습 능력치 public: Student(const std::string &amp; name_in = \"No Name\", const int &amp; intel_in =0) : m_name(name_in), m_intel(intel_in) {} void setName(const std::string &amp; name_in) { m_name = name_in; } void setIntel(const int &amp; intel_in) { m_intel = intel_in; } int getIntel() { return m_intel; } std::string getName() { return m_name; } friend std::ostream &amp; operator &lt;&lt; (std::ostream &amp; out, const Student &amp; student) { out &lt;&lt; student.m_name &lt;&lt; \", \" &lt;&lt; student.m_intel; return out; } };제휴 관계// 제휴관계// Association #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;//class Doctor; //Patient에서 Doctor를 사용하기 위해 forward declaration 사용/* 앞선 관계와 달리 Patient와 Doctor가 서로 동등한관계이며, 서로가 서로를 알아야한다. 파일이 분리가 되면 전방선언을보고 객체의 바디가 어디있는지 알아보기도 힘들고 링킹에러, 미구현사태가 발샐할수았다. 제휴관계는 앞선 관계보다 덜 사용하는것이 좋다. 어쩔수없으면 사용을 해야한다. 전방선언을 보게 되면 제휴관계인가보다 생각하고 코드를 읽어나가게 될것이다. */class Doctor;class Patient{private: string m_name; vector&lt;Doctor*&gt; m_doctors; public: Patient(string name_in) : m_name(name_in) {} //환자를 봐줄 의사를 배치 void addDoctor(Doctor * new_doctor) { m_doctors.push_back(new_doctor); } void meetDoctor();// {// for(auto &amp; ele : m_doctors)// cout &lt;&lt; ele-&gt;m_name &lt;&lt; endl; //전방선언을 하였지만, Doctor클래스에 m_name이 잇는지 m_age가 있는지 모른다.// //접근 방법 1 : Doctor에서 getName을 만든다.// //접근 방법 2 : Doctor에서 friend 키워드를 사용하여 Patient에서 접근 가능하게 한다.// }// friend class Doctor; };class Doctor{private: string m_name; vector&lt;Patient*&gt; m_patients; public: Doctor(string name_in) : m_name(name_in) {} //의사가 치료할 환자를 배치 void addPatient(Patient * new_patient) { m_patients.push_back(new_patient); } void meetPatient() { for(auto &amp; ele : m_patients) cout &lt;&lt; \"Meet Patient : \" &lt;&lt; ele-&gt;m_name &lt;&lt; endl; //접근 방법 1 : Doctor에서 getName을 만든다. //접근 방법 2 : Doctor에서 friend 키워드를 사용하여 Patient에서 접근 가능하게 한다. } friend class Patient;};//전방선언으로 인해 함수 구현을 밖에다 해주어야한다.void Patient::meetDoctor(){ for(auto &amp; ele : m_doctors) cout &lt;&lt; this-&gt;m_name &lt;&lt; \" Meet Doctor : \" &lt;&lt; ele-&gt;m_name &lt;&lt; endl; //접근 방법 1 : Doctor에서 getName을 만든다. //접근 방법 2 : Doctor에서 friend 키워드를 사용하여 Patient에서 접근 가능하게 한다.}int main() { //구성, 집합은 한곳이 전체, 한곳이 부품이 되는구성을 가지고있엇다. //몬스터/좌표 , 과목/(교사, 학생) //이번에는 구분이 명확하지않은 관계인제휴 관계를 알아보자 //예시 의사와 환자의 관계 Patient *p1 = new Patient(\"Jack Jack\"); Patient *p2 = new Patient(\"Dash\"); Patient *p3 = new Patient(\"Violet\"); Doctor *d1 = new Doctor(\"Doctor K\"); Doctor *d2 = new Doctor(\"Doctor L\"); //patients meet doctors //p1이 d1을 만난다면 p1-&gt;addDoctor(d1); //d1에 입장에선 p1이 환자로서 만나진다. d1-&gt;addPatient(p1); //p1과 d1 둘은 상호적이다. p2-&gt;addDoctor(d2); //doctors meet patients d2-&gt;addPatient(p2); p2-&gt;addDoctor(d1); d1-&gt;addPatient(p2); //p1 환자가 만나는 의사 출력 p1-&gt;meetDoctor(); //p2 환자가 만나는 의사 출력 p2-&gt; meetDoctor(); //d1이 만나는 환자 출력 d1-&gt;meetPatient(); //동적할당 제거 delete p1; delete p2; delete p3; delete d1; delete d2; //정리 //의사 환자 - 제휴관계 //서로가 내부에 상대방을 멤버로서 가지고있게 된다. //각각 자기 자신과 상호작용 해야하는 의사 컨테이너, 환자 컨테이너를 가지고있다. //한쪽에서는 전방선언을 해주어야한다. //구현팁 //벡터 포인터를 사용하지않고 환자의 ID로 찾는 방식으로 구현이 가능하다. //반사적 제휴관계? //의사가 의사를 만나는 관계 //서로가 동등한 관계를가진다. //용도외엔 무관하다. //서로가 서로를 관리를 하지 않는다. - 의사 클래스에서 환자클래스의 기록을 지운다던가 생성하던가 그런 행위를 하지않는다. return 0;}의존 관계main.cpp// 의존 관계// Dependencies#include &lt;iostream&gt;#include \"Worker.hpp\"using namespace std;//시간 재는 클래스//자주 사용할 기능들은 클래스로 묶어서 관리 한다.//class Timer//{// using clock_t = std::chrono::high_resolution_clock;// using second_t = std::chrono::duration&lt;double, std::ratio&lt;1&gt;&gt;;//// std::chrono::time_point&lt;clock_t&gt; start_time = clock_t::now();////public:// void elapsed()// {// std::chrono::time_point&lt;clock_t&gt; end_time = clock_t::now();//// cout &lt;&lt; std::chrono::duration_cast&lt;second_t&gt;(end_time - start_time).count() &lt;&lt; endl;// }//};//class Worker//{//public:// void doSomething()// {// Timer timer;// // //do some work here// // // timer.elapsed();// }// //함수가 끝나면 Timer는 사라진다.// //Timer에 대해 Worker는 알 필요가 없다.//};int main() { //앞에서 배운 3가지 관계보다 연결 강도가 느슨한 의존관계에 대해 알아보자 Worker().doSomething(); return 0;}//좀더 깔끔하게 구현이 된다.//가장 많이 사용할 패턴이다.//정리//잠깐 가져다 쓰는 관계//용도 외엔 무관//다른 관계들은 클래스에서 사용할 다른 클래스에 대해 알고있엇어야하지만, 의존관계는 클래스상에선 알필요가없다.Timer.h/* Timer 헤더 파일 분리 */#pragma once#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;chrono&gt;class Timer{ using clock_t = std::chrono::high_resolution_clock; using second_t = std::chrono::duration&lt;double, std::ratio&lt;1&gt;&gt;; std::chrono::time_point&lt;clock_t&gt; start_time = clock_t::now(); public: void elapsed() { std::chrono::time_point&lt;clock_t&gt; end_time = clock_t::now(); std::cout &lt;&lt; std::chrono::duration_cast&lt;second_t&gt;(end_time - start_time).count() &lt;&lt; std::endl; }};Worker.h/* Worker 헤더 파일 분리 */#pragma once//#include \"Timer.hpp\"//Worker 헤더는 Timer에 대해 무엇인가 알기 위해 include함//Worker cpp파일을 생성해서 옮기면//Worker를 선언할때 Timer에 대해 알 필요가 없으므로 include 제거 가능 class Worker{public: void doSomething(); //함수가 끝나면 Timer는 사라진다. //Timer에 대해 Worker는 알 필요가 없다.};//의존 관계에서는 선언부에서는 Timer에 대해 몰라도 된다.//바디부분에서만 알면된다.Worker.cpp#include \"Worker.hpp\"#include \"Timer.hpp\"void Worker::doSomething(){ Timer timer; //do some work here timer.elapsed();}컨테이너 클래스// 컨테이너 클래스// Container Class#include &lt;iostream&gt;using namespace std;int main() { //이번에는 다른 클래스들을 담는역할을 하는 컨테이너 클래스를 알아보자 //지금까지 사용한 컨테이너 클래스 std::vector&lt;int&gt; int_vec; std::array&lt;int, 10&gt; int_arr; //컨테이너 종류가 많다. //~가 ~의 멤버다 memver-of로 표시가 가능하다. //int가 int_vec의 멤버이다. //int가 int_arr의 멤버이다. //직접 구현 해보기 //int 자료형이 담기는 array를 직접 구현해보자 /* Constructor Destructor initialize reset resize insertBefore remove push_back */ /* IntArry my_arr{1,3,5,7,9}; my_arr.insertBefore(10,1); //1,10,3,5,7,9 my_arr.remove(3); //1,10,3,7,9 my_array.push_back(13); //1,10,3,7,9,13 */ //사용법을 이해하는것보다 //직접 구현을 한번해보고 컨테이너에 대해 알아보자 return 0;}" }, { "title": "[C++] Chapter.6 행렬, 문자열, 포인터, 참조", "url": "/posts/Cpp-Ch6/", "categories": "Language, C++", "tags": "c++", "date": "2022-09-08 22:20:19 +0900", "snippet": "배열의 기초적인 사용법//배열의 기초적인 사용법#include &lt;iostream&gt;using namespace std;//구조체 선언struct Rectangle{ int length; int width;};enum StudentName{ JACK, //0 LEE, //1 PARK, //2};int main() { //Array 비슷한것이 나열되어있는 구조 //동기 //이전까지의 //학생의 성적 기록 //변수 여러개 사용하여 하나씩 저장 //엠티 콘도 한층 빌리는것을생각 //배열 선언 int student_scores[5]; //5 int int student_one; //크기비교 cout &lt;&lt; sizeof(student_one) &lt;&lt; endl; //4 cout &lt;&lt; sizeof(student_scores) &lt;&lt; endl; //20 = int 5개가 되어 4 * 5 = 20이 된다. //어떠한 경우 배열의 크기가 너무커서 사용 못할수도잇다. - 변수의 크기가 너무 큰경우 //배열 대입 방법 student_scores[0] = 100; //1st element student_scores[1] = 80; //2nd element student_scores[2] = 90; //3rd element student_scores[3] = 50; //4th element student_scores[4] = 0; //5th element //잘못된 경우 - 오류 발생 //student_scores[5] = 30; //배열은 0부터 시작하여 n-1번까지 사용한다. cout &lt;&lt; student_scores[0] &lt;&lt; endl; cout &lt;&lt; student_scores[1] &lt;&lt; endl; cout &lt;&lt; student_scores[2] &lt;&lt; endl; cout &lt;&lt; student_scores[3] &lt;&lt; endl; cout &lt;&lt; student_scores[4] &lt;&lt; endl; //오류발생 //cout &lt;&lt; student_scores[5] &lt;&lt; endl; //출력은 된다. //변수처럼 연산자도 사용가능 cout &lt;&lt; student_scores[0] + student_scores[3] &lt;&lt; endl; //구조체 배열 선언 Rectangle rec[10]; cout &lt;&lt; sizeof(Rectangle) &lt;&lt; endl; //int 2개 : 8 cout &lt;&lt; sizeof(rec) &lt;&lt; endl; //int 2개 * 배열 10개 : 80 //배열 초기화방법 int arr[5] = {1, 2, 3, 4, 5}; cout &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; arr[1] &lt;&lt; endl; cout &lt;&lt; arr[2] &lt;&lt; endl; cout &lt;&lt; arr[3] &lt;&lt; endl; cout &lt;&lt; arr[4] &lt;&lt; endl; //배열의 크기가 정확한 경우 []안에 숫자 없이 초기화가능 - 자동으로 크기에 맞춰준다. //int arr[] = {1, 2, 3, 4, 5}; //배열 일부만 초기화가능 int arr2[5] = {1, 2}; //enum을 사용할수도잇다. //index도 enum으로 시용할수있다. cout &lt;&lt; arr[JACK] &lt;&lt; endl; cout &lt;&lt; arr[LEE] &lt;&lt; endl; cout &lt;&lt; arr[PARK] &lt;&lt; endl; //사이즈가 컴파일 타입에 고정이 되어야한다. int num_st; cin &gt;&gt; num_st; //index값이 불변적이라 오류값이 발생한다. //컴파일 타입에 숫자가 고정이 되어야한다 int student_values[num_st]; return 0;}배열 2/2//배열의 기초적인 사용법#include &lt;iostream&gt;using namespace std;//배열안의 값은 있어도 없어도 무방하다//포인터 변수로 받아오기때문에void doSomething(int student_scores[20]){ cout &lt;&lt; \"--values--\" &lt;&lt; endl; cout &lt;&lt; student_scores[0] &lt;&lt; endl; cout &lt;&lt; student_scores[1] &lt;&lt; endl; cout &lt;&lt; student_scores[2] &lt;&lt; endl; cout &lt;&lt; student_scores[3] &lt;&lt; endl; cout &lt;&lt; student_scores[4] &lt;&lt; endl; cout &lt;&lt; \"--address--\" &lt;&lt; endl; cout &lt;&lt; (size_t)&amp;student_scores &lt;&lt; endl; //함수 내부의 배열과 차이가 발생한다. //이값은 배열이 아니고 넘겨받은 배열의 첫번째 주소값을 저장하는 포인터 변수를받기때문에 //파라미터의 변수는 주소값을 저장하는 다른 변수로 저장하기 때문에 주소값이 달라지는것이다. cout &lt;&lt; (size_t)&amp;student_scores[0] &lt;&lt; endl; // cout &lt;&lt; (size_t)&amp;student_scores[1] &lt;&lt; endl; cout &lt;&lt; (size_t)&amp;student_scores[2] &lt;&lt; endl; cout &lt;&lt; (size_t)&amp;student_scores[3] &lt;&lt; endl; cout &lt;&lt; (size_t)&amp;student_scores[4] &lt;&lt; endl; cout &lt;&lt; sizeof(student_scores) &lt;&lt; endl; //포인터 변수의 사이즈를 출력한다. //32의 경우 4 //64인 경우 8 출력 //32비트에선 포인터의 변수 = 4바이트 //64비트에선 포인터의 변수 = 8바이트}int main() { //배열의 주소 방식 &amp; 함수 파라미터에서의 배열 사용 const int num_student = 20; int student_scores[num_student] = {1,2,3,4,5}; //배열 전체 주소 출력 //10진법으로 출력하기위해 casting 사용 //(long long) / (size_t)사용을 권장한다. cout &lt;&lt; (long)&amp;student_scores &lt;&lt; endl; //6171914940 //배열의 인덱스 주소 출력 cout &lt;&lt; (long)&amp;student_scores[0] &lt;&lt; endl; //6171914936 cout &lt;&lt; (long)&amp;student_scores[1] &lt;&lt; endl; //6171914940 cout &lt;&lt; (long)&amp;student_scores[2] &lt;&lt; endl; //6171914944 cout &lt;&lt; (long)&amp;student_scores[3] &lt;&lt; endl; //6171914948 //인덱스 값에 따라 숫자가 4씩 증가한다 =&gt; int 자료형의크기 = 4 //배열의 주소는 첫번째, 즉 인덱스가 0번인 배열과 주소가 같다. //함수 파라미터에 배열을 넣을수 있다. doSomething(student_scores); //함수 내부의 배열의 주소가 다른이유 //배열의 이름 = 인식자 identifier로 사용이 된다. //배열의 경우 변수명을 내부적으로 주소로 사용한다. //그리하여 배열의 경우 앞에 &amp;를 안 붙여도 주소값을 출력한다. //배열의 경우 주소로 데이터를주고받는것보다 데이터를 모두 복사하는것보다 효율이 좋기때문이다. //함수의 파라미터의 경우는 생긴건 배열처럼 보이지만 문법상 배열이 아니고 포인터라고 한다. //컴파일러는 포인터로 인식한다. //함수 파라미터로 넣어주게 되면 배열을 복사하는것이 아니라 주소값만 복사한다. //그래서 함수의 파라미터로 배열을 넣어줄때 그냥 포인터로 넣어주는 경우도 있긴하다고 한다. cout &lt;&lt; (size_t)student_scores &lt;&lt; endl; return 0;}배열과 반복문//배열과 반복문#include &lt;iostream&gt;using namespace std;int main() { //배열은 같은 자료형을 나열한것이므로 반복문을 사용하면 편해진다. //앞에서 하나하나씩 출력한것을 반복문을 사용하면 편해진다. //반복문을 안사용하는 경우 const int num_student = 5; int score0 = 10; int score1 = 20; int score2 = 30; int score3 = 40; int score4 = 50; int total_score = score0 + score1 + score2 + score3 + score4; double avg_score = static_cast&lt;double&gt;(total_score) / num_student; cout &lt;&lt; \"total : \" &lt;&lt; total_score &lt;&lt; endl; cout &lt;&lt; \"avg : \" &lt;&lt; avg_score &lt;&lt; endl; //반복문 사용 int scores[num_student] = {10, 20, 30, 40 ,50}; total_score = 0; avg_score = 0.0; for (int i = 0; i &lt; num_student; ++i) { total_score += scores[i]; } avg_score = static_cast&lt;double&gt;(total_score) / num_student; cout &lt;&lt; \"loop use total : \" &lt;&lt; total_score &lt;&lt; endl; cout &lt;&lt; \"loop use avg : \" &lt;&lt; avg_score &lt;&lt; endl; //배열의 인덱스 갯수 구하는 방법 const int num_arr = sizeof(scores) / sizeof(int); cout &lt;&lt; \"array size : \" &lt;&lt; num_arr &lt;&lt; endl; int max_score = 0; int min_score = INT_MAX; for (int i = 0; i &lt; num_arr; ++i) { //최댓값 if(max_score &lt; scores[i]) max_score = scores[i]; //최솟값 min_score = (min_score &gt; scores[i]) ? scores[i] : min_score; } cout &lt;&lt; \"max value : \" &lt;&lt; max_score &lt;&lt; endl; cout &lt;&lt; \"min value : \" &lt;&lt; min_score &lt;&lt; endl; return 0; }배열과 선택 정렬 selection sort//배열과 선택정렬//selection sort#include &lt;iostream&gt;using namespace std;void printArray(int array[], int length){ for (int i = 0; i &lt; length; ++i) { cout &lt;&lt; array[i] &lt;&lt; \" \"; } cout &lt;&lt; endl;}int main() { //배열 사용법을 더 연습하기 위해 정렬 중 선택 정렬을 구현해본다. //선택정렬 /* index value 3 5 2 1 4 0 3 &gt; 1 1 5 2 3 4 1 5 &gt; 2 1 2 5 3 4 2 5 &gt; 3 1 2 3 5 4 3 5 &gt; 4 1 2 3 4 5 end end 인덱스 0번부터 작은숫자 비교하여 값을 바꾸고 다음 인덱스 1번부터 작은숫자를 비교하여 값을 바꾸는식으로 인덱스 값만큼 반복하여 오름차순으로 정렬을한다. */ //선택 정렬 구현 const int length = 5; int arr[length] = {3, 5, 2, 1, 4}; printArray(arr, length); //내가 만든거 for (int i = 0; i &lt; length; ++i) { int min = INT_MAX; int min_idx = 0; for (int j = i; j &lt; length; ++j) { if(min &gt; arr[j]) { min = arr[j]; min_idx = j; } } int temp = arr[i]; arr[i] = arr[min_idx]; arr[min_idx] = temp; } printArray(arr, length); cout &lt;&lt; \"hong's code\" &lt;&lt; endl; //강의에서 만든거 for (int startIndex = 0; startIndex &lt; length - 1; ++startIndex) { int smallestIndex = startIndex; for (int currentIndex = startIndex+1; currentIndex &lt; length; ++currentIndex) { if(arr[smallestIndex] &gt; arr[currentIndex]) { smallestIndex = currentIndex; } } //swap two values in the array //std::swap( arr[smallestIndex], arr[i]); int temp = arr[smallestIndex]; arr[smallestIndex] = arr[startIndex]; arr[startIndex] = temp; } printArray(arr, length); //swap int temp = arr[0]; arr[0] = arr[1]; arr[1] = temp; printArray(arr, length); return 0;}정적 다차원 배열// 정적 다차원 배열// Multi-dimensional Array#include &lt;iostream&gt;using namespace std;int main() { //컴퓨터 메모리는 1차원적인주소공간을 가지고있다. //건물 복도 형식으로 되어있는데 배열을 사용하면서 건물처럼 사용해야할때가 발생한다. //일차원인것을 다차원인것처럼 사용한다. //나중에 동적 할당을 배우면 동적 다차원 배열도 배운다. //2차원적 배열 //가장 기본적인 2차원 구조 = 행렬 구조 const int num_rows = 3; const int num_columns = 5; for (int row = 0; row &lt; num_rows; ++row) { for (int col = 0; col &lt; num_columns; ++col) { cout &lt;&lt; '[' &lt;&lt; row &lt;&lt; ']' &lt;&lt; '[' &lt;&lt; col &lt;&lt;']' &lt;&lt; '\\t'; } cout &lt;&lt; endl; } /* [0][0] [0][1] [0][2] [0][3] [0][4] [1][0] [1][1] [1][2] [1][3] [1][4] [2][0] [2][1] [2][2] [2][3] [2][4] */ //다차원 배열 선언 방법 int arr[num_rows][num_columns]; //row-major 방식 &lt;-&gt; colum-major //하나씩 초기화 하는 방법 arr[0][0] = 1; int arr2[num_rows][num_columns] = { {1,2,3,4,5}, //row 0 {6,7,8,9,10}, //row 1 {11,12,13,14,15} //row 2 }; for (int row = 0; row &lt; num_rows; ++row) { for (int col = 0; col &lt; num_columns; ++col) { cout &lt;&lt; arr2[row][col] &lt;&lt; '\\t'; } cout &lt;&lt; endl; } //1차원 배열이 3줄 출력된다. /* 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 */ //다차원배열 주소출력 for (int row = 0; row &lt; num_rows; ++row) { for (int col = 0; col &lt; num_columns; ++col) { cout &lt;&lt; (size_t)&amp;arr2[row][col] &lt;&lt; '\\t'; } cout &lt;&lt; endl; } /* 6171914896 6171914900 6171914904 6171914908 6171914912 6171914916 6171914920 6171914924 6171914928 6171914932 6171914936 6171914940 6171914944 6171914948 6171914952 */ //일차원 배열 1개가 끝나고 다음 줄에 4씩 증가한것을 보고 //처음에 말한 1차원 배열을 다차원인것 처럼 사용한다는것이 이것을 보고 이해할 수 있다. //주소형식이 4씩증가하고 끝에서 다음 배열로 넘어갈때더 4씩 증가한것을 보고 일렬로 되어 있는 주소가 접힌것처럼 보이게 된다. //초기화 하는 방법2 //num_rows는 생략 가능 ,num_columns는 생략 불가능 //num_rows를 생략하는 경우 하나의 배열에는 모든 항목에 값이 들어가있어야한다. //배열에 빈값이 생기면 알아서 0으로 채워준다. int arr3[][num_columns] = { {1}, //row 0 {6,7,8,9,10}, //row 1 {11,12,13,14,15} //row 2 }; //3차원 배열 방식 int arr4[3][4][5]; return 0;}C언어 스타일의 배열 문자열// C언어 스타일의 배열 문자열#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() { //원래 기본적으로 사용하는 문자열은 string가 아닌 배열스타일의문자열이다. char str[] = \"string\"; //문자열은 마지막에 널값이 들어간다. '\\0' for (int i = 0; i &lt; 7; ++i) { cout &lt;&lt; (size_t)str[i] &lt;&lt; endl; } /* 115 116 114 105 110 103 0 */ //진짜 7자인지 크기로 다시 확인 cout &lt;&lt; sizeof(str) / sizeof(str[0]) &lt;&lt; endl; //7 출력 //문자입력 char str2[255]; cin &gt;&gt; str2; //문자 입력후 배열 방식으로 글자를 바꿔줄수도있다. str2[4] = '\\0'; //cout은 \\0이 나오기전까지 출력한다. cout &lt;&lt; str2 &lt;&lt; endl; cin.ignore(32767, '\\n'); cin.getline(str2, 255); cout &lt;&lt; str2 &lt;&lt; endl; //빈칸과 null은 다른값이다. int idx = 0; while(true) { if(str2[idx] == '\\0') break; cout &lt;&lt; \"char : \" &lt;&lt; str2[idx] &lt;&lt; \", \" &lt;&lt; \"ascii code : \" &lt;&lt; (size_t)str2[idx] &lt;&lt; endl; ++idx; } //null = 0 , 빈칸 = 32 //전통적인 c style coding char source[] = \"Copy this!\"; char dest[50]; //문자 복사하는 함수 strcpy(dest, source); cout &lt;&lt; source &lt;&lt; endl; cout &lt;&lt; dest &lt;&lt; endl; //strcat - 문자열 뒤에 문자열을 붙여주는함수 //strcmp() - 문자열 두개가 같은지 비교하는 함수 cout &lt;&lt; strcmp(source, dest) &lt;&lt; endl; //같으면 0 , 틀리면 -1 cout &lt;&lt; strcat(source, \"test\") &lt;&lt; endl; cout &lt;&lt; source &lt;&lt; endl; return 0;}포인터의 기본적인 사용법// 포인어틔 기본적인 사용법#include &lt;iostream&gt;#include &lt;typeinfo&gt;using namespace std;//포인터 반환형도 가능하다.//파라미터에도 포인터 변수를넣을수있다.int* doSomething(int* ptr_a){ return nullptr;}struct Something{ int a, b, c, d;};int main() { //포인터 - c cpp에서 중요한 특징중 하나 //코드가 내부적으로 어떤식으로 작동하는지 CPU/메모리가 어떻게 사용되는지 알기위한 중요한 요소 //지역 변수는 스택 메모리를 사용하고 //동적할당 메모리는 힙 메모리를 사용한다. //메모리에 저장되어있는 데이터를 사용하기 위해 메모리 전체를 찾는것이 아닌 데이터의 주소를 사용하여 가져온다. int x = 5; //x 주소에 5를 저장하고 cout &lt;&lt; x &lt;&lt; endl; //x의 주소를 따라가서 x의 값인 5를 출력한다. cout &lt;&lt; &amp;x &lt;&lt; endl; //&amp; address of operator //16진수로 표현한다. //x의 주소를 출력한다. //메모리 주소를 담는 변수를 포인터라고 한다. //de reference operator (*) //참조용 ? 연산자? //pointer - 이 주소를 따라가면 데이터가 존재해 -&gt; 간접적으로 알려주겠다는 의미 //de-reference operator - 그 주소에 진짜 무엇이 잇는지 두눈으로 확인해보께 -&gt; 직접적으로 접근하겠다는 의미 cout &lt;&lt; *(&amp;x) &lt;&lt; endl; //주소에 있는 값을 출력한다. //포인터 - 메모리 주소를 담는 변수 //변수라는점을 기억하자 int *ptr_x = &amp;x; //변수 앞에 붙이는것이 안헷갈리고 좋다.// int* ptr1 = &amp;x; //자료형 앞에 붙여도 된다.// int* ptr2 = &amp;x, ptr3 = &amp;x; //자료형 앞에 붙이면 여러개를 초기화 하는경우 헷갈릴수있다. //ptr2 는 포인터 변수 ptr3는 일반 변수 //포인터가 자료형을 가져야하는 이유 //de-reference가 값을 가져올때 자료형을 지정하기 위해 필요하다. cout &lt;&lt; ptr_x &lt;&lt; endl; cout &lt;&lt; *ptr_x &lt;&lt; endl; cout &lt;&lt; \"TEST\" &lt;&lt; endl; //포인터를 사용하는이유 //배열을 복사하는 경우 //변수를 여러곳에서 사용하는 경우 double d = 1.0; double *ptr_d = &amp;d; cout &lt;&lt; ptr_d &lt;&lt; endl; cout &lt;&lt; *ptr_d &lt;&lt; endl; cout &lt;&lt; typeid(ptr_x).name() &lt;&lt; endl; cout &lt;&lt; sizeof(x) &lt;&lt; endl; cout &lt;&lt; sizeof(d) &lt;&lt; endl; cout &lt;&lt; sizeof(&amp;x) &lt;&lt; \", \" &lt;&lt; sizeof(ptr_x)&lt;&lt; endl; cout &lt;&lt; sizeof(&amp;d) &lt;&lt; \", \" &lt;&lt; sizeof(ptr_d)&lt;&lt; endl; //포인터의 크기는 모두 같다. //모든 주소는 같은 길이의 주소이다. //우편번호 길이가 모두 같은것처럼 주소길이는 자료형에 상관없이 일정하다. //구조체도 포인터가 사용가능하다. Something ss; Something *ptr_s; cout &lt;&lt; sizeof(ss) &lt;&lt; endl; cout &lt;&lt; sizeof(ptr_s) &lt;&lt; endl; //문제가 되는 경우 //초기화가 안된경우 실행하면 안된다. int *ptr; cout &lt;&lt; *ptr &lt;&lt; endl; return 0;}널 포인터 null pointer// 널 포인터// NULL Pointer#include &lt;iostream&gt;#include &lt;cstddef&gt;using namespace std;void doSomething(double *ptr){ if (ptr != nullptr) { cout &lt;&lt; *ptr &lt;&lt; endl; } else { cout &lt;&lt; \"null address\" &lt;&lt; endl; }}int main() { //쓰레기값 주소를 찾는 경우 오류가발생하는경우를 방지하기위해 널포인터를 사용한다. //사용방법 //c style double *ptr_d = 0; //modern cpp double *ptr = nullptr; //조건문으로 주소값 판단하여 사용가능 if (ptr != nullptr) { } else { } doSomething(ptr); doSomething(nullptr); //추가내용 cstddef:: nullptr만 사용하는 변수 nullptr_t nptr; return 0;}포인터와 정적배열// 포인터와 정적 배열#include &lt;iostream&gt;using namespace std;//[]가 있어서 배열처럼 보이지만 내부적으로는 포인터로 작동한다.void printArrary(int arr[]){ cout &lt;&lt; sizeof(arr) &lt;&lt; endl; //포인터의 값이 출력 cout &lt;&lt; *arr &lt;&lt; endl; //9를 100으로 변경 *arr = 100;}struct MyStruct{ int arr[5] = {9,7,5,3,1};};void doSomething(MyStruct ms){ cout &lt;&lt; sizeof(ms.arr) &lt;&lt; endl;}void doSomething(MyStruct *ms){ cout &lt;&lt; sizeof((*ms).arr) &lt;&lt; endl;}//printArrary1 과 printArrary2는 같은 함수이다.void printArrary2(int *arr);int main() { //포인터와 정적배열과의 관계를 파악해보자! //포인터와 배열은 같다? int arr[5] = {9,7,5,3,1}; cout &lt;&lt; &amp;(arr) &lt;&lt; endl; cout &lt;&lt; arr &lt;&lt; endl; //배열에서 말한것처럼 배열은 주소의 첫값을 출력한다. //배열은 다시말하면 포인터이다. //포인터를 이용하여 사용해보자! cout &lt;&lt; *arr &lt;&lt; endl; //9출력 char name[] = \"Lee\"; cout &lt;&lt; *name &lt;&lt; endl; //L 출력 //int형 pointer를 뜻하는 * int *ptr = arr; cout &lt;&lt; ptr &lt;&lt; endl; //de-reference를 뜻하는 * cout &lt;&lt; *ptr &lt;&lt; endl; //포인터와 정적배열이 진짜 같은지? //문법상으로 좀 다르다. //정적배열에서 편의성 기능 몇개를 위해 정적배열을 사용하는것이다. //나중에는 주로 동적할당 포인터를 사용하게될것이다. cout &lt;&lt; sizeof(arr) &lt;&lt; endl; //전체의 사이즈 //전체 배열의 크기 cout &lt;&lt; sizeof(ptr) &lt;&lt; endl; //주소의 크기 //문제 발생요소 //함수 파라미터를 사용할떄 발생항ㄴ다. printArrary(arr); //중요한 성질 cout &lt;&lt; arr[0] &lt;&lt; \", \" &lt;&lt; *arr &lt;&lt; endl; //함수 안에서 100으로 바꾸어도 밖에서도 값이 바뀐값으로 출력이 된다. //포인터 연산 cout &lt;&lt; *ptr &lt;&lt; \", \" &lt;&lt; *(ptr+1) &lt;&lt; endl; //+1을 하여 다음 주소에 들어잇는 7이 출력이된다. //구조체 포인터 MyStruct ms; cout &lt;&lt; ms.arr[0] &lt;&lt; endl; cout &lt;&lt; sizeof(ms.arr) &lt;&lt; endl; doSomething(ms); // doSomething(&amp;ms); // //배열이 구조체나 클래스안에있는경우 포인터로 강제로 변환 되지않는다. return 0;}포인터 연산과 배열 인덱싱// 포인터 연산과 배열 인덱싱 indexing#include &lt;iostream&gt;using namespace std;int main() { //포인터는 주소를 저장하는 변수 //변수니까 연산도 가능하다. int val = 7; int *ptr = &amp;val; //십진수로 주소를 출력하는함수 cout &lt;&lt; uintptr_t(ptr) &lt;&lt; endl; cout &lt;&lt; uintptr_t(ptr + 1) &lt;&lt; endl; cout &lt;&lt; uintptr_t(ptr - 1) &lt;&lt; endl; cout &lt;&lt; uintptr_t(ptr + 2) &lt;&lt; endl; //포인터 변수는 크기가 고정이지만 변수타입을 지정하는이유 //포인터 연산을 하는경우에 메모리 크기만큼 이동하기 때문이다. //array에서 사용 int arr[] = {9,7,5,3,1}; //포인터 연산 사용 int *ptr2 = arr; for (int i = 0; i &lt; 5; ++i) { //이터레이트 = 배열의 값을 가져오는 작업 cout &lt;&lt; *(ptr2+i) &lt;&lt; \", \" &lt;&lt; uintptr_t(ptr2+i) &lt;&lt; endl; } //문자열에서 사용 char name[] = \"Lee\"; const int n_name = sizeof(name) / sizeof(char); char *ptr3 = name; for (int i = 0; i &lt; n_name; ++i) { //배열도 포인터와 같다고 전에 배웟으니 아래 코드는 같은출력을 보여준다. cout &lt;&lt; *(name + i) &lt;&lt; endl; cout &lt;&lt; *(ptr3 + i) &lt;&lt; endl; } for (int i = 0; i &lt; n_name; ++i) { cout &lt;&lt; *(ptr3 + i) &lt;&lt; endl; } //전,후위 증감 사용도 가능하다. while (*ptr3 != 0) { cout &lt;&lt; *ptr3 &lt;&lt; endl; ptr3++; } return 0;}C언어 스타일의 문자열 심볼릭 상수// C스타일의 문자열 기호적 상수#include &lt;iostream&gt;using namespace std;const char* getName(){ return \"Lee\";}int main() { //문자열 = 문자의 배열 , 배열 = 포인터 // // char name[] = \"Lee\"; //char *name = \"Lee\"; //리터럴 자체를 포인터에 넣을순 없다. //리터럴은 const char *name = \"Lee\"; //const를 사용하면 사용 가능하다. const char *name2 = \"Lee\"; const char *name3 = \"Lee2\"; cout &lt;&lt; \"address : \" &lt;&lt; (uintptr_t)name &lt;&lt; \", value : \" &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; \"address : \" &lt;&lt; (uintptr_t)name2 &lt;&lt; \", value : \" &lt;&lt; name2 &lt;&lt; endl; //두개의주소가 같다. cout &lt;&lt; \"address : \" &lt;&lt; (uintptr_t)name3 &lt;&lt; \", value : \" &lt;&lt; name3 &lt;&lt; endl; //리터럴값이 달라지면 주소가 달라진다. //아직 까진 그냥다르구나라고 생각하면 될듯하다. //함수 반환형로도 const pointer가 사용가능하다. const char *name4 = getName(); //문자 포인터의 특성 int int_arr[5] = {1,2,3,4,5}; char char_arr[] = \"Hello World!\"; const char *ch_ptr = \"Lee\"; cout &lt;&lt; int_arr &lt;&lt; endl; //주소 출력 cout &lt;&lt; char_arr &lt;&lt; endl; //문자열 출력 cout &lt;&lt; ch_ptr &lt;&lt; endl; //문자열 출력 //문자열이 출력되는 이유 &gt;&gt; cout에서는 문자열은 특별하게 처리되어 문자열이 출력되는것이다. //문자열의 null값 즉 \\0을 만날때 까지 출력을 하도록 되어있다. //포인터 주소를 직접 출력하는일이 공부할때 빼고 실무적으로 사용하는일이 없다. //그래서 문자열의 포인터는 주소가 아닌 문자열을 출력한다. char c = 'Q'; cout &lt;&lt; &amp;c &lt;&lt; endl; //Q에 이상한값도 같이 나온다. //문자열의 포인터를 출력하는경우 null(\\0)을 만날뗴까지 출력하느라 이상한값이 출력이 되는것이다. return 0;}메모리 동적 할당 new와 delete// 메모리 동적 할당 new와 delete// Dynamic Memory Allocation#include &lt;iostream&gt;using namespace std;int main() { //메모리 할당 방식 3가지 //정적 메모리 - static memory //한번 만들면 프로그램이 끝날떄까지 메모리를 잡아두는 방식 //자동 메모리 - //범위를 벗어나는 순간사라지는 메모리 방식 //동적 메모리 - dynamic memory // //정적 메모리 할당 = 100개의 메모리를사용한다. int arr[100]; //int arr[10000000]; //메모리가 부족하여 컴파일 오류 발생 //정적 할당 - 스택 메모리(stack memory)에 할당이된다. //오류가 나는 이유 - 스택의 메모리 용량이 작아서 오류가 발생 //Stack frame size (1345294384) exceeds limit (4294967295) in function 'main' //xcode 오류 메세지 //동적 할당 - 힙 메모리(Heap)에 할당이 된다. //힙메모리는 스택에 비해 용량이 엄청 크다. //뒤에서 스택 과 힙에서 다시배우게 된다. //여기서는문제가 이런식으로 나는구나만 확인하고 넘어가자 //새로운 변수 선언 방법 //new int; //new = 자료형 사이즈의 메모리를 os로 부터 받고 주소를 알려주는 연산자이다. - 주소를 받아오는 연산자이므로 포인터를 사용해서 받는다. int *ptr = new int; *ptr = 7; //int val = 7과 같은 방식이다. //굳이 new를사용하는이유 - 배열 동적할당에서 크기문제로 인하여 장점이 많아서 사용한다. 자세한 내용은 다음 강의에 배운다고 한다. //메모리 할당하면서 초기화 가능하다.// int *ptr2 = new int(7); cout &lt;&lt; ptr &lt;&lt; endl; cout &lt;&lt; *ptr &lt;&lt; endl;// cout &lt;&lt; ptr2 &lt;&lt; endl;// cout &lt;&lt; *ptr2 &lt;&lt; endl; //메모리 할당을 되돌려 주는 방법 //메모리를 돌려줘야하는이유 //컴퓨터 하나에 여러 프로그램에서 여러가지로 메모리를 많이 사용하는 경우 메모리기 부족한 경우가 발생한다. //컴퓨터 전체적으로 볼때 메모리를 효율적으로 사용하기위해 반환 해주는것이 중요하다. delete ptr; cout &lt;&lt; ptr &lt;&lt; endl; cout &lt;&lt; *ptr &lt;&lt; endl; //메모리 반환후 메모리주소는 남아있다. //출력값은 이상한 값을 가져온다. //이유 : 메모리는 반환을 하였지만 주소는 남아있어 원래 주소로 가서 값을 가져와서 출력이 되는것이다. //방지 하는 방법 ptr = nullptr; //ptr메모리를반환하고 포인터를 null로 만들어준다. if(ptr != nullptr) { cout &lt;&lt; ptr &lt;&lt; endl; cout &lt;&lt; *ptr &lt;&lt; endl; } //예전에는이렇게 햇지만 요즘엔 스마트 포인터를 사용하면 편해진다고 한다. //메모리가 부족하여 변수할당이 안되는 경우 처리하는 대표적인 방법 2가지 //프로그램이 죽도록 하는 방법 //메모리가 비워질때까지 버티는 방법 //메모리 공간이 나올때까지 버티다가 할당 받는 방법 int *ptr2 = new (std::nothrow) int{7}; //throw 예외처리 부분에서 다시 배우게 될것이다. //메모리가 부족한경우 일단 ptr2에 nullptr을 넣어주고 할당이 될수있으면 7을 넣게 된다고 한다. //흔히 하는실수 /* int *ptr3 = ptr; delete ptr; ptr = nullptr; 엮어서 초기화 하는 경우 원본인 ptr을 지우고 ptr3를 사용하려 했을때 오류가 발생한다. 코드가 점점 복잡해지면서 원본이 지워졋음에도 ptr3를 사용하려고 하는 실수를 범하게 된다. delete를 하는경우 delete하는 메모리 주소를 사용하는 다른변수가 있는지 확인하고 있다면 그 포인터도 null로 만들어주어야한다. delete ptr; ptr = nullptr; delete ptr3; ptr3 = nullptr; */ //memoty leak 메모리 유수// while(true)// {//// int *ptr5 = new int;// cout &lt;&lt; ptr5 &lt;&lt; endl;// delete ptr5;// } //new delete는 느린 연산자이다. //os를 통해 사용하는 연산자 //적게 사용하는방식으로 만들어야한다. //직접적으로 메모리를 조절가능해서 사용하는 방식은 중요하다. return 0;}동적 할당 배열// 동적 할당 배열// Dynamically Allocting Arrarys#include &lt;iostream&gt;using namespace std;int main() {// //정적 배열 -타입이 정해져야함// //동적 배열 - 런타임에 배열 사이즈를 정해준다. os로부터 받아온다.////// //정적 할당// const int s_length = 5;// int s_arr[s_length];////// //동적 할당// int d_length;//// //초기화 방법// int *d_arr = new int[d_length]{1,2,3,4,5,6};//// cin &gt;&gt; d_length;// d_arr[0] = 1;// d_arr[1] = 2;////// for (int i = 0 ; i &lt; d_length; ++i) {// cout &lt;&lt; d_arr[i] &lt;&lt; endl;// cout &lt;&lt; (uintptr_t)&amp;d_arr[i] &lt;&lt; endl;// }//// //배열 delete 방법// delete [] d_arr;// int fixedArray[] = {1,2,3,4,5}; //배열을 초기화할때 크기가정해져있는경우 앞에 숫자를 빼면 오류가 발생한다. int *array = new int[]{1,2,3,4,5}; //resizing //직접적으로는불가 //1. 큰 사이즈를 만들고 늘리고 싶은 배열을 다시 넣고 추가하는 방식 //2. os에게 메모리를 받을떄 추가할수있는지 요청해보고 안되면 1번 방식으로 해야함 delete[] array; return 0;}포인터와 const// 포인터와 const#include &lt;iostream&gt;using namespace std;int main() { //포인터에도 const로 선언가능하다. //일반 변수 const와 무슨 차이가 있는지 확인해보자. const int val = 5; const int *ptr = &amp;val; //변수가 const이면 포인터도 const로 받아야한다. //*ptr = 6; //값변경은 불가 cout &lt;&lt; *ptr&lt;&lt; endl; int val2 = 6; const int *ptr2 = &amp;val2; //const 포인터가 일반 변수여도 가능하다. cout &lt;&lt; *ptr2&lt;&lt; endl; val2 = 7; //일반 변수 값 변경가능 //*val2 = 8; //*를 이용하여 포인터 변수 값 변경 불가 cout &lt;&lt; *ptr2&lt;&lt; endl; //변경된 7 출력됨 //포인터 자체는 바꾸지 못하지만 바뀐 값은 가져온다. int val3 = 5; const int *ptr3 = &amp;val3; int val4 = 6; ptr3 = &amp;val4; //이런것이 가능하다. //일반 변수의 const는 값을 바뀌지않게 하기위하여 사용하는데. //포인터의 int * 앞에 Const를 붙일때는 주소에 들어있는 값을 안바꾸겟다는 것이지. ptr의 주소값을 바꾸지않겟는다는것은 아니다. //포인터 자체가 상수인 경우 int val5 = 5; int *const ptr5 = &amp;val5; *ptr5 = 10; //값 변경 가능 cout &lt;&lt; *ptr &lt;&lt; endl; int val6 = 7; //ptr5 = &amp;val5; //int * 뒤에 const가 붙는경우에는 변수 값은 변경이 가능하지만, 주소값은 변경하지 못한다. int val7 = 7; const int *const ptr7 = &amp;val7; // ptr7 = &amp;val7;// *ptr7 = 10; //이런식으로 앞뒤로 const가 붙는경우 주소값, 변수값 둘다 변경이 불가능하게 된다. return 0;}참조변수 reference variable// 참조변수// reference variable#include &lt;iostream&gt;using namespace std;//void doSomething(int n)//{// n = 10;// cout &lt;&lt; \"in function : \" &lt;&lt; n &lt;&lt; endl;//}void doSomething(int &amp;n){ n = 10; cout &lt;&lt; \"in function : \" &lt;&lt; n &lt;&lt; endl; cout &lt;&lt; &amp;n &lt;&lt; endl; //참조 변수를 이용하는경우 주소가 같게 나온다. //포인터의 경우 변수의 주소를 복사해서 함수내의포인터 변수에 넣어서 가져오는것이고 //참조 변수의 경우 변수자체가 넘어온다. //이런것으로 인해 참조변수가 편하고 좋다. //퍼포먼스 차원에서 포인터 처럼 주소를 복사해서 가져올필요가없어서 좋다. 효율이 더 높다. //함수에서 변수 값을 변경하지 않기 위해서는 파라미터를 const로 교체하면된다.}//참조 변수의 경우 배열의크기가 지정이 되어야 사용가능하다.void printElement(int (&amp;arr)[5]){ for (int i = 0; i &lt; 5; ++i) { cout &lt;&lt; arr[i] &lt;&lt; \" \"; } cout &lt;&lt; endl;}struct Something{ int v1; float f1;}struct Other{ Something st;}int main() { //*을 붙여주는게귀찮을수도 있다. //포인터 변수보다 사용하기 편한것을 소개한다. int val = 5; //기본적인 포인터 변수사용 방법 int *ptr = &amp;val; //참조변수 사용방법 int &amp;ref = val; //내부적으로 ref가 val가 같은 메모리를 사용하는것처럼 작동한다. cout &lt;&lt; ref &lt;&lt; endl; ref = 10; //*ptr = 10; 와 같은 작업 cout &lt;&lt; val &lt;&lt; \", \" &lt;&lt; val &lt;&lt; endl; cout &lt;&lt; &amp;val &lt;&lt; \", \" &lt;&lt; &amp;ref &lt;&lt; \", \" &lt;&lt; ptr &lt;&lt; \", \" &lt;&lt; &amp;ptr &lt;&lt; endl; //포인터 주소와는 달리 원본의 주소와 같다고 출력이 된다. 주소를공유한다고 생각하자 /* int &amp;ref; int &amp;ref = 104; */ //참조변수는 무조건 초기화가 되어야한다. //리터럴도 불가능하다. int x = 5; int &amp;ref2 = x; /* const int y = 8; int &amp;ref = y; */ //ref에서 값이 변경이 가능하므로 허용하지않는 문법이다. const int y = 8; const int &amp;ref5 = y; //const는 const에 대입해줘야한다. int val2 = 5; int val3 = 10; int &amp;ref3 = val2; cout &lt;&lt; ref3 &lt;&lt; endl; ref3 = val3; cout &lt;&lt; ref3 &lt;&lt; endl; int n = 5; cout &lt;&lt; n &lt;&lt; endl; //5 doSomething(n); //10 cout &lt;&lt; n &lt;&lt; endl; //5 cout &lt;&lt; &amp;n &lt;&lt; endl; //참조변수를 이용하면 값이 10으로 출력이 된다. //배열 함수 사용 const int length = 5; int arr[length] = {1,2,3,4,5}; printElement(arr); //구조체에서의 참조변수 사용 Other ot; ot.st.v1 = 1.0; //기본적인 구조 int &amp;v1 = ot.st.v1; //이런식으로 참조가 가능하다 //이름이 짧아지는 장점이 생김 //포인터와 비교 int val10 = 5; int *const ptr10 = &amp;val10; int &amp;ref10 = val10; *ptr10 = 10; ref10 =10; //구조적으로 모두 같은 식이다. //레퍼런스도 내부적으로는 포인터로 구성되어있어서 그런것이다. return 0;}참조와 const// 참조와 const#include &lt;iostream&gt;using namespace std;void doSomething(const int&amp; x){ cout &lt;&lt; x &lt;&lt; endl;}int main() { //앞장에서 포인터와 const의 관계를 보앗으니 //참조와 const와의 관계를 알아보자 //참조는 좀더 간단하고 쉽게 사용가능하다. //함수의 파라미터로 사용할때 엄청 편해진다. int x = 5; int &amp;ref_x = x; const int &amp;ref2 = 4; //const ref에는 리터럴로 초기화가 가능하다. cout &lt;&lt; ref2 &lt;&lt; endl; cout &lt;&lt; &amp;ref2 &lt;&lt; endl; int a = 1; doSomething(a); doSomething(1); //함수의 파라미터가 const int&amp; 인 경우에는 값을 리터럴값으로 바로 넣어줄수있다. doSomething(a+1); //연산식도 가능 return 0;}포인터와 참조의 멤버 선택//포인터와 참조의 멤버 선택 연산자///Member Selection Operator#include &lt;iostream&gt;using namespace std;struct Person{ int age; double weight;}int main() { //포인터와 참조를 통해 구조체나 클래스의 멤버에 접근가능하다. //멤버 선택 연산자는 객체지향이나 멤버함수 클래스에서 유용하게 사용되는 연산자이다. Person ps; //앞에서 배운 멤버 접근방식 ps.age = 5; ps.weight = 30; //ref를 이용한 멤버 접근방식 Person &amp;ref = ps; ref.age = 5; ref.weight = 30; //포인터를 이용한 멤버 접근방식 Person *ptr = &amp;ps; ptr-&gt;age = 5; ptr-&gt;weight = 30; (*ptr).age = 5; (*ptr).weight = 30; //괄호 필수 *보다 .이 우선순위가 높아서 작동이 안됨 //ref에 포인터를 이용한 멤버 접근방식 Person &amp;ref2 = *ptr; ref2.age = 5; ref2.weight = 30; return 0;}for-each 반복문// for-each 반복문#include &lt;iostream&gt;#include &lt;limits&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main() { //C++ 11버젼 부터 사용가능한 for-each문 사용방법에 대해 알아보자 int fibonacci[] = {0,1,1,2,3,5,8,13,21,34,55,89}; //1. 사용법 output for(int number : fibonacci) cout &lt;&lt; number &lt;&lt; \" \"; cout &lt;&lt; endl; //3. 최댓값 구하기 int num_max = numeric_limits&lt;int&gt;::lowest(); for(const auto &amp;n : fibonacci) { num_max = max(num_max, n); } cout &lt;&lt; num_max &lt;&lt; endl; //2. change array values for(auto &amp;number : fibonacci) { number = 10; cout &lt;&lt; number &lt;&lt; \" \"; } //값을 바꾸기위해서는 참조를이용하여 사용한다. //보통 auto 키워드를 이용하여 자료형을 자동으로 결정하게 한다. //4. 동작할당을 하는경우 for-each문 사용 불가능 //대신에 벡터를 사용한다. //벡터 사용법 vector&lt;int&gt; fibonacci2 = {0,1,1,2,3,5,8,13,21,34,55,89}; return 0;}void 포인터// void 포인터#include &lt;iostream&gt;using namespace std;//void pointer, generic pointerint main() { //포인터의 길이는 운영체제의 길이에 고정되므로 자료형과 상관없이 포인터에 저장이 가능하다. int i = 5; float f = 3.0f; char c = 'a'; void *ptr = nullptr; ptr = &amp;i; ptr = &amp;f;// ptr = &amp;c; //void 포인터에 경우 모든 자료형이 대입이 가능하다. //하지만, 값이 무슨 자료형이 들어있는지는 모른다. int *ptr_i = &amp;i; cout &lt;&lt; ptr_i &lt;&lt; endl; cout &lt;&lt; ptr_i + 1 &lt;&lt; endl; // cout &lt;&lt; ptr + 1 &lt;&lt; endl; //void 포인터는 포인터 연산이 불가능하다. //자료형을 모르고있기 때문에 몇바이트가 증가해야하는지 모르기때문이다. cout &lt;&lt; &amp;f &lt;&lt; \" \" &lt;&lt; ptr &lt;&lt; endl; //주소는 잘 들어간다. // cout &lt;&lt; *ptr &lt;&lt; endl; //de-reference 사용불가. cout &lt;&lt; *static_cast&lt;float*&gt;(ptr) &lt;&lt; endl; //캐스팅을 사용하여 값을 출력가능하다. //이렇게 사용해야하는경우가 가끔가다 생긴다.. //포인터에 대한 내용중에 이런것도 있구나하고 파악만 해보면 좋을것같다. //나중에 현업에 들어가서 이런게 있었엇지 생각하고 그때 다시보면 되니까 return 0;}다중 포인터와 동적 다차원 배열//이중포인터와 동적 다차원 배열#include &lt;iostream&gt;using namespace std;int main() { //동적 할당을 동하여 다차원 배열을 사용하는 방법에 대해 알아보자! //이중 포인터에 대한 내용도 공부할것이다. //이중 포인터 = 포인터에 대한 포인터 int *ptr = nullptr; //이중 포인터 형식 int **ptrptr = nullptr; int val = 5; ptr = &amp;val; ptrptr = &amp;ptr; cout &lt;&lt; ptr &lt;&lt; \" \" &lt;&lt; *ptr &lt;&lt; \" \" &lt;&lt; &amp;ptr &lt;&lt; endl; //val의 주소, val의 값, ptr의 주소 cout &lt;&lt; ptrptr &lt;&lt; \" \" &lt;&lt; *ptrptr &lt;&lt; \" \" &lt;&lt; &amp;ptrptr &lt;&lt; endl; //ptr의 주소, ptr의 주소 = ptrtpr에 ptr의 주소를 넣었으니, 주소값이 de-reference가 된다. , ptrptr의 주소 cout &lt;&lt; **ptrptr &lt;&lt; endl; //val의 값 //*(*ptrptr) //삼,사중 포인터도 가능하다. = 다중포인터 int ***ptr3, ****ptr4; //이중포인터는 2차원 행렬 구현할떄 자주사용한다. const int row = 3; const int col = 5; const int s2da[row][col] = { {1,2,3,4,5}, {6,7,8,9,10}, {11,12,13,14,15}, }; //기존 방식 int *r1 = new int[col] {1,2,3,4,5}; int *r2 = new int[col] {6,7,8,9,10}; int *r3 = new int[col] {11,12,13,14,15}; //row가 많은경우 일일히 할당 해주기 힘드므로 //그냥 포인터의 배열을 만들면 int **rows = new int*[row] {r1,r2,r3}; for (int r= 0; r &lt; row; ++r) { for (int c = 0; c &lt; col; ++c) { cout &lt;&lt; rows[r][c] &lt;&lt; \" \"; } cout &lt;&lt; endl; } //delete delete [] r1; delete [] r2; delete [] r3; delete [] rows; //위의 delete방식은 너무 귀찮다 딱보기만 해도 진저리가 나는거같다. 싶은경우 //delete를 for문으로 반복해서 하고싶은경우 //이중 포인터를 먼저 초기화하고 포인터 row1,2,3을초기화하고 rows에 넣어주어야한다. int **matrix = new int*[row]; //이중 포인터를 먼저 초기화 하고 for (int r= 0; r &lt; row; ++r) { matrix[r] = new int[col]; } //포인터 배열에 넣어줄 포인터를 초기화 한다. for (int r= 0; r &lt; row; ++r) for (int c = 0; c &lt; col; ++c) matrix[r][c] = s2da[r][c]; //포인터에 값을 넣어주는작업 for (int r= 0; r &lt; row; ++r) { for (int c = 0; c &lt; col; ++c) { cout &lt;&lt; matrix[r][c] &lt;&lt; \" \"; } cout &lt;&lt; endl; } //값을 출력하는 작업 //한번에 delete하는 방법 for (int r= 0; r &lt; row; ++r) { delete[] matrix[r]; } delete[] matrix; //이중포인터를 사용하지않는 방법 int *matrix2 = new int[row*col]; for (int r= 0; r &lt; row; ++r) for (int c = 0; c &lt; col; ++c) matrix2[c + col*r] = s2da[r][c]; //한번 생각해보자 왜 matrix2의 인덱스값이 c + col*r로 작동을 해야하는지 for (int r= 0; r &lt; row; ++r) { for (int c = 0; c &lt; col; ++c) { cout &lt;&lt; matrix2[c + col*r] &lt;&lt; \" \"; } cout &lt;&lt; endl; } delete[] matrix2; return 0;}std::array 소개//std::arrary 소개#include &lt;iostream&gt;#include &lt;array&gt;#include &lt;algorithm&gt;using namespace std;void printLength(array&lt;int, 5&gt; arr){ cout &lt;&lt; arr.size() &lt;&lt; endl;}int main() { //arrary 키워드를 배워보자! int arr1[5] = {1,2,3,4,5}; array&lt;int, 5&gt; arr2 = {1,2,3,4,5}; //두개가 똑같이 작동하는 코드이다. //크기를 지정해서 사용한다. arr2 = {0,1,2,3,4}; arr2 = {0,1,2,3}; cout &lt;&lt; arr2[0] &lt;&lt; endl; cout &lt;&lt; arr2.at(0) &lt;&lt; endl; //at은 미리 안의 숫자를 체크해보고 문제가 발생하는경우 예외처리를 시켜준다. //at이 조금 느리다. cout &lt;&lt; arr2.size() &lt;&lt; endl; //array의 크기 가져오는방법 //함수 파라미터로 사용할수도있다. printLength(arr2); array&lt;int, 5&gt; arr3 = {1, 21, 3, 40, 5}; for (auto element: arr3) { cout &lt;&lt; element &lt;&lt; \" \"; } cout &lt;&lt; endl; //정렬 사용가능 //algorithm 라이브러이에 sort를사용하면 된다. sort(arr3.begin(), arr3.end()); for (auto element: arr3) { cout &lt;&lt; element &lt;&lt; \" \"; } cout &lt;&lt; endl; //역순정렬 sort(arr3.rbegin(), arr3.rend()); for (auto element: arr3) { cout &lt;&lt; element &lt;&lt; \" \"; } cout &lt;&lt; endl; return 0;}정적 배열이다.std::vector 소개//std::vetor 소개 #include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() { //동적 배열에 해당하는 부분이다. //동적 배열보다 사용하기 편하다. //동적할당이 되는것이라 사이즈는 array처럼 사이즈를 지정해줄 필요가 없다. std::vector&lt;int&gt; arr; //std를 사용하면 생략가능 vector&lt;int&gt; arr2 = {1,2,3,4,5}; cout &lt;&lt; arr2.size() &lt;&lt; endl; vector&lt;int&gt; arr3 = {1,2,3}; cout &lt;&lt; arr3.size() &lt;&lt; endl; vector&lt;int&gt; arr4{1,2,3,4,5,6}; cout &lt;&lt; arr4.size() &lt;&lt; endl; //사이즈 수시로 변경 가능 vector&lt;int&gt; arr5 = {1,2,3,4,5}; for(auto &amp;itr : arr5) { cout &lt;&lt; itr &lt;&lt; \" \"; } cout &lt;&lt; endl; cout &lt;&lt; arr5[1] &lt;&lt; endl; cout &lt;&lt; arr5.at(1) &lt;&lt; endl; //array와 마찬가지로 at 키워드가 사용 가능하다. //vector의 장점 = 동정할당이지만, 메모리를 알아서 지워준다. new delete가 필요가 없다. //블록을 벗어나는경우 자동으로 제거된다. //resize 방법 arr5.resize(10); for(auto &amp;itr : arr5) { cout &lt;&lt; itr &lt;&lt; \" \"; } //크기가 커진경우 = 추가된 크기만큼 0값이 추가가 된다. //크기가 작아진경우 = 작아진 만큼만 출력한다. return 0;}동적 배열이다." }, { "title": "[C++] Chapter.5 흐름제어", "url": "/posts/Cpp-Ch5/", "categories": "Language, C++", "tags": "c++", "date": "2022-09-08 22:20:19 +0900", "snippet": "제어 흐름 개요 Control flow// 제어 흐름 개요// Control flow#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;int main() { //프로그래밍은 CPU에게 할일을지정해주는것 //순서도 //Flow Chart //흐름제어 종류 /* 중단 Halt 점프 Jump - goto, break, continue 조건 분기 Conditional branches - if, switch 반복 Loops - while, do while, for 예외처리 Exceptions - try, catch, throw */ //중단 cout &lt;&lt; \"Test 1\" &lt;&lt; endl; //중단 방법1 return 0; //중단 방법2 //cstdlib library 필요 exit(0); //retur보다 긴급한 상황 //자료 반환형에 상관없이 코드에 어디에 있든지 종료가 가능하다. //코드파악할때 주로 사용 //실제 프로그램에는 잘 안들어가고 테스트 할때 특정 작동 범위만 보고싶을때 중단점을 잡아두고 실행을 해보는식으로 사용한다. //나머지 아래 코드들은 지워도 되지만, 지우면 안되는경우가 발생할수도있다. //주석으로 여기는 왜 안사용하는지 이유를 적어서 표시를해놓는다. cout &lt;&lt; \"Test 2\" &lt;&lt; endl; return 0;}조건문 if// 조건문 if#include &lt;iostream&gt;using namespace std;int min(int x, int y){ if(x &gt; y) return y; else return x; // return (x &gt; y) ? y : x;}int main() { //사용방법 /* if(bool) { 처리 내용 } */ //예시 int x; cin &gt;&gt; x; if(x &gt; 10) //true { cout &lt;&lt; x &lt;&lt; \" is greater than 10\" &lt;&lt; endl; } else //flase cout &lt;&lt; x &lt;&lt; \" is not greater than 10\" &lt;&lt; endl; //내용이 한줄이면 {} 생략 가능 if(1) int y = 5; else int y = 6; //if 안에 변수를 만들면 if문 안에서만 작동을 한다. // cout &lt;&lt; y &lt;&lt; endl; //y를찾지못한다는 오류 발생 //chaining if(x &gt; 10) cout &lt;&lt; \"x is greate than 10\" &lt;&lt; endl; else if(x &lt; 10) cout &lt;&lt; \"x is less than 10\" &lt;&lt; endl; else cout &lt;&lt; \"x is 10\" &lt;&lt; endl; if(x &gt; 10) cout &lt;&lt; \"x is greate than 10\" &lt;&lt; endl; else { if(x &lt; 10) cout &lt;&lt; \"x is less than 10\" &lt;&lt; endl; else cout &lt;&lt; \"x is 10\" &lt;&lt; endl; } //이런식으로도 사용가능하다. //if의 깊이가 깊어지면 안좋다. 코드를 파악하기도 힘들고 간단한 코드가 아니라면 깊이를 깊지않게 만드는게 좋다. //논리연산자 사용 int y; cin &gt;&gt; y; if(x == y) cout &lt;&lt; \"equal numbers\" &lt;&lt; endl; else cout &lt;&lt; \"not equal numbers\" &lt;&lt; endl; if(x &gt; 0 &amp;&amp; y &gt; 0) //둘다 양수일때 cout &lt;&lt; \"both numbers are positive\" &lt;&lt; endl; else if(x &gt; 0 || y &gt; 0) //둘중 하나만 양수일때 cout &lt;&lt; \"one of the numbers are positive\" &lt;&lt; endl; else //둘다 음수일떄 cout &lt;&lt; \"both numbers are negative\" &lt;&lt; endl; //많이 사용해보면 익숙해진다. //분기문을 이용하여 프로그램 종료가능 int a; cin &gt;&gt; a; if(a &gt; 10) cout &lt;&lt; \"A\" &lt;&lt; endl; else if(x == -1) return 0; //exit(0) else if(x &lt; 0) cout &lt;&lt; \"B\" &lt;&lt; endl; cout &lt;&lt; \"Hello\" &lt;&lt; endl; //null statment if(x &gt; 10) { }; //if에 아무것도 작성하지않은것 //오타 조심해야할것 if(x = 0) //x=0; if(x) 로 실행이 된다. cout &lt;&lt; x &lt;&lt; endl; //x에 0이 들어가게되고 ture처리가 된다. cout &lt;&lt; x &lt;&lt; endl;}switch-case// switch-case#include &lt;iostream&gt;using namespace std;enum class Colors{ BLACK, WHITE, RED, GREEN, BLUE};void printColor(Colors col){ //if문 방식// if(col == Colors::BLACK)// cout &lt;&lt; \"Black\" &lt;&lt; endl;// else if(col == Colors::WHITE)// cout &lt;&lt; \"Whith\" &lt;&lt; endl;// else if(col == Colors::RED)// cout &lt;&lt; \"Red\" &lt;&lt; endl; //switch-case switch (col) { case Colors::BLACK: cout &lt;&lt; \"BLACK\" &lt;&lt; endl; break; case Colors::RED: cout &lt;&lt; \"RED\" &lt;&lt; endl; break; case Colors::GREEN: cout &lt;&lt; \"GREEN\" &lt;&lt; endl; break; case Colors::BLUE: cout &lt;&lt; \"BLUE\" &lt;&lt; endl; break; case Colors::WHITE: cout &lt;&lt; \"WHITE\" &lt;&lt; endl; break; } //static_cast로 int로 바꿔서도 사용할수있다.}int main() { //if처럼 조건문이다. //특별한 경우 사용되며 깔끔하게 처리가능 int x; cin &gt;&gt; x; //숫자별 출력 예시 switch (x) { case 0: cout &lt;&lt; \"Zero\"; case 1: cout &lt;&lt; \"One\"; case 2: cout &lt;&lt; \"Two\"; } cout &lt;&lt; endl; //0일때 012 다출력 //1일때 12 출력 //2일때 2 출력 //case진행하면서 다 출력이 된다. //원하는 방식 switch (x) { case 0: cout &lt;&lt; \"Zero\"; break; case 1: cout &lt;&lt; \"One\"; break; case 2: cout &lt;&lt; \"Two\"; break; } cout &lt;&lt; endl; //break를 만나는순간 switch빠져나온다. //선택이 된 부분부터 아래 끝 case까지 모두 출력하고 swicth문이 종료가 된다. //break를 의도적으로 사용가능 //색상 출력 방법 enum사용 printColor(Colors::BLACK); //주의사항 switch (x) { int a; //선언은가능// int b = 5; //초기화는 불가능 //Cannot jump from switch statement to this case label 오류발생 //선언만 해주고 case에서 대입을 해주어야한다. case 0: { int b; b = 5; cout &lt;&lt; a &lt;&lt; endl; break; } case 1: int b; cout &lt;&lt; b &lt;&lt; endl; //쓰레기값 발생 } //변수를 사용할거면 굳이 switch문 밖에 선언하는것이 사용하기 편하고 오류발생확률을 줄일수있다. //default //case에 없는것 조건들 출력 }goto// goto#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main() { //goto //코드이동코드 //지점 설정 //label tryAgin: //label double x; cout &lt;&lt; \"Enter a non-negative number\" &lt;&lt; endl; cin &gt;&gt; x; if(x &lt; 0.0) goto tryAgin; cout &lt;&lt; sqrt(x) &lt;&lt; endl; //goto //반복문이 나오고 사용하지않느다. 예전에나 많이썻지 //좀더 계획적으로 구조를 짜서 사용할땐 좋아보인다. //스파게티코드가 된다.. 라고 말들이 많다.}반복문 while// 반복문 while#include &lt;iostream&gt;using namespace std;int main() { //반복문으로 for문을 더 많이 사용하지만 while을 사용해야하는 경우가 있다. //이전의 숫자 출력 반복작업// cout &lt;&lt; 1 &lt;&lt; endl;// cout &lt;&lt; 2 &lt;&lt; endl; //사용방법 /* while(조건) { ... } 조건이 ture일때 */ //반복 횟수 count variabel int count = 0; while(count &lt; 10) { cout &lt;&lt; count &lt;&lt; endl; count++; } //for문 //count 변수 //조건 //합쳐진것 //무한루프 /* while(true) { ... } or while(1) { ... } 게임, 인터넷서비스, 서버쪽에서 사용할때 무한루프를 사용하는경우가있다. */ //무한루프 탈출방법 count = 0; while(1) { cout &lt;&lt; count &lt;&lt; endl; count++; //조건으로 무한루프 탈출가능 if(count == 10) break; } //문제 발생 예제 // unsigned int cnt = 10;//// while (cnt &gt;= 0) {// if (cnt == 0)// cout &lt;&lt; cnt &lt;&lt; endl;// else// cout &lt;&lt; cnt &lt;&lt; endl;//// cnt--;// } //무한루프 발생 //unsigned를 조건으로 하게되면 오버플로우가 발생하여 무한루프가 발생한다. //unsigned계산이 signed보다 빠를수있다고 한다. //최적화할때 사용하기도 한다. //벡터 사이즈가 unsigned를 반환을 해준다. //unsigned를 사용하면 안된다 라는게 아니고 조심해서 잘사용하자! 라는말이다. //이중 반복문 int outter_cnt = 1; while (outter_cnt &lt;= 5) { int inner_cnt = 1; while (inner_cnt &lt;= outter_cnt) { cout &lt;&lt; inner_cnt++ &lt;&lt; \" \"; } cout &lt;&lt; endl; ++outter_cnt; } //1 //1 2 //1 2 3 //1 2 3 4 //1 2 3 4 5 //별찍기 문제를 풀어보는게 좋다.}반복문 do-while// do-while#include &lt;iostream&gt;using namespace std;int main() { //do-while / while의 차이 //while //0번 실행가능 //do-while //무조건 반복 1번은 최소실행 //반드시 한번을 실행해야하는경우 사용한다. int selection; //do내부에 선언하게 되면 while에서 접근 불가 do { cout &lt;&lt; \"1. add\" &lt;&lt; endl; cout &lt;&lt; \"2. sub\" &lt;&lt; endl; cout &lt;&lt; \"3. mult\" &lt;&lt; endl; cout &lt;&lt; \"4. div\" &lt;&lt; endl; cin &gt;&gt; selection; } while (selection &lt;= 0 || selection &gt;=5); cout &lt;&lt; \"You selected : \" &lt;&lt; selection &lt;&lt; endl;}반복문 for// 반복문 for#include &lt;iostream&gt;using namespace std;//제곱 함수 구현가능int pow(int base, int exponent){ int result = 1; for (int count = 0; count&lt; exponent; ++count) { result *= base; } return result;}int main() { //셋다 기간을 의미한다. //do-while 반드시한번실행 - //while - 무한루프에 많이사용한다. //for - 반복횟수(숫자)가 딱 정해진경우 /* for (int count = 0; count &lt; 10; count++) //iteration - 반복성 { cout &lt;&lt; count &lt;&lt; endl; //0123456789 출력 //첫번쨰 ; //int count = 0 //횟수 변수 선언 및 정의 //두번째 ; //count &lt; 10 //반복 조건 //마지막 //count++ // 횟수 변수 증감 / 증감외의 다른 연산도 넣기도함 } */ int count = 0; for (; count &lt; 10; count++) //iteration - 반복성 { cout &lt;&lt; count &lt;&lt; endl; //0123456789 출력 //for문 밖에서 count를계속 사용하고싶은경우 이렇게 사용가능하다. //첫번쨰 ; 에 아무값을안넣어도 작동한다. } /* 무한루프 사용법 while(true) for(;true;) { } for(;;) { } 세가지 조건 다 안넣어도 작동한다. count = 0; for (; ; ) { count++; cout &lt;&lt; count &lt;&lt; endl; if(count == 10) break; } */ cout &lt;&lt; pow(2, 4) &lt;&lt;endl; //16출력 //감소 구현 for (int cnt = 9; cnt &gt;= 0; cnt--) { cout &lt;&lt; cnt &lt;&lt; endl; } for (int cnt = 9; cnt &gt;= 0; cnt -= 2) { cout &lt;&lt; cnt &lt;&lt; endl; } //while처럼 unsigned로 감소 구현시 오류 발생 //원인은?? 알아서 생각해보는게 좋을듯 //변수 2개 사용 for (int i = 0, j=0; i &lt; 10; ++i, j--) { cout &lt;&lt; \"i : \" &lt;&lt; i &lt;&lt; \", \" &lt;&lt; \"j : \" &lt;&lt; j &lt;&lt; endl; } /* i : 0, j : 0 i : 1, j : -1 i : 2, j : -2 i : 3, j : -3 i : 4, j : -4 i : 5, j : -5 i : 6, j : -6 i : 7, j : -7 i : 8, j : -8 i : 9, j : -9 */ //이중 for문 int cnt = 0; for (int i = 0; i &lt; 10; i++) { for (int j =0; j &lt; 10; j++) { cnt++; } } cout &lt;&lt; cnt &lt;&lt; endl; //이중 포문은 i * j 번 작동한다는것을 알수있다. //구구단 출력 한번 해볼것!}break, switch// break, continue#include &lt;iostream&gt;using namespace std;void BreakOrReturn(){ while (true) { char ch; cin &gt;&gt; ch; if(ch == 'b') break; //while 탈출 if (ch == 'r') { return; //함수 탈출 } } cout &lt;&lt; \"Hello!\" &lt;&lt; endl;} int main() { //반복문에서 제어하기 위한 연산자 //switch에서 본적이있다. // int count = 0;// while (true) {// cout &lt;&lt; count &lt;&lt; endl;// if (count == 10) break;// count++;// //break를 만나면 현재 블록을빠져나온다.// //while 종료// } // BreakOrReturn();//// for (int i = 0 ; i &lt; 10; ++i) {// cout &lt;&lt; i &lt;&lt; endl;// if(i == 5) break;// //for문 종료// } //continue// for (int i = 0; i &lt; 10; ++i) {// //짝수만 출력 방법1// if(i % 2 == 0) cout &lt;&lt; i &lt;&lt; endl;//// //방법2 continue 사용// if(i % 2 != 0) continue;// //continue를 만나면 아랫부분을 뛰어넘고 마지막 조건인 ++i을 실행하고 이어서 반복을실행한다.// cout &lt;&lt; i &lt;&lt; endl;//// } //// int count(0);//// do {// if(count == 5)// continue;//// cout &lt;&lt; count &lt;&lt; endl;// } while (++count &lt; 10);////// //while안에 증감연산자를사용하는경우// //contine 사용시 이상하게 작동할수있다.// count = 0;// do {// if(count == 5)// continue;//// cout &lt;&lt; count &lt;&lt; endl;// count++;// } while (count &lt; 10);// //4에서 안넘어간다. 무한루프 발생// //dowhile문애소 continue를 사용하면 의도치않게 무한루프가 발생할수있다. //break를 사용하는게 조건걸어주는것보다 편할수있는예제 int count(0); //특정키 입력시 탈출 // while(true)// {// //반복문 사용시 반복문안에 변수를선언하게 되는경우 느려질수있다.// //복잡한 변수(클래스, 객체변수)를 선언하게 되면 느려질수있어서 while문에서 사용할 변수는 while문 밖에 선언/정의 하는것이 좋다.// char ch;// cin &gt;&gt; ch;//// bool escape_flag = false;//// cout &lt;&lt;\"input value : \"&lt;&lt; ch &lt;&lt; \", \" &lt;&lt;\"loop count : \" &lt;&lt; count++ &lt;&lt; endl;//// if (ch == 'x') {// escape_flag = true;// }// } /* bool escape_flag = false; //while안에 bool변수를 이용하여 조건 사용가능 while(!escape_flag) { //반복문 사용시 반복문안에 변수를선언하게 되는경우 느려질수있다. //복잡한 변수(클래스, 객체변수)를 선언하게 되면 느려질수있어서 while문에서 사용할 변수는 while문 밖에 선언/정의 하는것이 좋다. char ch; cin &gt;&gt; ch; cout &lt;&lt;\"input value : \"&lt;&lt; ch &lt;&lt; \", \" &lt;&lt;\"loop count : \" &lt;&lt; count++ &lt;&lt; endl; if (ch == 'x') { escape_flag = true; } } */ //escape_flag없이 break를이용하여 조건 탈출 만들기 while(true) { char ch; cin &gt;&gt; ch; cout &lt;&lt;\"input value : \"&lt;&lt; ch &lt;&lt; \", \" &lt;&lt;\"loop count : \" &lt;&lt; count++ &lt;&lt; endl; if (ch == 'x') { cout &lt;&lt; \"exit\" &lt;&lt; endl; break; } } //많이 사용하는 연산자이다. //switch, 반복문에서 많이 사용되니 많이 사용해보면 익숙해진다.}난수#include &lt;iostream&gt;using namespace std;//랜덤 숫자 생성 원리 설명 코드unsigned int PRNG(){ static unsigned int seed = 5523; //seed number //시작하는 숫자 seed = 8253729 * seed + 2396403; return seed % 32768;}int main() { //게임에서 난수를 이용하여 변칙스러운 행동을 만들기 위하여 사용한다. //컴퓨터는 스스로 난수를 만들순없다. //계산만 가능 //유사 난수를 만든다. c스타일#include &lt;iostream&gt;#include &lt;cstdlib&gt;//radn(), srand()를 이용하여 난수 사용#include &lt;ctime&gt;//time()using namespace std;//특정한 숫자 범위 난수 생성int getRandomNumber(int min, int max){ //난수중 가장큰 숫자 static const double fraction = 1.0 / (RAND_MAX + 1.0); return min + static_cast&lt;int&gt;((max-min+1) * (rand() * fraction));}int main() { //게임에서 난수를 이용하여 변칙스러운 행동을 만들기 위하여 사용한다. //컴퓨터는 스스로 난수를 만들순없다. //계산만 가능 //유사 난수를 만든다. //seed num 설정// srand(5323); //디버깅 할때 seed를 고정해서 실행해야지 같은 값으로 출력이 되어 버그를 찾기가 쉬워진다. //난수 디버그할때는 고정하여 사용하여야한다. //현재 시간을 이용하여 seed 숫자를 계속 변경 srand(static_cast&lt;unsigned int&gt;(std::time(0))); // for (int cnt = 1; cnt &lt;= 1000; ++cnt) {//// //seed없이 사용가능// cout &lt;&lt; rand() &lt;&lt; \"\\t\";//// if (cnt % 5 == 0) {// cout &lt;&lt; endl;// }// } //seed가 고정되어있으면 다른숫자 생성불가 난수가 고정되어 생성된다. // for (int cnt = 1; cnt &lt;= 1000; ++cnt) {//// //seed없이 사용가능// cout &lt;&lt; getRandomNumber(1, 2) &lt;&lt; \"\\t\";//// if (cnt % 5 == 0) {// cout &lt;&lt; endl;// }// } for (int cnt = 1; cnt &lt;= 1000; ++cnt) { //seed없이 사용가능 //1부터 10까지 랜덤 변수 만들기 cout &lt;&lt; rand() % 10 + 1 &lt;&lt; \"\\t\"; if (cnt % 5 == 0) cout &lt;&lt; endl; } //숫자범위가 작은경우 사용가능 //숫자 범위가 커지는 경우 난수가 특정 숫자로 몰리는 경우가 발생한다. //정밀성이 떨어진다.cpp random library (ver.cpp11)#include &lt;iostream&gt;#include &lt;random&gt;//cpp11부터 사용가능using namespace std;int main(){ //bust에서 사용하던걸 가져온것이라고함 //srand를사용할때 seed에 변동을 주기위하여 시간으로 사용한것이 //random _device와 같다. random_device rd; //난수 알고리즘과 관련된 변수 //난수 생성기 //32bit mt19937 mersenne(rd()); //create a mesenne twister , time()을 사용한것과 유사한 현상발생 //64bit mt19937_64 ss2; //난수 분포 설정 uniform_int_distribution&lt;&gt; dice(1,6); //1이상 6이하 숫자생성 확률이 모두 동일 for (int cnt = 1; cnt &lt;= 20; cnt++) { cout &lt;&lt; dice(mersenne) &lt;&lt; endl; }}std::cin 더 잘쓰기// std::cin 더 잘 쓰기// ignore(), clear(), fail()#include &lt;iostream&gt;using namespace std;int getInt(){ cout &lt;&lt; \"Enter a integer number : \"; int x; cin &gt;&gt; x; return x;}char getOperator(){ cout &lt;&lt; \"Enter an operator(+, -) : \"; char op; cin &gt;&gt; op; }void printResult(int x, char op, int y){ //case - switch문으로 변경 해보자 곱셈 나눗세몯 포함 시켜서 만들어보자! if(op == '+') cout &lt;&lt; \"result : \" &lt;&lt; x + y &lt;&lt; endl; else if(op == '-') cout &lt;&lt; \"result : \" &lt;&lt; x - y &lt;&lt; endl; else cout &lt;&lt; \"Invalid operator\" &lt;&lt; endl; }int main() { //cin : console 입력 //의도하지 입력이 들어오는경우 대응방법 설명 int x = getInt(); char op = getOperator(); int y = getInt(); printResult(x, op, y); return 0;}//문제점 숫자 두개를한번에 입력하는경우 앞장에서 말한 첫마디만 입력이되고 나머지 입력은버퍼에 쌓여서 버퍼에쌓여있는 데이터들이 다음 cin을만나면 바로 입력이 되는현상이 발생//미리 저장되어있고 하나씩 꺼내 사용하는방식으로 진행이 된다.오류 발생 보수작업 코드#include &lt;iostream&gt;using namespace std;int getInt(){ while(true) { cout &lt;&lt; \"Enter a integer number : \"; int x; cin &gt;&gt; x; //입력 실패 유무 확인 함수 //cin.fail(); if(cin.fail()) { //입력 초기화 cin.clear(); //버퍼 비우기 std::cin.ignore(32767, '\\n'); cout &lt;&lt; \"Invalid number, Please Try Again\" &lt;&lt; endl; } else { //버퍼를 비워주는 행동 std::cin.ignore(32767, '\\n'); return x; } }}char getOperator(){ while(true) { cout &lt;&lt; \"Enter an operator(+, -) : \"; char op; cin &gt;&gt; op; //버퍼를 비워주는 행동 std::cin.ignore(32767, '\\n'); if(op == '+' | op == '-') return op; else cout &lt;&lt; \"Invalid operator, Please Try again\" &lt;&lt; endl; } }void printResult(int x, char op, int y){ //case - switch문으로 변경 해보자 곱셈 나눗세몯 포함 시켜서 만들어보자! if(op == '+') cout &lt;&lt; \"result : \" &lt;&lt; x + y &lt;&lt; endl; else if(op == '-') cout &lt;&lt; \"result : \" &lt;&lt; x - y &lt;&lt; endl; else cout &lt;&lt; \"Invalid operator\" &lt;&lt; endl; }int main() { //cin : console 입력 //의도하지 입력이 들어오는경우 대응방법 설명 int x = getInt(); char op = getOperator(); int y = getInt(); printResult(x, op, y); return 0;}//문제점 숫자 두개를한번에 입력하는경우 앞장에서 말한 첫마디만 입력이되고 나머지 입력은버퍼에 쌓여서 버퍼에쌓여있는 데이터들이 다음 cin을만나면 바로 입력이 되는현상이 발생//미리 저장되어있고 하나씩 꺼내 사용하는방식으로 진행이 된다." }, { "title": "[C++] Chapter.4 변수범위와 더 다양한 변수형", "url": "/posts/Cpp-Ch4/", "categories": "Language, C++", "tags": "c++", "date": "2022-09-03 21:39:12 +0900", "snippet": "지역 변수, 범위, 지속시간// 지역 변수의 범위와 지속시간// Scope / Duration#include &lt;iostream&gt;using namespace std;//같은변수여서 충돌이 난다.//int a = 1;////int a = 1;//함수 선언 정의분리가능//선언은 여러곳 가능 정의는 한번만 가능//함수중 이름은 같은데 파라미터가 다른경우에는 충돌이일어나지않는다.//충돌을 막기위하여 네임스페이스를 사용하여 분리를 해준다.namespace work1{ int a = 1;}namespace work2{ int a = 3;}//네임스페이스안에 네임스페이스를 또 만들수 있다.//네스티드 영역은 되도록이면 적게사용하는것이 좋다.namespace work3::work33::work333{ int a = 3;}int main() { //블록 명칭공간,이름충돌, 이름숨기기 //범위 Scope 눈으로 볼수았는 범위 뉘앙스 //어디서 내가 변수를 사용할수있는가 볼수있다 //지속기간 메모리에 얼마나 사용할수있는가 //동적 할당 사용시 &gt;&gt; 지역, 지속기간 분리가 된다. //apple = 1; //변수가 선언전이라 안되어있어서 사용불가 //변수 선언 int apple = 5; cout &lt;&lt; apple &lt;&lt; endl; //5 //블록 지정 { //블록 밖에서 선언한변수는블록 안에서도 사용가능하다. apple = 1; cout &lt;&lt; apple &lt;&lt; endl; //1 //이 apple은 다른 apple이다. //더 작은 영역안에같은변수가 있는경우 밖의 apple은 숨겨진다. hiding //블록간의 이름은분리하는게 좋다. 헷갈린다. 보기 안좋다. int apple = 6; cout &lt;&lt; apple &lt;&lt; endl; //6 } cout &lt;&lt; apple &lt;&lt; endl; //1 apple = 1; //:: 영역/범위 결정 연산자 스코프 레졸루션? 오퍼레이터 work1::a; work2::a;}//메모리 반납 후//apple = 3;//변수선언된 범위가 아니여서 사용불가전역 변수, 정적 변수, 내부 연결, 외부 연결// 전역 변수, 정적 변수, 내부 연결, 외부 연결// Global Static Internal External#include &lt;iostream&gt;#include \"Constants.h\"using namespace std;//forward declaration//컴파일러가 main.cpp를 컴파일할때 어딘가에 함수가 정의가 되어있으니 링킹할때 그걸 사용하면 된다.라고 알려주는 길라잡이 역할을 한다.void doSomething_t();//(extern) void doSomething_t(); extern이 생략 된것이다.extern int b;extern int b_;//extern int b_2 = 456;//외부변수 선언//전역변수int value = 123;int global_a = 1;//정적변수 지속변수void doSomething(){ //정적변수 선언 static int a = 1; ++a; ++global_a; cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; global_a &lt;&lt; endl; //static global 차이 //static 변수는 os로부터받은 메모리가 static이다. //동적 할당 배우면서 정확하게 알게 된다. //지역변수, 전역변수(일반 변수들)는 메모리 활동이 블록을 벗어나면 메모리를 반납햇다가 다시 선언하게 되면 다시 할당됫다 한다. //정적변수는 메모리가 고정으로 잡혀있는것이다. 블록을 벗어나고 다시 블록에 접근하여 사용할때 메모리를 다시할당하는것이아니라 원래 메모리주소를 사용한다. //정적변수는 초기화를하지않으면 사용하지 못한다. //메모리 관점에서 보면 이해가 쉬워진다. }int main() { //블록 내에서만작용 하는 변수 = 지역변수 //어디서든 사용 가능한 변수 = 전역변수 //편한것처럼 보이지만 //가급적 사용을 하지 말아야 한다. //그렇지만, 여러가지 이유로 부득이하게 사용하게 된다. //지역변수의 경우 링키지가 없다. //특정 파일 내에선 어디서든 사용가능한 연결 = 내부연결 //파일내에 선언한 변수를 다른 파일에서 사용하는 연결 = 외부연결 //전역변수 123 출력 cout &lt;&lt; value &lt;&lt; endl; //전역변수 123 출력 //지역변수 블록 벗어나면 사용, 접근 불가 int value = 1; cout &lt;&lt; value &lt;&lt; endl; //지역변수 1 출력 //golbal scope operator사용하여 전역변수 사용가능 cout &lt;&lt; ::value &lt;&lt; endl; //전역 변수 123 출력 //전역변수 사용할때의 위험성 예시 //전역변수 사용하고 다른 파일에서 사용하는 경우 어디서 사용하는지 관리하기가 힘들어진다. //대안방법1 //전역 변수 사용시 설계를 유의하여 사용한다. //전역변수인지 아닌지 명확하게 사용을 한다. ex)함수의 파라미터를 사용할때 //대안방법2 //글로별 변수는 변수명에 구분을 두어 명확하게 사용하는것이다. //지역변수 a =&gt; int a; //전역변수 a =&gt; global_a; //대안방법3 //객체지향을 배우고 객체지향을 사용하고 전역변수를 사용하지 않는것이다. doSomething(); //2 출력 doSomething(); //3 출력 일반변수 사용시 2로 출력 //링킹 =&gt; 연결 시켜주는? cpp파일들을 연결하여 obj를 묶어주는? //지역변수는 링키지가 없다. //다른 파일이랑 연결 될일이 없기때문에 없다. //내부연결 //개별 cpp파일 안에서만 전역으로 작동하는 전역변수를 의미한다. //cpp안에서 모든곳에서 사용가능하다. //static 전역변수는 다른 cpp파일에서 접근이 불가능하다. //static은 문법상 다른 cpp파일에서 사용할 수 없도록 막아주는 역할을 한다. //외부연결 //test.cpp에서 외부 함수를 쓰려고할때 include하여 접근 할수있다. 가급적 사용하진 않지만.. //extern을 사용하여 사용이 가능하다. //링키지 =&gt; 연결 그 자체? //test.cpp에서 외부변수 초기화가 안되어있는 경우 실행하면 오류발생 //링킹에러 발생// cout &lt;&lt; b &lt;&lt; endl; //test.cpp에서 초기화하면 출력이 잘됨 cout &lt;&lt; b_ &lt;&lt; endl; //초기화를 두번해주면 오류가 발생한다. //이유 : extern 변수를 선언하고 초기화를 두번하게 되면 컴파일러 입장에서는 프로그램 전체에서 같은 변수가 2번 초기화가 된것이므로 충돌이 발생한것이다.// cout &lt;&lt; b_2 &lt;&lt; endl; // cout &lt;&lt; \"main.cpp : \" &lt;&lt; Constants::pi &lt;&lt; endl; cout &lt;&lt; \"pi address of main.cpp : \" &lt;&lt; &amp;Constants::pi &lt;&lt; endl; doSomething_t(); //같은 파일의 변수를 다른파일에서 사용하면서 주소를 출력해보면 다르게 나온다. //게임 코딩의 경우 이렇게 변수를 100~1000개 사용하면 메모리가 100~1000개의 사본이 생긴셈이다. //전역변수가 100~1000개 생기면 메모리 낭비가 예상치 못하게 커질수있다. //방지하는 방법 //cpp파일을만들어서 초기화를해주고 헤더에서 선언만 하여 사용해준다. /* 정리 int g_x; // external linkage static int g_x; //internal linkage const int g_x; (x)사용 불가 초기화를 해주어야 한다. //초기화를 안해줘도 되지만 어느 한곳에서는 초기화가 되어있어야한다. extern int g_z; //초기화를 안해줘도 되지만 어느 한곳에서는 초기화가 되어있어야한다. extern const int g_z; int g_y(1); 변수 초기화 static int g_y(1); 외부에서 접근 불가능한 변수 초기화 const int g_y(1); 같은 파일 안에서만 사용하는 상수 extern int g_w(1); 외부접근가능한 변수 초기화 &lt;&lt; 다른곳에서 사용할땐 초기화 진행하면 안된다. extern const int g_w(1); 외부접근 가능한 상수 초기화 */}test.h```cpp#include &lt;iostream&gt;#include \"Constants.h\"using namespace std;extern int b;extern int b_= 123;extern int b_2 = 123;void doSomething_t(){ cout &lt;&lt; \"Hello\" &lt;&lt; endl; cout &lt;&lt; \"test.cpp : \" &lt;&lt; Constants::pi &lt;&lt; endl; cout &lt;&lt; \"pi address of test.cpp : \" &lt;&lt; &amp;Constants::pi &lt;&lt; endl;}Constants.h#pragma oncenamespace Constants{ //전역상수// const double pi(3.141592);// const double gravity(9.8);//선언만 해준다.extern const double pi;extern const double gravity;}Constants.cpp```cpp//초기화를하였으니 컴파일을 하게 되면 cpp파일에서 obj가 만들어지고 obj들이 링킹이 될때 여러 cpp파일들이사용하게 된다.namespace Constants{ //전역상수 extern const double pi(3.141592); extern const double gravity(9.8);}Using문과 모호성// Using문과 모호성// Ambiguity#include &lt;iostream&gt;//std를 통채로 가져오는 방법//using namespace std;namespace a{ int my_var(10); int my_a(10);}namespace b{ int my_var(20); int my_b(10);}int main() { //프로그램의 크기가 커지면 동일한 이름의 변수와 함수를 사용하게 된다. //모호성 //이름이 같아지면 무엇을사용해아하는지 모른다. //컴파일러에게 모호성을없애주는 역할을 하는게 using이다. //예시) //cout, endl, cin을 사용하기 위해 std::의 사용을줄이기 위해 using naemspce std;가 있다. //std안의 cout만 가져오는 방법 using std::cout; using std::endl;// using namespace a;// using namespace b; //오류 발생 //네임스페이스안의 동일한 변수가잇어서 모호성 발생 //변수가 다르면 사용가능// cout &lt;&lt; my_var &lt;&lt; endl;// cout &lt;&lt; my_a &lt;&lt; endl;// cout &lt;&lt; my_b &lt;&lt; endl; //영역지정 연산자 이용하여 출력가능 cout &lt;&lt; a::my_var &lt;&lt; endl; cout &lt;&lt; b::my_var &lt;&lt; endl; //영역 연산자를 이용하기 싫다! //영역을 분리하여 사용하면 된다. { using namespace a; cout &lt;&lt; my_var &lt;&lt; endl; } { using namespace b; cout &lt;&lt; my_var &lt;&lt; endl; } //using 의 위험성에 대해 //헤더에 전역범위에 넣어버리면 헤더를 인클루드하는 모든cpp파일에 영향을 끼치게 된다. //헤더에 큰영역으로 두는것은좋지않다. //cpp파일에 넣는게좋긴하다. //헤더에 네임스페이스를안쓰느건아니긴하다. //쓰이긴 한다. //되도록 적은 범위에 영향을주도록 만드는게 좋다.}auto 키워드와 자료형추론// Auto 키워드롸 자료형 추론// Type Inference#include &lt;iostream&gt;using namespace std;//함수에서도 auto 사용가능auto add(int x, int y){ return x + y;}//파라미터에선 auto 사용 불가//파라미터에 auto를 쓰고싶은 이유://함수이름에 대하여 여러가지 변수형을 사용하고싶다. add(int, int) , add(double, double) 파라미터의 변수형에 따라 다르게 만들어주려면 귀찮다.//근데 auto를사용하지못하면 방법이 없는건가?//아니다.//나중에 템플릿(Template) 배우면 자동으로 하나의 함수이름으로 여러가지자료형을 넣을수있게 된다.//tailing//-&gt;를 이용하여 auto값을 표시해준다.//코드를 정리 할깨 정리하기 좋다.//줄맞춤에 용이하다.auto add(double x, double y) -&gt; double{ return x + y;}/* tailing 줄맞춤이 안맞음 auto add() -&gt; int; auto add() -&gt; double; int add(); double add(); */int main() { //큰 프로그램에서는 많은 변수를 선언하고 사용한다. //어떤 자료형인지 매번 수동으로 결정하게 되면 효율이 떨어진다. //자료형의 추론을 통해 효율을 높일수잇다. // int a = 123; //123만 보아도 a의 자료형은 int형이라는것을 추론할수있다. //auto keyword auto a = 123; //자동으로 a를 int형으로 할당한다. //자료형을 상황에 따라 스스로 결정하게 하는것을 형추론이라 한다. auto d = 123.0; //double auto c = 1 + 2; //int auto b = 1 + 2.0; //double //편리함과 동시에 잘 알고 사용해야한다. //함수의 리턴값에도 사용가능 auto result = add(1, 2); }형변환// 암시적 형변환과 명시적 형변환// Implicit Type Conversion(coersion)// Explicit Type Conversion(coersion)#include &lt;iostream&gt;#include &lt;typeinfo&gt;//자료형의 종류를 알수있는함수#include &lt;iomanip&gt;using namespace std;int main() { //타입 출력 방법 cout &lt;&lt; typeid(4.0).name() &lt;&lt; endl; //double int a = 123; cout &lt;&lt; typeid(a).name() &lt;&lt; endl; //int //암시적 형변환 //컴파일러가 알아서 바꿔주는형변환 int c = 123.0; cout &lt;&lt; typeid(c).name() &lt;&lt; endl; //명시적 형변환 //작은것 -&gt; 큰것 float a1 = 1.0f; double d = a1; //float의 크기가 double보다 작기때문에 정밀도가떨어지지않는다. //크게 문제가 없다. //numeric promotion //큰것 -&gt; 작은것 //numeric conversion //int -&gt; double double d2 = 3; //int -&gt; short short s = 2; //int -&gt; char int i = -128; char c1 = i; cout &lt;&lt; static_cast&lt;int&gt;(c1) &lt;&lt; endl; //48출력 //127이 나오는게 아니고 엉뚱한 숫자가 출력됨 //char이 들어갈수있는 숫자는 잘들어간다. -128~127 double d1 = 0.123456789; float f1 = d1; cout &lt;&lt; setprecision(12); cout &lt;&lt; \"d : \" &lt;&lt; d1 &lt;&lt; endl; cout &lt;&lt; \"f : \" &lt;&lt; f1 &lt;&lt; endl; //d : 0.123456789 //f : 0.123456791043 //정밀도가 떨어져 정확이 저장을 하지못한다. float ff = 3.14; int ii = ff; cout &lt;&lt; ii &lt;&lt; endl; //3출력, 버림 처리 cout &lt;&lt; 5u - 10 &lt;&lt; endl; //4294967291 cout &lt;&lt; 5 - 10 &lt;&lt; endl; //-5 cout &lt;&lt; 5u - 10u &lt;&lt; endl; //4294967291 //unsigned끼리의 연산은 unsigned 자료형에 저장하기때문에 이런 결과값이 발생한다. //형변환도 우선순위가 존재한다. //4바이트보다 작은것(short, char)은 int형으로 형변환이 우선적으로 된다. //형변환 우선순위 //int, unsigned int, long, unsigned long, long long, unsigned long long, float, double, long double //명시적 형변환 //프로그래머가 명시해주는 형변환 int i3 = int(4.0); //cpp style int i3 = (int)4.0; //c style int i3 = static_cast&lt;int&gt;(4.0); //세가지의 기능 차이는 거의없다. }문자열 std::string 소개// 문자열 std string 소개#include &lt;iostream&gt;#include &lt;string&gt;//std::string 라이브러리#include &lt;limits&gt;using namespace std;int main() { //--------------- //글자들이 나열되어있는것을 문자열이라고한다. //문자열을 다루는 데이터 타입 : string cout &lt;&lt; \"Hello World!\" &lt;&lt; endl; //문자열 마지막에는 안보이는 코드가 숨겨져있다. const char my_strs [] = \"Hello World!\"; //배열을 이용한 문자열 저장방식 //char cpp에서 기본적으로 제공하는 변수 //한글자를 배열로 나열하는것 //기본적인 방식 const string my_hello = \"Hello World!\"; //기본방식이 아닌 문자열을 사용하기 위해 사람들이 만든것 //사용자 정의 자료형 string my_ID = \"123\"; //숫자도 저장이 가능하지만 \"\"안에 저장해야한다. //정수로써 연산은 불가능하다. cout &lt;&lt; my_hello &lt;&lt; endl; //--------------- //string 입력방법 // // cout &lt;&lt; \"Your name? : \";// string name;// cin &gt;&gt; name;//// cout &lt;&lt; \"Your age? : \";// string age;// cin &gt;&gt; age;//// cout &lt;&lt; \"name : \" &lt;&lt; name &lt;&lt; endl;// cout &lt;&lt; \"age : \" &lt;&lt; age &lt;&lt; endl; //입력에 빈칸이 존재하면 입력을 완료하고, 나머지를 버퍼에 저장되고 다음 입력에서 사용한다. //ex) 입력 : Lee Sin //출력 : Lee //Sin은 버퍼에 저장 //입력 : 무시 //출력 : Sin //string 사용시 getline으로 빈칸 무시가능// cout &lt;&lt; \"Your name2? : \";// string name2;// std::getline(std::cin, name2);//// cout &lt;&lt; \"Your age2? : \";// string age2;// std::getline(std::cin, age2);//// cout &lt;&lt; \"name : \" &lt;&lt; name2 &lt;&lt; endl;// cout &lt;&lt; \"age : \" &lt;&lt; age2 &lt;&lt; endl; //getline //엔터칠때까지 입력을 받는다. //--------------- //오류 발생 코드 cout &lt;&lt; \"Your age2? : \"; int age2; cin &gt;&gt; age2; // cin.ignore(32767, '\\n'); //괄호 안의 내용 \\n을 만날떄까지 최대 32767개의 글자를 무시해라! //2바이트 int signed value값 32767 cin.ignore(numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); //이렇게도 사용가능하다. //알아만 두자 include 파일도 늘어나고 코드가 길어져서 별로다. // cout &lt;&lt; \"Your name2? : \"; string name2; std::getline(std::cin, name2); cout &lt;&lt; \"name : \" &lt;&lt; name2 &lt;&lt; endl; cout &lt;&lt; \"age : \" &lt;&lt; age2 &lt;&lt; endl; //cin을입력 하고 getline이 무시되는 현상 발생 //cin완료 후 버퍼를 지우고 새롭게 만들어주는 작업 필요 //--------------- //문자열의 덧셈 string a(\"Hello \"); string b(\"World! \"); cout &lt;&lt; a + b &lt;&lt; endl; //Hello World! 출력 string hw = a + b; //문자열 + 문자열 append hw += \"\\ni'm good\"; cout &lt;&lt; hw &lt;&lt; endl; //문자열의 길이 출력 방법 cout &lt;&lt; (a + b).length() &lt;&lt; endl; //13출력 //12글자 지만왜 13으로 출력이 되는가? //문자 마지막의 문자열의 끝을 알려주는 null값이 숨겨져있다.}열거형 enumerated types// 열거형 enumerated types#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//게임으로 예시//캐릭터 피해량 측정//데미지 반환 함수int computeDamange(int weapon_id){ //무기 종류에 따라 데미지가 다를수있음 if(weapon_id == 0) //sword { return 1; } if(weapon_id == 1) //hammer { return 2; } //옵션 값에 따라 값이 달라지면 헷갈리는 경우가 발생한다. //sword = 무기번호: 0 , 데미지: 1 //hammer = 무기번호: 1 , 데미지: 2 //hammer 무기번호와 sword 데미지를 보고 같은 무기라고 헷갈리는 경우가 발생할 수 있다. //종류가 많아지면 더욱더 헷갈려지는 경우가 발생한다. (실수 방어) return 0;}//열거형 정의 방법//예시 : 색상 반환enum Color //user-defined data types 유저정의 데이타{ COLOR_BLACK, COLOR_RED, COLOR_BLUE, COLOR_GREEN //마지막 끝은 , 있어도 없어도 ㄱㅊ 예전에는 없어야 한다고 함};//중괄호 끝나고 세미콜론 필요, 오류 발생enum Feeling{ HAPPY, BLUE, TIRED, JOY};//서로 다른 열거형의 값도 전역변수 처럼 작동한다.//중복이 안됨//enum으로 묶여잇지만, 중복으로 사용불가능하다.//이름이 중복되면 어쩔수없이 바꿔야하냐? 그건 아닌거같고 enum class? 에서 처리 가능하다고 한다.int main() { //비슷한 유형의 다양한 옵션들을 기호적으로 표현하기위한 열거형 방식 Color paint = COLOR_BLACK; Color house(COLOR_BLUE);// Color shoes{COLOR_GREE}; //uniform 은 다은 초기화와 다르게 조심해야하는것이잇다. Color my_color = COLOR_BLACK; cout &lt;&lt; my_color &lt;&lt; \", \" &lt;&lt; COLOR_BLACK &lt;&lt; endl; //0, 0출력 //enum변수에 값 지정가능 //COLOR_BLACK = -3 -&gt; 자동으로 그 아래값들은 +1씩 증가 RED: -2 //값을 다 따로 할당 가능 //수동으로 값을 같게 해주면 구분이 불가능 해지므로 사용하는의미가 사라진다. //기본 할당값을 사용하는게 좋긴하다. //대부분 대문자를 사용한다. //내부적으로 정수로 저장이 된다. //정수형처럼 사용 불가능하다. int color_id = COLOR_RED; cout &lt;&lt; color_id &lt;&lt; endl; //Color color = 2; //int 초기화 불가능 //casting은 가능하다 Color color = static_cast&lt;Color&gt;(3); //cin사용 유무 //불가!// cin &lt;&lt; color; //enum 입력 구현방법 1// int in_number;//// cin &gt;&gt; in_number;//// if(in_number == 0) my_color = COLOR_BLACK;// if(in_number == 1) my_color = COLOR_RED; //방법2// string str;// getline(cin, str);// if(in_number == \"COLOR_BLACK\") my_color = COLOR_BLACK;// if(in_number == \"COLOR_RED\") my_color = COLOR_RED; //권장하지않는다. 대소문자 구분이 불가능하여 오류발생 //여라 파일에서 사용할때는 //cpp 함수 만들엇던것처럼 헤더파일로 만들어서 include해서 다른 파일에서도 사용가능하게 만들수있다. //많이 사용하는 개념이다.}영역 제한 열거형(열거형 클래스)// 영역 제한 열거형 (열거형 클래스)// Scoped Enumerations// Enum Class#include &lt;iostream&gt;using namespace std;//enum Color//{// RED,// BLUE,//};////enum Fruit//{// BANANA,// APPLE,//};enum class Color{ RED, BLUE,};enum class Fruit{ BANANA, APPLE,};int main() {// Color color(RED);// Fruit fruit(BANANA);//// if(color == fruit)// cout &lt;&lt; \"color == fruit\" &lt;&lt; endl;// //RED랑 BANANA를 비교를 했는데 같은걸로 나온다. Color color(Color::RED); Fruit fruit(Fruit::BANANA); Color color1(Color::RED); Color color2(Color::BLUE); //같은 것끼리만 비교가 가능하다 //Fruit과 Color끼리의 비교가 불가능해짐 if(color1 == color2) cout &lt;&lt; \"equal\" &lt;&lt; endl; else cout &lt;&lt; \"not equal\" &lt;&lt; endl;}자료형에게 가명 붙여주기// 자료형에게 가명 붙여주기// type aliases(가명)#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdint&gt;using namespace std;int main() { //double을 거리 개념으로 사용하기위한 정의 //주석겸 메모겸 사용한다. //_t =&gt; type name을 알려주기위한 표시 없어도 됨 사용자 정의 니까. typedef double distans_t; //고정너비정수 std::int8_t i(97); double my_distance; //사용방법 distans_t home2work; //위나 아래나 컴파일러는 같다고 생각한다. //사용하는이유 별명 사용시 자료형을 바꿔야하는경우 typedef의 자료형만 바꿔주면 다 바뀌므로 코드 유지관리하기가 쉬워진다. 용이해진다. //템플릿에서도 사용한다고 한다. //자료형이 복잡한경우 typedef를 사용하면 깔끔해진다. vector&lt;pair&lt;string, int&gt; &gt; pairlist1; vector&lt;pair&lt;string, int&gt; &gt; pairlist2; typedef vector&lt;pair&lt;string, int&gt; &gt; pairlist_t; pairlist_t pairlis3; pairlist_t pairlis4; //using 사용 using pairlist2_t = vector&lt;pair&lt;string, int&gt; &gt;; //두개의 장단점은 없다. //긴것을 짧게 만들수있다.}구조체 struct// 구조체// struct#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//Person 구조체 정의struct Person{ double height; //키 float weight; //몸무게 int age; //나이 string name; //이름 //파라미터 불필요 void printPerson2() { cout &lt;&lt; height &lt;&lt; \", \" &lt;&lt; weight &lt;&lt; \", \" &lt;&lt; age &lt;&lt; \", \" &lt;&lt; name &lt;&lt; endl; }};//사람 정보 출력 함수void printPerson(Person ps){ cout &lt;&lt; ps.height &lt;&lt; \", \" &lt;&lt; ps.weight &lt;&lt; \", \" &lt;&lt; ps.age &lt;&lt; \", \" &lt;&lt; ps.name &lt;&lt; endl; //. member selection operator //구조체의 각각의 변수를 멤버라고 한다. }struct Family{ //구조체 안에 구조체를 넣을수도 있다. Person me, mom, dad;};//구조체 반환형 함수도 가능Person getMe(){ Person me{2.0, 100.0, 20, \"Lee\"}; return me; }struct Employee{ short id; int age; double wage; };int main() { //하나의 자료형으로 복잡한 구조물을 설명하기 어렵다. //구조체 //여러 자료형을 묶어서 하나릐 자료형으로 만든다. //클래스를 넘어가기 위한 길목 //중요한 내용이다. //사람 예시// double height; //키// float weight; //몸무게// int age; //나이// string name; //이름 //구조체를 사용하는 이유1 //함수를 만들어서 출력하기 위해 파라미터가 길어지는 경우 발생한다. /* void printPerson(double height, float weight, int age, string name....) { } */ //이유2 //사람의 수가 늘어난다? /* 사람의 수 3명 예시 double height1, height2, height3; //키 float weight1, weight2, weight3; //몸무게 int age1, age2, age3; //나이 string name1, name2, name3; //이름 */ //여러명의 여러가지를 다루어야한다. //변수에 접근하기에 복잡해진다. //사용자 정의 자료형 Person me{2.0, 100.0, 20, \"Lee\"}; //uniform initialization //초기화 방법 Person ma; Person fa; printPerson(me); //함수의 인자가 짧아진다. //구조체 안에함수를 만들수있다. 데이터와 기능을 묶어줄수있다. /* struct Person { //멤버변수 double height; //키 float weight; //몸무게 int age; //나이 string name; //이름 //멤버함수 void printPerson2() { cout &lt;&lt; height &lt;&lt; \", \" &lt;&lt; weight &lt;&lt; \", \" &lt;&lt; age &lt;&lt; \", \" &lt;&lt; name &lt;&lt; endl; //. member selection operator //구조체의 각각의 변수를 멤버라고 한다. } }; //사람 정보 출력 함수 */ //파라미터가 필요없다. me.printPerson2(); //대입 Person me2; me2 = me; //간단한 구조체의 경우에는 복사가능하다. //복잡해질경우 이상하게 작동할수도있다. struct to struct / class to class 복사는 조심히 사용하자 me2.printPerson2(); //함수 사용 Person per1 = getMe(); per1.printPerson2(); //구조체 값을 직접 초기화 가능하다. //기본값 정의 방법 /* struct Person { //멤버변수 double height = 10; float weight; int age; string name; //멤버함수 void printPerson2() { cout &lt;&lt; height &lt;&lt; \", \" &lt;&lt; weight &lt;&lt; \", \" &lt;&lt; age &lt;&lt; \", \" &lt;&lt; name &lt;&lt; endl; //. member selection operator //구조체의 각각의 변수를 멤버라고 한다. } }; //초기화를 안해주면 기본값 사용하고, 초기화를 진행하면 초기화값으로 출력된다. */ //Employee 예제 //구조체의크기 파악 Employee emp1; //emp1의 데이터 크기 //short + int + double = 2bype + 4bype + 8bype = 14bype cout &lt;&lt; sizeof(Employee) &lt;&lt; endl; //16이 출력이됨 //계산에. 따르면 14가 나올것을예상햇는데 16이 나옴 //컴퓨터가 2byte 배치가 어렵다. //2bype + (2bype) + 4bype + 8bype //(2bype) padding 발생 //최적화할때 이런것도 고려해야한다. //클래스를 배울때 수월해지려면 구조체를잘알고 넘어가야 한다고 한다.}" }, { "title": "[C++] Chapter.3 연산자들", "url": "/posts/Cpp-Ch3/", "categories": "Language, C++", "tags": "c++", "date": "2022-09-01 21:39:12 +0900", "snippet": "연산자 우선순위와 결합법칙// 연산자 우선운위와 결합 법칙// Operator Precedence and Associativity#include &lt;iostream&gt;using namespace std;int main() { //기본적인 수학 연산자 int x = 4 + 2 * 3; //컴파일러가 연산자를 만낫을때 우선순위 구조를 가지고 판단하여 실행한다. //ex 4+2*3 =&gt; *를 먼저 실행하고 그후에 + 연산자를 실행한다. //ex (4+2)*3 =&gt; 괄호가 있는 경우 괄호 먼저 실행 //결합법칙 Associativity //우선순위 Precedence //Left to Right //왼쪽부터 진행 //Right to Left //오른쪽부터 진행 //우선순위가 헷갈리는경우 갈호로 묶어서 명확하게 표현하는것도 나쁘진않다. //기존 코드를 읽을때 헷갈리는 경우가 잇으면 구글링을 해라 표를 확인해보자 cout &lt;&lt; x &lt;&lt; endl; }산술 연산자// 산술 연산자// Arithmetic Operator#include &lt;iostream&gt;using namespace std;int main() { int x = 1; //부호를 바꿔주는 -연산자 //단항 연산자 int y = -x; //-1 출력 x = 2; y = 4; //사칙연산 //+ 더하기 연산자 int z = x + y; cout &lt;&lt; z &lt;&lt; endl; //- 뺼셈 연산자 z = x - y; cout &lt;&lt; z &lt;&lt; endl; //* 곱셈 연산자 z = x * y; cout &lt;&lt; z &lt;&lt; endl; // / 나눗셈 연산자 z = x / y; cout &lt;&lt; z &lt;&lt; endl; //% 나머지 연산자 z = x % y; cout &lt;&lt; z &lt;&lt; endl; x = 7; y = 4; //정수에서의 나머지 연산 z = x / y; cout &lt;&lt; \"정수의 나눗셈 : \" &lt;&lt; z &lt;&lt; endl; //실수에서의 나머지 연산 //둘중 하나라도 실수면 실수로 나온다. cout &lt;&lt; \"실수의 나눗셈 : \" &lt;&lt; float(x) / y &lt;&lt; endl; cout &lt;&lt; \"실수의 나눗셈 : \" &lt;&lt; x / float(y) &lt;&lt; endl; cout &lt;&lt; \"실수의 나눗셈 : \" &lt;&lt; float(x) / float(y) &lt;&lt; endl; //주의사항 //음수를 나누는 경우 //소수점 버림으로 처리 cout &lt;&lt; \"음수의 나눗셈 : \" &lt;&lt; -5 / 2 &lt;&lt; endl; //나머지 연산 음수의 경우 //왼쪽의 부호에 따라 부호를 결정한다. //대입 연산자 //x의 메모리의 정보를 a변수가 가르키고있는 메모리에 복사해 넣어라! int a = x; //축약형 //코드가 짧아져서 좋다. a += y; //a = a + y; a -= y; //a = a - y; a *= y; //a = a * y; a /= y; //a = a / y; a %= y; //a = a % y; }증감 연산자// 증가/감소 연산자// increment/decrement#include &lt;iostream&gt;using namespace std;int add(int a , int b){ return a + b;}int main() { //많이 쓰이고 쓰기 쉽고 실수가 많이발생한다. 중요하다. int x = 5;// int y = ++x; //x에 1을 더한다. int y = --x; int z = x--; //앞뒤 둘다 가능 cout &lt;&lt; y &lt;&lt; endl; cout &lt;&lt; z &lt;&lt; endl; //6출력 int a = 6 , b = 6; cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl; // cout &lt;&lt; ++a &lt;&lt; \" \" &lt;&lt; --b &lt;&lt; endl; //7 5 출력 cout &lt;&lt; a++ &lt;&lt; \" \" &lt;&lt; b-- &lt;&lt; endl; //6 6 출력 //증감이 안된다 //앞에 붙는경우 //증감 실행 후, 출력 실행 //뒤에 붙는 경우 //a b 출력 후, 증감 실행 cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl; //증감 발생 cout &lt;&lt; \"---reset----\" &lt;&lt; endl; a = 6 , b = 6; cout &lt;&lt; \"1 : \"&lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl; //기본 출력 cout &lt;&lt; \"2 : \"&lt;&lt; ++a &lt;&lt; \" \" &lt;&lt; --b &lt;&lt; endl; //증감후 출력 cout &lt;&lt; \"3 : \"&lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl; //기본 출력 cout &lt;&lt; \"4 : \"&lt;&lt; a++ &lt;&lt; \" \" &lt;&lt; b-- &lt;&lt; endl; //출력후 증감 cout &lt;&lt; \"5 : \"&lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl; //기본 출력 //부작용이 되는 경우 //함수에 적용하는 경우 //강의에서는4가 출력되지만, xcode에선 3이 출력된다. //컴파일러마다 다르게 적용이 된다. //정의하기 힘들다. int q = 1; int result = add(q, ++q); //이렇게 사용하지 말아라. 인수에 증감 연산자를 사용하지말것; cout &lt;&lt; result &lt;&lt; endl; q = 1; int w = 2; result = add(q, ++w); //이경우엔 4가 출력이됨; cout &lt;&lt; result &lt;&lt; endl; cout &lt;&lt; \"---reset----\" &lt;&lt; endl; x = 1; x = x++; //이런식으로 사용하지말아라. 헷갈린다. cout &lt;&lt; x &lt;&lt; endl;}sizeo, 쉼표 연산자, 조건부 연산자// sizeof, 쉼표연산자, 조건부 연산자// Comma Operator// Conditional Operator#include &lt;iostream&gt;using namespace std;int getPrice(bool OnSale){ if(OnSale) return 10; else return 100;;}int main() { //데이터 형의 크기를 알고 싶을때 사용 //변수 타입사용가능// sizeof(float); //변수로도 사용가능// float a;// sizeof(a); //구조체 및 클래스도 사용가능 //커스텀 자료형이다. //sizeof는 함수가 아니라 연산자이다. //변수일땐 괄호없이 사용가능; //cout &lt;&lt; sizeof a ; //comma operator //주의 필요 int x = 3; int y = 10; int z = (++x, ++y); //++x; ++y; int z = y; &lt;&lt; for문에서 많이 사용한다. //콤마 앞 진행, 뒤 진행후 마지막 것을 대입한다. cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \" \" &lt;&lt; z &lt;&lt; endl; //선언의 콤마는 구분해주는 기호 int a = 1 , b = 10; int c; c = a, b; //우선순위가 대입보다 낮아서 대입을 먼저 실행하고 콤마를 실행되어 (c = a) , b로 진행이되어 b는 아무런 진행이 안되고 a값이 c에 복사가 되어 a값을 출력한다. cout &lt;&lt; c &lt;&lt; endl; //for문외에는 잘 사용하지않는다. 보기불편하고 해석하기 불편하다. //코드는 보기 편하게 만드는게 제일 좋다. //conditional operator //arithmetric if //삼항 연산자 bool onSale = true; int price; if(onSale) price = 10; else price = 100; cout &lt;&lt; price &lt;&lt; endl; //삼항연산자가 잘 쓰이는곳 //price값을 const로 사용하고싶을때 //연산이 간단할때 사용한다. const int price2 = (onSale == true) ? 10 : 100; cout &lt;&lt; price2 &lt;&lt; endl; //함수로 짤수도 있다. //코드가 간단하면 추천하지 않는다. //코드가 간단한 경우에는 코드가 늘어나고 보기 힘들어진다. const int price3 = getPrice(onSale); }관계 연산자// 관계 연산자// Relational Operator#include &lt;iostream&gt;using namespace std;int main() { //두 변수 대수비교에 사용하는 연산자이다. // while(true)// { int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; \"Your input values are : \" &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; endl; //==연산자 if(x == y) cout &lt;&lt; \"equal\" &lt;&lt; endl; //!= 연산자 if(x != y) cout &lt;&lt; \"not equal\" &lt;&lt; endl; //&gt;연산자 if(x &gt; y) cout &lt;&lt; \"x is greater than y\" &lt;&lt; endl; //&lt;연산자 if(x &lt; y) cout &lt;&lt; \"x is less than y\" &lt;&lt; endl; //&gt;=연산자 if(x &gt;= y) cout &lt;&lt; \"x is greater than y or equal to y\" &lt;&lt; endl; //&lt;=연산자 if(x &lt;= y) cout &lt;&lt; \"x is less than y or equal to y\" &lt;&lt; endl;// } //반복문 처리로 연속 입력 가능 //주의사항 //실수의 비교에서 오류가ㅏ 발생한다. double d1(100 - 99.99); //0.001 double d2(10 - 9.99); //0.001 //보기엔 같아보인다. if(d1 == d2) cout &lt;&lt; \"equal\" &lt;&lt; endl; else { cout &lt;&lt; \"not equal\" &lt;&lt; endl; //여기가 출력 if(d1 &gt; d2) cout &lt;&lt; \"d1 &gt; d2\" &lt;&lt; endl; //여기가 출력 else cout &lt;&lt; \"d1 &lt; d2\" &lt;&lt; endl; }// if(d1 != d2)// cout &lt;&lt; \"not equal\" &lt;&lt; endl;// //not equal 발생!! //수치해석학? 수치가 중요한곳에서 일하려면 이것도 공부해라 cout &lt;&lt; d1 - d2 &lt;&lt; endl; //절댓값 함수 사용 cout &lt;&lt; std::abs(d1 - d2) &lt;&lt; endl; //5.32907e-15 출력 //이만큼 정도밖에 차이 안난다. //차이의 한계를 정해놓는다. //차이를 어떻게 정의를해야하는가? //정의 하는것은 그때그때 달라진다. const double epsilon = 1e-10; if(abs(d1 - d2) &lt; epsilon) cout &lt;&lt; \"Approximately equal\" &lt;&lt; endl; //여기 실행 else cout &lt;&lt; \"not equal\" &lt;&lt; endl;}논리 연산자// 논리 연산자// Logical Operator#include &lt;iostream&gt;using namespace std;int main() { //bool값 연산 별로 어려운 내용은 아니다. //추상적이라 이해하기 힘들 수 있다. //하다보면 익숙해지니까 별걱정 말자. bool x = true; bool y = false; //logical not ! //true -&gt; fasle //false -&gt; true cout &lt;&lt; !x &lt;&lt; endl; //logical and //&amp;&amp; //둘다 true일때만 true 반환 cout &lt;&lt; (x &amp;&amp; y) &lt;&lt; endl; //사용 예시 게임 //타격 여부와 체력 조건에 의한 결과로 설명한다. bool hit = true; int health = 10; //if두개로 나눌수있지만, 더 복잡해므로 논리 연산자에 익숙해져야한다. 효율적이다. if(hit == true &amp;&amp; health &lt; 20) //if(hit &amp;&amp; health &lt; 20)도 가능 명확성이 조금 떨어져 보임 cout &lt;&lt; \"die\" &lt;&lt; endl; else health -= 20; //logical or //둘중에 하나라도 true면 true 반환 cout &lt;&lt; (x || y) &lt;&lt; endl; int a = 5; int b = 5; //equal 연산자의 잘못 사용 예시 //우선순위로 인하여 원치않은 결과값이 나온다. if(!a == b) //(!x) == y //!(x == y) //(x != y) cout &lt;&lt; \"a does not equal b\" &lt;&lt; endl; else cout &lt;&lt; \"a eqauls b\" &lt;&lt; endl; //예시 int v = 1; if(v == 0 || v == 1) cout &lt;&lt; \"v is 0 or 1\" &lt;&lt; endl; //특정 아이템 사용시 //and or로 한번 연습해봐라 자신만의 스토리를 이용하여 //short circuit evaluation a = 2; b = 2; //생각으로는 왼쪽 연산하고 오른쪽 연산하고 두개의값을 비교한다. 라고 생각이 든다. //하지만, 실질적으로 and에서 왼쪽이 false가 되어버리면 계산을 안한다. //왜냐하면 and는 둘중 하나라도 false면 false가 반환이 되므로 왼쪽계산이 false라면 계산을 멈춘다. //or도 마찬가지로 왼쪽이 true면 계산을 멈추고 true를 반환한다. if(a == 1 &amp;&amp; ( b++ == 2)) { cout &lt;&lt; \"Test\" &lt;&lt; endl; } //a가 1인경우 3반환 //a가 2인경우 2반환 cout &lt;&lt; b &lt;&lt; endl; x = true; y = false; //De Morgan's Law // !(x &amp;&amp; y) != !x &amp;&amp; !y; // !x || !y; // !(x || y) = !x &amp;&amp; !y; //XOR != //false false false //false true true //true false true //true true false cout &lt;&lt; boolalpha; cout &lt;&lt; (x != y) &lt;&lt; endl; cout &lt;&lt; (x != !y) &lt;&lt; endl; //연습 문제 //(true &amp;&amp; true) || false //(false &amp;&amp; true) || true //(false &amp;&amp; true) || false || true //(14 &gt; 13 || 2 &gt; 1) &amp;&amp; (9 &gt; 1) // !(2314123 &gt; 2 || 123123 &gt; 2387 //and or 혼합 bool b1 = true; bool b2 = false; bool b3 = false; bool r1 = b1 || b2 &amp;&amp; b3; bool r2 = (b1 || b2) &amp;&amp; b3; bool r3 = b1 || (b2 &amp;&amp; b3); //true, false 출력 cout &lt;&lt; r1 &lt;&lt; \", \" &lt;&lt; r2 &lt;&lt; \", \" &lt;&lt; r3 &lt;&lt; endl; //이유 우선순위가 &amp;&amp;가 ||보다 높다. //명확성, 정확성을 위해 여러 연산을 사용하는경우에는 괄호를 사용하자;;}이진수// 이진수// Binary Numbers#include &lt;iostream&gt;using namespace std;int main() { //0과 1로 숫자를 표현하는 방식 //컴퓨터는 전압 방식으로 숫자를 저장한다. /* 10진법 0 1 2 3 4 5 6 7 8 9 자릿수 증가 10 10^1 + 0 11 10^1 + 1 12 10^1 + 2 337 = (300 + 30 + 7) = (10^2 *3) + (10^1 *3) + 1(0^0 * 7) 이진법 0 1 10 = 2^1*1 + 2^0*0 = 2 11 = 2^1*1 + 2^0*1 = 3 100 = 2^2*1 + 2^1*0 + 2^0*1 = 4 (1) 11 + 1 ------ 100 컴퓨터는 10진수를 2진수로 바꿔서 저장한다. int = 4byte = 32bit 1byte = 8bit 0101 1110 7654 3210 &lt;binary to Decimal&gt; 2^7*0 + 2^6*1 + 2^5*0 + 2^4*1 + 2^3*1 + 2^2*1 + 2^1*1 + 2^0*0 2^6*1 + 2^4*1 + 2^3*1 + 2^2*1 + 2^1*1 = 64 + 16 + 8 + 4 + 2 = 94 &lt;Decimal to binary&gt; 방법2 148 148 / 2 = 74 - 0 74 / 2 = 37 - 0 37 / 2 = 18 - 1 18 / 2 = 9 - 0 9 / 2 = 4 - 1 4 / 2 = 2 - 0 2 / 2 = 1 - 0 1 / 2 = 0 - 1 몫이 0이 될때까지 2로 나누고 나머지들을 이어주면 그것이 2진수가 된다. = 10010100 방법2 148 2의 제곱수 중 작으면서 제일 근접한 숫자를 찾는다. 148 &gt; 128 그 숫자가 몇번째 제곱수 인지 파악한다. 127 = 2^7 = 7번째 숫자 그 수의 1을 더한 자리가 1을가진다. 8번째 자리 = 1 2의 제곱수를 뺀 숫자로 1번부터 반복한다. 148 - 128 = 20 20 &gt; 16 =&gt; 16=2^4 =&gt; 5번째 자리 = 1 20 -16 = 4 =&gt; 4 = 2^2 =&gt; 3번째 자리 = 1 4-4 = 0 완료 전체 길이는 8자리의 2진수이며, 8번자리가 1이고, 5번자리가 1이고, 3번자리가 1인 10010100이 된다. &lt;이진법에서의 더하기&gt; 11 0110 (6) 0111 (7) ------- 1101 (13) &lt;음의 정수 표현 방법&gt; -5 1. 절댒값을 이진수로 바꾼다. &gt;0000 0101 2. 보수(complement)를 취한다. 숫자 반전 0을 1로 1을 0으로 변환후 1을 더한다. &gt;1111 1010 3. 1을 더한다. =&gt; 숫자 0을표현할때 2가지숫자가 될수있어서 막기위한 과정 &gt;1111 1011 (-5) 양수 0 0000 0000 보수 0 1111 1111 더하기 1 0000 0000 이진수의 맨앞 숫자는 부호 숫자이다. 0 = 양수 , 1 = 음수 1001 1110 (?) 1. 보수를 취한다. 0110 0001 2. 1을 더한다. 0110 0010 -&gt; 98 앞의 부호가 1이므로 1001 1110은 -98이 된다. 1111 11 1001 1110 0110 0010 --------- 0000 0000 두개의 숫자를 더하면 0000 0000 , 0이 된다. &lt;signed vs unsigned&gt; unsigned 1001 1110 -&gt; 2^7*1 + 2^4*1 + 2^3*1 + 2^2*1 + 2^1*1 = 128 + 16 + 8 + 4 +2 = 158 signed 1001 1110 -&gt; -98 같은 숫자라도 signed unsigned에 따른 값의 차이가 크게 난다. &lt;숙제&gt; 0100 1101을 10진수로 변환하기 10진수 93을 8비트 무부호 정수로 변환하기 10진수 -93을 8비트 부호 정수로 변환하기 2진수 1010 0010을 무부호 10진수로 변환하기 2진수 1010 0010을 부호가 있는 10진수로 변환하기 */ }비트단위 연산자// 비트단위 연산자// Bitwise Operator#include &lt;iostream&gt;//2진수로 바꿔주는 라이브러리#include &lt;bitset&gt;using namespace std;int main() { //int float 타입단위 연산 사람이 하는 연산 //비트단위 //컴퓨터가 이진수로 저장하였을때 각자리를 계산하는 방식 //1바이트가 최소단위 //비트단위를 사용하며 더 빠른 경우가 있다. //비트단위 //unsigned를 사용하는것이 대부분이다. unsigned int a = 3; //bitset&lt;bit&gt;(variable) cout &lt;&lt; bitset&lt;4&gt;(a) &lt;&lt; endl; unsigned int b = a &lt;&lt; 1; // &lt;&lt; left shift //cout 의 &lt;&lt; 는 다른것이다. &lt;오퍼레이터 오버로딩&gt; cout &lt;&lt; bitset&lt;4&gt;(b) &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl; //0110 6 //한칸더 이동 b = b &lt;&lt; 1; cout &lt;&lt; bitset&lt;4&gt;(b) &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl; //1100 12 b = b &lt;&lt; 1; cout &lt;&lt; bitset&lt;8&gt;(b) &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl; //00011000 24 //규칙성이 보인다. cout &lt;&lt; bitset&lt;4&gt;(a &lt;&lt; 1) &lt;&lt; \" \" &lt;&lt; (a &lt;&lt; 1) &lt;&lt; endl; //6 = 3 * 2^1 cout &lt;&lt; bitset&lt;4&gt;(a &lt;&lt; 2) &lt;&lt; \" \" &lt;&lt; (a &lt;&lt; 2) &lt;&lt; endl; //12 = 3 * 2^2 cout &lt;&lt; bitset&lt;4&gt;(a &lt;&lt; 3) &lt;&lt; \" \" &lt;&lt; (a &lt;&lt; 3) &lt;&lt; endl; //24 = 3 * 2^3 cout &lt;&lt; bitset&lt;4&gt;(a &lt;&lt; 4) &lt;&lt; \" \" &lt;&lt; (a &lt;&lt; 4) &lt;&lt; endl; //48 = 3 * 2^4 //2의 제곱을 하고싶을경우 left shift를 사용하는것이 훨씬 빠르게 구현가능하다. //0011 //0110 //기능 : 이진수를 오른쪽으로 한칸 밀고 0으로 채워준다. // cout &lt;&lt; \"----right shift----\" &lt;&lt; endl; // &gt;&gt; right shift //cin 의 &gt;&gt; 는 다른것이다. &lt;오퍼레이터 오버로딩&gt; a = 1024; cout &lt;&lt; bitset&lt;16&gt;(a) &lt;&lt; endl; cout &lt;&lt; bitset&lt;16&gt;(a &gt;&gt; 1) &lt;&lt; \" \" &lt;&lt; (a &gt;&gt; 1) &lt;&lt; endl; //512 = 1024 / 2^1 cout &lt;&lt; bitset&lt;16&gt;(a &gt;&gt; 2) &lt;&lt; \" \" &lt;&lt; (a &gt;&gt; 2) &lt;&lt; endl; //256 = 1024 / 2^2 cout &lt;&lt; bitset&lt;16&gt;(a &gt;&gt; 3) &lt;&lt; \" \" &lt;&lt; (a &gt;&gt; 3) &lt;&lt; endl; //128 = 1024 / 2^3 cout &lt;&lt; bitset&lt;16&gt;(a &gt;&gt; 4) &lt;&lt; \" \" &lt;&lt; (a &gt;&gt; 4) &lt;&lt; endl; //64 = 1024 / 2^4 // 0000010000000000// 0000001000000000 512// 0000000100000000 256// 0000000010000000 128// 0000000001000000 64 cout &lt;&lt; \"----not bit----\" &lt;&lt; endl; // ~ not cout &lt;&lt; bitset&lt;16&gt;(~a) &lt;&lt; \" \" &lt;&lt; (~a) &lt;&lt; endl; //0과 1을 바꾸는 연산 //1111101111111111 4294966271 //1024 가 어떻게4294966271이 되었는가? cout &lt;&lt; \"----and bit----\" &lt;&lt; endl; // &amp; and a = 0b1100; b = 0b0110; cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl; //12 6 cout &lt;&lt; bitset&lt;4&gt;(a &amp; b) &lt;&lt; endl; //0100 cout &lt;&lt; \"----or bit----\" &lt;&lt; endl; // | or cout &lt;&lt; bitset&lt;4&gt;(a | b) &lt;&lt; endl; //1110 cout &lt;&lt; \"----xor bit----\" &lt;&lt; endl; // ^ xor cout &lt;&lt; bitset&lt;4&gt;(a ^ b) &lt;&lt; endl; //1010 //비트연산자도 축약형으로 사용가능하다. //a &amp;= b //Quiz //0110 &gt;&gt; 2 //5 | 12 //5 &amp; 12 //5 ^ 12}비트플래그, 비트 마스크 사용법// 비트 플래그, 비트마스크사용법// Bit flags, Bit masks#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;int main() { //비트 플래그 //비트단위가 실전에서 어떻게 사용되는지 예시를 알려준다.. //게임예시 //아이템 착용 유무 //4개의 장비 미착용중 bool item1_flag = false; bool item2_flag = false; bool item3_flag = false; bool item4_flag = false; //착용! //1번 장비 작용 item1_flag = true; //파괴! //1번 장비 파괴 item1_flag = false; //특정 장비 착용 유무에 따른 이벤트 발생 if(item3_flag == true) { //쏼라 쏼라~ } //이렇게 적은경우엔 변수가 4개밖에 안되지만, 여러개가 있는경우 코드가 길어진다. 불편하다. //함수의 파라미터에 가짓수가 많아질수잇다. //invokeEvent(item1_flag,item2_flag,item3_flag,item4_flag ....) //유무 관련 데이터는 참 거짓 두가지만 가지므로 1바이트만 해도 8비트 이니까 8개 데이터 저장 가능하지않을까? 생각이 들수있다. unsigned char items_flag = 0; cout &lt;&lt; bitset&lt;8&gt;(items_flag) &lt;&lt; endl; //00000000 //각 비트별 플래그 설정 const unsigned char op0 = 1 &lt;&lt; 0; const unsigned char op1 = 1 &lt;&lt; 1; const unsigned char op2 = 1 &lt;&lt; 2; const unsigned char op3 = 1 &lt;&lt; 3; cout &lt;&lt; bitset&lt;8&gt;(op0) &lt;&lt; endl; cout &lt;&lt; bitset&lt;8&gt;(op1) &lt;&lt; endl; cout &lt;&lt; bitset&lt;8&gt;(op2) &lt;&lt; endl; cout &lt;&lt; bitset&lt;8&gt;(op3) &lt;&lt; endl; cout &lt;&lt; \"No item\" &lt;&lt; bitset&lt;8&gt;(items_flag) &lt;&lt; endl; //item0 획득! items_flag |= op0; cout &lt;&lt; bitset&lt;8&gt;(items_flag) &lt;&lt; endl; //00000001 //itme3 획득 items_flag |= op3; cout &lt;&lt; bitset&lt;8&gt;(items_flag) &lt;&lt; endl; //00001001 //item3 소멸 items_flag &amp;= ~op3; cout &lt;&lt; bitset&lt;8&gt;(items_flag) &lt;&lt; endl; //item1 여부 확인 if(items_flag &amp; op1) { cout &lt;&lt; \"있어요\" &lt;&lt; endl; } else cout &lt;&lt; \"없어요\" &lt;&lt; endl; //내 예상// if((items_flag &amp; op0) == op0)// cout &lt;&lt; \"있어요\" &lt;&lt; endl; //아이템 동시 획득 items_flag |= (op2 | op3); cout &lt;&lt; bitset&lt;8&gt;(items_flag) &lt;&lt; endl; //아이템2를 사용하요 아이템1 생성 if((items_flag &amp; op2) &amp;&amp; !(items_flag &amp; op1)) { //두줄을 한줄로 줄일 수 있다. items_flag ^= op2; items_flag ^= op1; cout &lt;&lt; bitset&lt;8&gt;(items_flag) &lt;&lt; endl; } //비트 마스크 //색상테이블 사용 const unsigned int red_mask = 0xFF0000; const unsigned int green_mask = 0x00FF00; const unsigned int blue_mask = 0x0000FF; // cout &lt;&lt; bitset&lt;32&gt;(red_mask) &lt;&lt; endl;// cout &lt;&lt; bitset&lt;32&gt;(green_mask) &lt;&lt; endl;// cout &lt;&lt; bitset&lt;32&gt;(blue_mask) &lt;&lt; endl; unsigned int pixel_clr = 0xDAA520; cout &lt;&lt; bitset&lt;32&gt;(pixel_clr) &lt;&lt; endl; //00000000110110101010010100100000 unsigned int red, green, blue; blue = pixel_clr &amp; blue_mask; cout &lt;&lt; bitset&lt;8&gt;(blue) &lt;&lt; \" \" &lt;&lt; (int)blue &lt;&lt; endl; green = pixel_clr &amp; green_mask; cout &lt;&lt; bitset&lt;16&gt;(green) &lt;&lt; \" \" &lt;&lt; (int)green &lt;&lt; endl; //1010010100000000 //8칸 right shift 사용 green &gt;&gt;= 8; cout &lt;&lt; bitset&lt;16&gt;(green) &lt;&lt; \" \" &lt;&lt; (int)green &lt;&lt; endl; red = pixel_clr &amp; red_mask; cout &lt;&lt; bitset&lt;8&gt;(red) &lt;&lt; \" \" &lt;&lt; (int)red &lt;&lt; endl; red &gt;&gt;= 16; cout &lt;&lt; bitset&lt;8&gt;(red) &lt;&lt; \" \" &lt;&lt; (int)red &lt;&lt; endl; }" }, { "title": "[C++] Chapter.2 변수와 기본 자료형 소개", "url": "/posts/Cpp-Ch2/", "categories": "Language, C++", "tags": "c++", "date": "2022-08-30 23:33:42 +0900", "snippet": "기본 자료형 소개// 기본 자료형 소개// Fundamental Data Types// 빌트인? 베이직?#include &lt;iostream&gt;using namespace std;int main() { //int = 정수형 4바이트 사용 //char = 문자형 character 1바이트 //문자도 숫자로 바꾸고 숫자를 이진법으로 바꿔서 메모리에 저장한다 &gt;&gt; 아스키 코드 //signed 음수 양수 0 //unsigned 양수 0 //특정 연산일때 빠른 경우가 발생한다. //타입마다 메모리수가 달라진다. //메모리 사이즈 수만큼 표시가 가능하다. //사이즈가 다양한 이유 //게임예시 : 하나의 int를 사용해도 동접자수가 여러명일때 메모리사용증가 한다. //int 100개, 동접자수 1000명 -&gt; 400바이트* 1000 = 400,000 바이트 . 400킬로바이트 사용 -&gt; 조금만 커져도 엄청 커진다. //분기문, 비교 할때 사용 //bool도 숫자로 메모리에 저장한다. bool bValue1 = true; bool bValue2 = false; cout &lt;&lt; bValue1 &lt;&lt; endl; cout &lt;&lt; bValue2 &lt;&lt; endl; char chValue = 'A'; cout &lt;&lt; chValue &lt;&lt; endl; cout &lt;&lt; (int)chValue &lt;&lt; endl; char chValue2 = 65; cout &lt;&lt; chValue2 &lt;&lt; endl; //float는 뒤에 f를 붙여줘야한다. float fValue = 3.141592f; double dValue = 3.141592; //뒤가 짤림 cout에서 자릿수를 맞춰준다. //실수는 정밀하지가 않다. cout &lt;&lt; fValue &lt;&lt; endl; cout &lt;&lt; dValue &lt;&lt; endl; //auto 데이터 타입을 자동으로 지정해준다. auto aValue1 = 3.141592; auto aValue2 = 3.141592f; cout &lt;&lt; aValue1 &lt;&lt; endl; cout &lt;&lt; aValue2 &lt;&lt; endl; //변수의 크기 출력 cout &lt;&lt; sizeof(aValue1) &lt;&lt; endl; cout &lt;&lt; sizeof(aValue2) &lt;&lt; endl; //데이터타입 크기 출력 cout &lt;&lt; sizeof(bool) &lt;&lt; endl; //변수 초기화 방법 3가지 //copy initializaion int a = 123; //direct initializaion 객체지향에서 많이 사용한다. int b(123); //uniform initializaion 객체지향에서 많이 사용한다. int c{123}; //실수에서 어떤 코드를 보더라도 당황하지 않게 여러가지 방법을 알아두자. //casting int d = 3.4; //자료형이 맞지않는경우 casting해준다. 3으로 초기화 //변수 동시 선언 //같은 데이터 타입끼리만 가능 int e, f, g; //변수를 언제 선언해야 하는가? //모든 변수는 위에 선언을 했어야햇다. //요즘엔 사용하기 직전에 선언하는것을 선호한다. //기능 부분에 있는 경우 리팩토링 할때 편하다. //디버깅 할때 편하다. }정수형// 정수형// Integers#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;limits&gt;using namespace std;int main() { //문자형 넽워크쪽 //최소크기인 1바이트 저장소 개념으로 사용한다. //최소 크기 //short 2바이트 //int 2바이트 / 요즘은 4바이트 //long 4바이트 //long long 8바이트 //정수 데이터 구조 int i = 1; //32비트 구조 //00000000 00000000 00000000 00000001 //맨앞 1비트는 부호에 사용 //양수 = 0, 음수 = 1 short s = 1; //2byte = 16bit = 2^16개 long l = 1; long long ll = 1; cout &lt;&lt; sizeof(short) &lt;&lt; endl; cout &lt;&lt; std::pow(2, sizeof(short)* 8 - 1 ) - 1 &lt;&lt; endl; //0표현 -1, 부호표시 -1 //자료형의 사이즈를 가져오는 함수 cout &lt;&lt; \"short max:\" &lt;&lt; std::numeric_limits&lt;short&gt;::max() &lt;&lt; endl; cout &lt;&lt; \"short min:\" &lt;&lt; std::numeric_limits&lt;short&gt;::min() &lt;&lt; endl; cout &lt;&lt; \"short lowest:\" &lt;&lt; std::numeric_limits&lt;short&gt;::lowest() &lt;&lt; endl; //min lowest 정수에서는 차이없음 //소수에서 차이가 생긴다. //자료형마다 사이즈 제한이 잇고 범위를 벗어나면 안된다. s = 32767; cout &lt;&lt; s &lt;&lt; endl; s = s + 1; cout &lt;&lt; s &lt;&lt; endl; //-32768 출력 overflow 발생 //2진수에서 1을 더해서 첫값인 -32768이 나온것 2를 더하면 -32767이 나온다. //음수에서도 동일 s = std::numeric_limits&lt;short&gt;::min(); s -= 1; cout &lt;&lt; s &lt;&lt; endl; cout &lt;&lt; sizeof(int) &lt;&lt; endl; cout &lt;&lt; sizeof(long) &lt;&lt; endl; cout &lt;&lt; sizeof(long long) &lt;&lt; endl; //다른 것들은 얼마가 나오나 실험해보자~~ 가보자~ 가보자~ //unsigned에서의 overflow 실험 해보자~ // unsigned int a = -1; cout &lt;&lt; a &lt;&lt; endl; //overflow 발생, 엉뚱한 숫자가 나옴 오류가 발생하지않음 그냥 빌드가 됨 int b = 20 / 4; int c = 22 / 4; cout &lt;&lt; \"b : \" &lt;&lt; b &lt;&lt; \", c : \" &lt;&lt; c &lt;&lt; endl; //둘다 5발생 //소수를 정수형으로 바꿔서 출력한다. 몫만 출력함 소수점 버림 실행 cout &lt;&lt; (float)c &lt;&lt; endl;}C++ 11 고정 너비 정수 (Fixed-width integers// 고정 너비 정수// Fixed-width integers#include &lt;iostream&gt;//#include &lt;cstdint&gt;using namespace std;int main() { //플랫폼 컴파일러마다 정수형의 크기가 다를 수 있다. //모든 곳에서 같은 크기를 지닌 것 //16비트인 크기를 가진 Int형 int16_t i(5); //int 지만 8비트는 문자형으로 취급한다. int8_t myint = 65; cout &lt;&lt; myint &lt;&lt; endl; //8비트 중에 가장 빠른 타입을 찾아줌 int_fast8_t fi(5); //적어도 64비트를 가지는 타입을 찾아줌 int_least64_t fl(5); //멀티 플랫폼에서 사용이 된다.}무치형 (void)// 무치형// Void Type#include &lt;iostream&gt;void func(){}int main() { //포인터 사용할때 사용한다. int i = 123; float f = 123.4567f; // void my_void; 사용불가 //주소를 뜻함 void *my_void; //&amp; 주소를 대입하는것? //포인터란? //데이터의 타입이 다르고 크기가 다르더라도 데이터 주소를 표현하는 데이터의 양은 동일하다?? //그래서 int float 서로 다른 자료형이지만 둘다 void로 캐스팅이 가능하다. my_void = (void*)&amp;i; my_void = (void*)&amp;f;}부동소수점수 floating point numbers//// main.cpp// 2.5//// Created by YdO_ObY on 2022/08/30.//// 부동소수점 수// Floating Point Numbers#include &lt;iostream&gt;#include &lt;iomanip&gt; //소수점 조정가능하게 해주는함수가 있는곳#include &lt;limits&gt;#include &lt;cmath&gt; //isnan 사용using namespace std;int main() { //소수점을 의미한다. //float 4byte //double 8byte //long double 8byte //요즘엔 double를 기본으로 사용한다. //숫자를 많이 다르는 경우엔 float로 사용한다. //주로 딥러닝 사용할때 float를 사용한다고 한다. //탬플릿을 사용하여 무엇이든지 실행이 되게끔할 수 있다. //구성 //부호 지수 가수 로 나뉜다. (이미지 첨부) //너무 복잡한데? 라고 생각 ㅋㅋㅋ // float f;// double d;// long double ld; cout &lt;&lt; sizeof(float) &lt;&lt; endl; cout &lt;&lt; sizeof(double) &lt;&lt; endl; cout &lt;&lt; sizeof(long double) &lt;&lt; endl; //double long double 같다. cout &lt;&lt; std::numeric_limits&lt;float&gt;::max() &lt;&lt; endl; cout &lt;&lt; std::numeric_limits&lt;double&gt;::max() &lt;&lt; endl; cout &lt;&lt; std::numeric_limits&lt;long double&gt;::max() &lt;&lt; endl; //표현할수았는 최소값이 절댓값 cout &lt;&lt; std::numeric_limits&lt;float&gt;::min() &lt;&lt; endl; cout &lt;&lt; std::numeric_limits&lt;double&gt;::min() &lt;&lt; endl; cout &lt;&lt; std::numeric_limits&lt;long double&gt;::min() &lt;&lt; endl; //부동소수점에서의 최소값을 보는방법 cout &lt;&lt; std::numeric_limits&lt;float&gt;::lowest() &lt;&lt; endl; cout &lt;&lt; std::numeric_limits&lt;double&gt;::lowest() &lt;&lt; endl; cout &lt;&lt; std::numeric_limits&lt;long double&gt;::lowest() &lt;&lt; endl; //초기화 하는 방법 float f(3.141592f); //자동으로 double로 바뀐다. f가 없으면 double d(3.141592); long double ld(3.141592); cout &lt;&lt; 3.14 &lt;&lt; endl; //e 10의 제곱을을 뜻한다 e-1 : 10^-1 cout &lt;&lt; 31.4e-1 &lt;&lt; endl; cout &lt;&lt; 31.4e-2 &lt;&lt; endl; cout &lt;&lt; 31.4e1 &lt;&lt; endl; cout &lt;&lt; 31.4e2 &lt;&lt; endl; //생길수있는 오류 //소수점 자릿수 정하는 함수 default 6 cout &lt;&lt; setprecision(16) &lt;&lt; endl; cout &lt;&lt; 1.0 / 3.0 &lt;&lt; endl; float f2(123456789.0f); // 10 significant digits 유효숫자 //유효숫자를 적게 잡으면 오류가 발생 cout &lt;&lt; setprecision(9); cout &lt;&lt; f2 &lt;&lt; endl; //123456792 출력 //정일도가 떨어지는 경우 발생 //요즘엔 그냥 크기가 큰 double을 사용해도 된다. //시간의 흐름에 있어서 double가 기본으로 갈수도있다. //성능이 점점 좋아지고있기 때문에 double d2(0.1); cout &lt;&lt; d2 &lt;&lt; endl; //0.1 출력 cout &lt;&lt; setprecision(17); cout &lt;&lt; d2 &lt;&lt; endl; //0.10000000000000001 출력 //부동소수점 범위가 커질수록 정확성에 의해 차이가 발생한다. //0.1에 가장 가까운수를 출력하게된다. //무서운것 cout &lt;&lt; setprecision(17); double d3(1.0); double d4(0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1); cout &lt;&lt; d3 &lt;&lt; endl; //1 cout &lt;&lt; d4 &lt;&lt; endl; //0.99999999999999989 //오차가 누적이 되어 이런 현상이 발생한다. //컴퓨터가 그렇게 정확하진 않다. //이렇게 작동한다는것을 기억해라. //한계가 발생한다. //숫자가 아닌 숫자? double zero = 0.0; double posinf = 5.0 / zero; double neginf = -5.0 / zero; double nan = zero / zero; cout &lt;&lt; posinf &lt;&lt; endl; cout &lt;&lt; neginf &lt;&lt; endl; cout &lt;&lt; nan &lt;&lt; endl; //이거 확인 방법 cout &lt;&lt; posinf &lt;&lt; \" \" &lt;&lt; isnan(posinf) &lt;&lt; endl; cout &lt;&lt; neginf &lt;&lt; \" \" &lt;&lt; isnan(neginf) &lt;&lt; endl; cout &lt;&lt; nan &lt;&lt; \" \" &lt;&lt; isnan(nan) &lt;&lt; endl; cout &lt;&lt; posinf &lt;&lt; \" \" &lt;&lt; isinf(posinf) &lt;&lt; endl; cout &lt;&lt; neginf &lt;&lt; \" \" &lt;&lt; isinf(neginf) &lt;&lt; endl; cout &lt;&lt; nan &lt;&lt; \" \" &lt;&lt; isinf(nan) &lt;&lt; endl; }불리언 자료형과 조건문 if// 불리언 자료형과 조건문 if#include &lt;iostream&gt;using namespace std;bool isEqual(int a, int b){ //비교 operator : == //두개가 같으면 ture bool result = (a == b); return result;}int main() { //boolean //조건문 사용할때 사용한다. //true(1) //false(0) //두가지로 구분된다. bool b1 = true; bool b2(false); bool b3{ true }; cout &lt;&lt; b1 &lt;&lt; endl; cout &lt;&lt; b2 &lt;&lt; endl; //true / false로 출력 하는 방법 cout &lt;&lt; boolalpha; cout &lt;&lt; b1 &lt;&lt; endl; cout &lt;&lt; b2 &lt;&lt; endl; //not operator : ! //반대값으로 바꿔주는 연산자 cout &lt;&lt; !b1 &lt;&lt; endl; cout &lt;&lt; !b2 &lt;&lt; endl; //and operator : &amp;&amp; //bool 연산 두개를 비교하여 하나의 bool로 바꿔준다. //둘다 true일때 true cout &lt;&lt; (true &amp;&amp; true) &lt;&lt; endl; //true cout &lt;&lt; (true &amp;&amp; false) &lt;&lt; endl; //false cout &lt;&lt; (false &amp;&amp; true) &lt;&lt; endl; //false cout &lt;&lt; (false &amp;&amp; false) &lt;&lt; endl; //false //or operator : || //둘중 하skaks true면 true cout &lt;&lt; (true || true) &lt;&lt; endl; //true cout &lt;&lt; (true || false) &lt;&lt; endl; //true cout &lt;&lt; (false || true) &lt;&lt; endl; //true cout &lt;&lt; (false || false) &lt;&lt; endl; //false //조건문 if 예습 if(false) cout &lt;&lt; \"This is true\" &lt;&lt; endl; else cout &lt;&lt; \"This is false\" &lt;&lt; endl; //true //This is true //false //This is false //if안의 bool타입이 true일경우에 실행된다. //게임의 경우 //체력이 0인경우 죽는다 아니면 체력이 단다.. 라고 조건문 사용 //예시 작성 한번해보자 //bool을 리턴 타입으로도 많이 사용한다. cout &lt;&lt; isEqual(1, 1) &lt;&lt; endl; //true cout &lt;&lt; isEqual(0, 3) &lt;&lt; endl; //false //if안에 숫자를 넣어 사용가능 //0이면 flase, 0외의 것은 true if(5) cout &lt;&lt; \"True\" &lt;&lt; endl; //이거 출력 else cout &lt;&lt; \"False\" &lt;&lt; endl; if(0) cout &lt;&lt; \"True\" &lt;&lt; endl; else cout &lt;&lt; \"False\" &lt;&lt; endl; //이거 출력 //입력 할때 true / false 로 입력하면 안된다. //0 or 1로 넣어야한다. //위험성이 있는 코드는 사용하면 안된다. //이 방식은 문제가 발생할 수 있는 방식 bool b; cin &gt;&gt; b; cout &lt;&lt; \"your input : \" &lt;&lt; b &lt;&lt; endl; //quest: 정수 하나입력 받고 홀수인지 짝수인지 출력하는프로그램 만들어보기 }문자형 char type// 문자형#include &lt;iostream&gt;#include &lt;limits&gt;using namespace std;int main() { //문자를 숫자로 표현하는 방법 //아스키 테이블로 정해져잇다. //아스키 코드 테이블 확인 char c1(65); char c2('A'); //한글자 '' , 문자열 \"\" 사용 C++ std::string 도 문자열 사용 //출력시 문자로 출력 cout &lt;&lt; c1 &lt;&lt; \" ,\" &lt;&lt; c2 &lt;&lt; \" ,\" &lt;&lt; (int)c1 &lt;&lt; \" ,\" &lt;&lt; (int)c2 &lt;&lt; endl; //char c casting 방법 cout &lt;&lt; (char)65 &lt;&lt; endl; cout &lt;&lt; (int)'A' &lt;&lt; endl; //cpp style casting cout &lt;&lt; char(65) &lt;&lt; endl; cout &lt;&lt; int('A') &lt;&lt; endl; //강제 변환반식들 위에는 //casting 방식에는 두가지 존재 dynamic static //기본타입들 간의 변환일때 컴파일러에게 검사한번 받고 빌드 cout &lt;&lt; static_cast&lt;char&gt;(65) &lt;&lt; endl; cout &lt;&lt; static_cast&lt;int&gt;('A') &lt;&lt; endl; char ch(97); cout &lt;&lt; ch &lt;&lt; endl; cout &lt;&lt; static_cast&lt;int&gt;(ch) &lt;&lt; endl; cout &lt;&lt; ch &lt;&lt; endl; //static casting을 해도 원래 변수가 바뀌진 않는다. // cin &gt;&gt; c1;//// cout &lt;&lt; c1 &lt;&lt; \" \" &lt;&lt; static_cast&lt;int&gt;(c1) &lt;&lt; endl;//// //두글자 이상 입력시 첫글자만 출력// //나머지 데이터는 사라지지않고 버퍼에 가지고있는다.// //다음 cin에서 그 나머지 처리를한다.////// cin &gt;&gt; c1;//// cout &lt;&lt; c1 &lt;&lt; \" \" &lt;&lt; static_cast&lt;int&gt;(c1) &lt;&lt; endl;// //abc 입력시 a출력후 b 바로 출력 //크기 출력 cout &lt;&lt; sizeof(char) &lt;&lt; endl; //이상한값 출력함; cout &lt;&lt; numeric_limits&lt;char&gt;::max() &lt;&lt; endl; cout &lt;&lt; numeric_limits&lt;char&gt;::lowest() &lt;&lt; endl; //모든 아스키코드를출력 할수없다. cout &lt;&lt; (int)numeric_limits&lt;char&gt;::max() &lt;&lt; endl; cout &lt;&lt; (int)numeric_limits&lt;char&gt;::lowest() &lt;&lt; endl; cout &lt;&lt; sizeof(unsigned char) &lt;&lt; endl; cout &lt;&lt; (int)numeric_limits&lt;unsigned char&gt;::max() &lt;&lt; endl; cout &lt;&lt; (int)numeric_limits&lt;unsigned char&gt;::lowest() &lt;&lt; endl; cout &lt;&lt; \"This is first line \\nsecond line \\n\"; cout &lt;&lt; \"This is first line\" &lt;&lt; endl; cout &lt;&lt; \"second line\" &lt;&lt; endl; //ascii 10번 = new line cout &lt;&lt; int('\\n') &lt;&lt; endl; //\\n과 endl의 차이 //\\n //줄바꿈 //endl //줄바꿈을 하고 버퍼에 있는 내용을 다 출력해라 라는 명령어 //std::flush //줄바꿈을 안하고 버퍼에 있는것을 출력하는 명령어 cout &lt;&lt; \"This is first line \\tsecond line \\n\"; //ascii 9번 = tab cout &lt;&lt; int('\\t') &lt;&lt; endl; //특수문자 출력방법 cout &lt;&lt; \"\\\"\" &lt;&lt; endl; //윈도우에서 사용 //요즘에는 사용 안하는 추세이다. wchar_t c; //이모티콘 등에서 사용 char16_t c16; char32_t c32; cout &lt;&lt; \"\\u4444! \\n\"; //ascii표에 있는 여러가지 문자들을 cin/cout으로 입출력해보자! }리터럴 상수 literal constants// 리터럴 상수#include &lt;iostream&gt;using namespace std;int main() { //상수 변하지 않는 숫자 //변수 값은 바꿀수 있다. float pi = 3.14f; //u = unsigned int i = -1234u; //명확하게 표시하기위해 숫자 뒤에 표시할 수 있다. unsigned int n = 5u; long n2 = 5L; double d = 6.0e-10; //10진수 Decimal //0 1 2 3 4 5 6 7 8 9 -&gt; 10 11 12 //8진수 Octal //0 1 2 3 4 5 6 7 -&gt; 10 11 12 //숫자 앞에 0을 붙인다. int x = 010; cout &lt;&lt; x &lt;&lt; endl; //16진수 Hexa //0 1 2 3 4 5 6 7 8 9 A B C D E F -&gt; 10 int y = 0xF; cout &lt;&lt; y &lt;&lt; endl; //8진수 16진수 많이 사용한다. //오픈소스에서 사용할때 알아봐야하니까 중요하다. //2진수로 쓰면 길어지는데 16진수로 바꾸면 짧아지므로 많이 사용한다고 한다. //C++ 14부터 2진수 사용가능 int z = 0b1010; cout &lt;&lt; z &lt;&lt; endl; //이진수가 길어질경우 '를 사용하여 구분가능 //컴파일러가 '는 무시한다고한다. //인용부호 따옴표 int z1 = 0b1111'1010'1011'0101; cout &lt;&lt; z1 &lt;&lt; endl; //코딩하다 보면 상수를 코드에 넣어두는 경우가있는데 //상수를 바로 적지 말고 //magic number : 연산에 숫자를 바로 적은 숫자 //하드코딩식으로 리터럴로 작성하면 안좋다. int num_items = 10; int price = num_items * 10; const int price_per_item = 10; int price2 = num_items * price_per_item; }심볼릭 상수 symbolic constants// 심볼릭 상수#include &lt;iostream&gt;#include \"my_constants.h\"//C에서는 매크로로 사용하지만 cpp에선 잘 사용하지 않는다.//상수를 대체하기위한 매크로는 사용하지 않는다.//디버깅이 힘들다.//define은 파일전체에 영향을 끼친다.//적용 범위가 너무 넓어진다.#define PRICE_PER_ITEM 30;using namespace std;//const는 파라미터에서도 많이 사용한다.//특별하지 않는한파라미터 값을 바꾸지않는다.//함수 안에서 파라미터 값을바꾸면 입출력을 명확하게 보여주지 못하는 방식이라 거의 안바꾸지만//바꾸고 싶다면 안에서 변수를 지정하여 변경한다.//&amp;레퍼런스로 파라미터를 가져오는 경우도 많다.void printNumber(const int&amp; my_number){ cout &lt;&lt; my_number &lt;&lt; endl;}int main() { //변하지 않는 상수 const double gravity{9.8}; //값을 바꾸지 못한다. //고정된 숫자를 사용할때 사용한다. //이렇게도 사용가능 double const dd{1.2}; //일반적으로 앞에것을 사용한다. //const는 초기화로 사용한다. 해야한다. printNumber(123); //컴파일 타입 상수 const int my_const(123); int number; cin &gt;&gt; number; //입력을 받아 const값으로 사용할 수 있다. //런타임 타입 상수 const int special_number(number); //number는 바뀔수잇지만, special_number는 바꾸지 못한다. //special_number는 프로그램 실행후 입력을 받고 나서 결정 된다. //C++ 11 이후 //컴파일 타입의 상수를 확인하는 변수 constexpr int num1(123); // constexpr int num1(number); //사용 불가 int num_items = 123; const int price_per_item = 30; int price1 = num_items * PRICE_PER_ITEM; //매크로로 사용 int price2 = num_items * price_per_item; //const 사용 //const 표기법 //물리엔진과 같은 특별한 경우빼곤 없다. //const는 한번에 몰아 넣는경우가 많다. //헤더 파일을 만들어서 필요한 상수를 모아서 작성해서 관리한다. //재사용 가능한 변수들이라 한곳에 몰아넣고 수정사항이 생길때 헤더파일에서 그것만 건들면 모두다 적용이 되어 좋다. double radius; cin &gt;&gt; radius; double circumference = 2.0 * radius * constants::pi; }#pragma oncenamespace constants{ constexpr double pi(3.141592); constexpr double earth_gravity(9.807); constexpr double moon_gravity(1.62);}" }, { "title": "[C++] Chapter.1 C++의 기초적인 사용법", "url": "/posts/Cpp-Ch1/", "categories": "Language, C++", "tags": "c++", "date": "2022-08-26 22:13:42 +0900", "snippet": "프로그램의 구조용어 표현식 Expressions 명령문 Statements 함수 Functions 라이브러리 Library 표준 라이브러리 Standard Library프로그램을 실행한다는것 이란?Operation Sytem(운영체제, OS)에 요청 하는 행위이다.OS한테 코드를 작성한 코드를 던지면서 실행 해줘! 부탁하는 것이다.자신(OS)이 사용 할 수 있는 CPU, Memory를 사용하여 실행이 되는 것이다.함수무언가를 넣어서 결과값을 도출하는 것main 함수명은 변경 불가os가 프로그램을 시작할때 main 함수를 찾는다.함수 기본 형태int main(void){ return 0;}빈줄 빈칸 컴파일러가 무시한다.main함수명int 출력부분인티저의 약자출력물의 자료형을 적는부분{}함수의 몸체기능 구현부분returnOS에게 함수의 끝을 알리는 부분OS에게 함수의 결과물을 전달하는 부분기능을 수행하는 코드를 Statement라고 부른다.;문장의 끝을 표시절대로 뺴먹어서는 안되는것없으면 Error 발생()함수에 들어가는 값을 넣는 부분1+2 * 3+4 익스프레션?int x;변수 선언 방식정수형 변수를 선언#include &lt;iostream&gt;iostreamio input output stream# &lt;-전 처리기 preperocessor directiveint main(){ int x = 2; // (2,3,5)리터럴 literal / x,y 변수 x = 5; //변수 int y = x + 3; std::cout &lt;&lt; y &lt;&lt; std::endl; //namespace??에 관한 내용 :: namespace에 접근 가능하게 하는 연산자 &lt;&lt; outer operator? 연산자중 하나 return 0;}std » 표준 라이브러리의 일부iostream표준 라이브러리 - 정해진 형식으로 만들어진 것라이브러리 - 자주쓰는것을 묶어서 모아놓은것표현식과 명령문의 차이?함수와 라이브러리의 차이?C++에서 문장을 끝내는 기호?문법 오류란?주석 comments주석컴파일러가 코드를 무시하게 만드는 것//한줄 주석 처리/*8/영역 주석 처리영역 안에 처리를 하면 안된다.메모용으로 자주 이용한다.프로그램 전체 설명 - 무엇인지 설명함수 구현 부 - 구현이 왜 되어야하는지, 방식 등등코드 단위 - 기능 구현 방식, 변수명을 적음;적어야하는 부분만 적자..다적으면 불필요한것만 늘어나고 읽어야하는부분만 늘어난다.직관적인 경우엔 주석 사용 하지말아라변수와의 첫 만남객체 objects현실에서 존재하는 물체메모리에 저장되어있는 정보 = 객체로서 존재한다.변수 variables메모리에 담긴 객체의 이름, 핸들Left-values , Right-values메모리 주소 접근 유무에 따라 구분가능초기화 initialization대입 assignment초기화를안했을때의 문제점입출력 스트림과의 첫만남 (cin,cout)#include &lt;iostream&gt; //cout, cin, endlint main(){// cin console in// cout console out// endl end line //문자열 출력 방법 std:: cout &lt;&lt; \"Test\" &lt;&lt; std:: endl; int x = 1024; float y = 3.141592; std:: cout &lt;&lt;\"x is \"&lt;&lt; x &lt;&lt; std::endl; std:: cout &lt;&lt;\"y is \" &lt;&lt; y &lt;&lt; std::endl; //3.14159 까지 출력; 정밀도 개념필요 나중에 나옴 //tab 빈공간에 줄맞춤을 하기위한 연산자 \\t std::cout &lt;&lt; \"abc\" &lt;&lt; \"\\t\"&lt;&lt; \"def\" &lt;&lt; std::endl; std::cout &lt;&lt; \"ab\" &lt;&lt; \"\\t\"&lt;&lt; \"cdef\" &lt;&lt; std::endl; //new line - endl과 거의 비슷한 기능조금의 차이가 있다. std::cout &lt;&lt; \"\\n\"; //std:: 적기 싫을때 //네임스페이스를 사용하여 무시가능 using namespace std; //경고음 출력 cout &lt;&lt; \"\\a\"; //문자 입력 방법 //저장 변수선언 int z = 1; cout &lt;&lt; \"value : \" &lt;&lt; z &lt;&lt; endl; //입력 cin &gt;&gt; z; cout &lt;&lt; \"input value : \" &lt;&lt; z &lt;&lt; endl; //엄청 큰값을 넣으면 최댓값 출력함 //입력 유효성 검증 필요 }함수와의 첫만남//함수와의 첫 만남#include &lt;iostream&gt;using namespace std;//함수 네이밍은 정확하게 자세하게 적는것이 좋다.int addTwoNumbers(int num_a, int num_b){ int sum = num_a + num_b; //함수 명 앞의 int 와 출력 값의 형태가 같아야한다. //함수 출력 형태 :int //리턴값 sum의 형태 :int return sum;}//매개변수 num_a , num_bint multiplyTwoNumbers(int num_a, int num_b){ int sum = num_a * num_b; //함수 명 앞의 int 와 출력 값의 형태가 같아야한다. //함수 출력 형태 :int //리턴값,반환값 sum의 형태 :int return sum;}void printHelloWorld(void){ cout &lt;&lt; \"Hello World!\" &lt;&lt; endl;// return 0; 해도되고 안해도 되고 //return을 만나면 종료한다.}void printHello() //void 써도 안써도 ㄱㅊ{ cout &lt;&lt; \"Hello\" &lt;&lt; endl; //함수안에서 다른 함수 호출가능 printHelloWorld(); //함수안에 함수를 정의는 못한다.}int main(){ //함수 function //리턴값 return values //매개변수 parameters //인수 arguments int x = 0; cout &lt;&lt; 1 + 2 &lt;&lt; endl; //함수 호출부분 //인수 1, 2 cout &lt;&lt; addTwoNumbers(1, 2) &lt;&lt; endl; x = addTwoNumbers(100, 11); cout &lt;&lt; addTwoNumbers(3, 4) &lt;&lt; endl; cout &lt;&lt; multiplyTwoNumbers(3, 4) &lt;&lt; endl; //하나의 패턴이 여러번 나오는경우 함수를 만든다. //재사용이 가능하다. //함수도 메모리안에 저장이된다. printHello(); printHelloWorld(); }키워드와 식별자 이름짓기#include &lt;iostream&gt;using namespace std;//함수 이름은 대문자로 시작한다.//모든 기능을 설명하기 힘들면 짧게 짓고 주석으로 설명을 달아놓는다.void MyFunction(){}int main(){ //식별자 identifier //변수 객체 함수 이름 모두다 말하는거 메모리주소; 개발자가인식할수있는 이름으로 바꿔주는것 //기술보단 센스에 가깝다. //실력이 늘수록 늘어난다. //예약어 reserved keyword //함수, 변수,클래스, 객체 이름으로 사용할 수 없다. //함수를 main으로 만들수 없다. //reserved keyword처럼 작동한다. //int 1name; //변수명은 숫자로 시작하지못한다. //길지많으면서 의미를 충분히 담을수있는 정도로 작성한다. //int number_apples -&gt; int n_apples //명칭에는 빈칸이 존재하지않는다. //빈칸은 _로 대체하여 사용한다. //int number apples -&gt; int number_apples //대문자는 대문자로 거의 만들지않는다. //매크로에서 많이 사용하여서 매크로랑 헷갈리는 경우가 발생할 수 있어서 소문자로 작성한다. //_를 붙이는 경우 //클래스 멤버변수에 사용을 많이한다. //모든 것이 정답은 아니고 속도 개발자가 편한게 최고다. //회사마다 작성방법이 정해져있으므로 회사에 따라 달라진다.}class MyClass{public: int m_variable;}지역범위#include &lt;iostream&gt;using namespace std;int main(){ int y = 0; cout &lt;&lt; y &lt;&lt; \", \" &lt;&lt; &amp;y &lt;&lt; endl; //영역분리 { int y = 1; cout &lt;&lt; y &lt;&lt; \", \" &lt;&lt; &amp;y &lt;&lt; endl; } //영역분리 { int y = 2; cout &lt;&lt; y &lt;&lt; \", \" &lt;&lt; &amp;y &lt;&lt; endl; } { //이미 메모리공간이 존재하는 경우 해당 메모리를 사용한다. y = 2; cout &lt;&lt; y &lt;&lt; \", \" &lt;&lt; &amp;y &lt;&lt; endl; } //중광호 안의 변수는 중괄호를 벗어나면 사라지게된다. 중괄호를벗어나면 사용불가. //중괄호를 벗어나는 순간 stack 메모리로 반납되어 사라진다. //반납된 메모리는 다음지역변수가 사용할수있도록 대기한다. cout &lt;&lt; y &lt;&lt; \", \" &lt;&lt; &amp;y &lt;&lt; endl; int x = 0; //x를 0으로 초기화 cout &lt;&lt; x &lt;&lt; \", \" &lt;&lt; &amp;x &lt;&lt; endl; return 0;}연산자와의 첫 만남#include &lt;iostream&gt;using namespace std;int main(){ //리터럴 Literal //피연산자 Operand //단항 unary //이항 binary //삼항 ternary //x is variable , 2 is a literal int x = 2; //x를 2로 초기화 //Test is literal cout &lt;&lt; \"Test\" &lt;&lt; \"\\n\"; //1,2 is literal //1 + 2 is expressions cout &lt;&lt; 1 + 2 &lt;&lt; \"\\n\"; //+ is operator //x, 2 is operand //= is assignment cout &lt;&lt; x + 2 &lt;&lt; \"\\n\"; //연산자는 +,-,*,/ 등등 많다. //피연산자가 2개인 경우 이항연산자 //삼항 연산자 int y = (x &gt; 0) ? 1 : 2; //x가 0보다크면 1, 작으면 2 //괄호안이 참이면 왼쪽, 거짓이면 오른쪽 대입 cout &lt;&lt; y &lt;&lt; endl; }기본적인 서식 맞추기#include &lt;iostream&gt;using namespace std;//int add (int x, int y){return x+y;}int main(){ //프로그래머의 효율을 좋게 하기 위해 중요하다. //ide마다 자동으로 맞춰준다. //tab 들여쓰기 = indenting 빈칸 만드는 행동 //문자열의 빈칸은리터럴이고, 그외의 빈칸은컴파일러가 무시한다. //하드코딩 //변수값을 리러럴같이 고정된 값으로 직접 대입해주는방식 //소프트 코딩 //프로그램에서 사용자의 입력이나 외부파일, 인터넷통신을 통하여 데이터를 가져오는 방식 int my_v = 1; int x = 4; int num_apples = 123; //코드를 볼때 잘 보이게만 작성하면 된다. //눈에 보기 쉽게 잘읽히게}선언과 정의의 분리//Declaration 선언//Definition 정의#include &lt;iostream&gt;//함수가 어떤 기능할지 최소한의 정보를 먼저 알려준다.int add(int a , int b); //forward declaration, 전방 선언int multiply(int a , int b);int subtract(int a , int b);using namespace std;int main(){ //함수가 여러 가지가 되는 경우 사용한다. //컴파일러는 순차적으로 읽어서 main아래에 함수를 정의하면 에러발생. cout &lt;&lt; add(1, 2) &lt;&lt; endl; cout &lt;&lt; subtract(1, 3) &lt;&lt; endl;}// definitionint add(int a , int b){ return a + b;}int multiply(int a , int b){ return a * b;}int subtract(int a , int b){ return a - b;}헤더파일 만들기//헤더 파일 만들기//파일 쪼개기 , 헤더 만들기#include &lt;iostream&gt;#include \"functions.h\"// \\&lt;\\&gt; \"\" 차이는?//int add(int a , int b); //cpp의 함수 선언using namespace std;int main(){ //한파일 안에 함수가 많아지면 코드가 길어진다. //파일 하나 읽기가 힘들어짐. //파일을 쪼개서 보면 코드가 짧아진다. //주로 비슷한 기능들을 하는것을 묶어서 관리 //객체지향 클래스에서 사용한다. //cpp파일을 하나 만들어서 거기에 함수를 정의한다. //분리 이유 : 재사용을 하기위해 cout &lt;&lt; add(1, 2) &lt;&lt; endl; return 0;}//header#pragma once //전처리기 일종중 하나int add(int a , int b);//헤더에 몸체까지구현해도 되나 가급적 cpp로 나누는게 좋다.//cppint add(int a , int b){ return a + b;}헤더 가드가 필요한 이유//헤더가드#include &lt;iostream&gt;#include \"functions.h\"#include \"test.h\"using namespace std;int main(){ //헤더가드 사용이유: 링킹에러 doSomething(); //add 프로토타입만 잇으면 실행은되는데 몸체가 없으면 링킹에러 발생한다. //include 교체하는 개념 //include가 두번되면 오류가 발생한다. //중복되는경우 한번만 include 해주는것이 헤더가드이다. }//test.h//#pragma once#include \"functions.h\"void doSomething(){ add(1, 2);}functions.h#pragma once //전처리기 일종중 하나int add(int a , int b){ return a + b;}//헤더에 몸체까지구현해도 되나 가급적 cpp로 나누는게 좋다.//현실적으로 개발하면서 수정 추가 하다보면 헤더에 몸체를 구현하는 경우가 많이 발생한다.//이것이 문제가 될수도잇는데 이것을 막아주는게 헤더가드이다.#ifndef functions_h#define functions_h#endif /* functions_h */표준 방식#pragma onde표준방식은 번거러우니 한줄만 적자둘다 같은 방식네임스페이스(명칭 공간)#include &lt;iostream&gt;namespace MySpace{ int doSomething(int a, int b) { return a + b; } namespace InnerSapce { int func() { return 0; } }}namespace MySpace2{ int doSomething(int a, int b) { return a + b; }}using namespace std;int main(){ //어떤 경우에 사용하는가? //동일 이름의 함수가 존재해야하는 경우 //namespace 내부 함수 접근 방법 cout &lt;&lt; MySpace::doSomething(1, 2) &lt;&lt; endl; cout &lt;&lt; MySpace2::doSomething(1, 2) &lt;&lt; endl; MySpace::InnerSapce::func(); using namespace MySpace; cout &lt;&lt; doSomething(1, 2) &lt;&lt; endl;}전처리기와의 첫 만남//// main.cpp// 1.14//// Created by YdO_ObY on 2022/08/30.////전처리기와의 첫 만남//Preprocessor#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;//매크로 거의 대문자를 사용한다.//교체 개념#define MY_NUMBER 9#define MY_STR \"Hello, World\"#define MAX(a, b) ((a&gt;b) ? a : b)//매크로로 배열 사이즈를 선언하지만 실제로는 잘 사용하지않는다.//매크로는 하드코딩과 퍼포먼스가 같다.//요즘엔 함수로 처리를 한다.//선언한 파일 안에서만 사용가능#define LIKE_APPLE//전처리기//빌드 할때 정해진다.//프로그램 실행기 운영체제 결정할때 사용한다.//그래픽카드 사양 결정할때 사용한다.//멀티 플랫폼 개발할때 많이 사용한다.void doSomething();int main(){ cout &lt;&lt; MY_NUMBER &lt;&lt; endl; cout &lt;&lt; MY_STR &lt;&lt; endl; cout &lt;&lt; MAX(1, 2) &lt;&lt; endl; //algorithm파일에 max함수가 존재 cout &lt;&lt; max(100, 99) &lt;&lt; endl; //매크로 정의 유무 사용 가능#ifdef LIKE_APPLE cout &lt;&lt; \"Apple\" &lt;&lt; endl;#endif #ifndef LIKE_APPLE cout &lt;&lt; \"Orange\" &lt;&lt; endl;#endif #ifdef LIKE_APPLE cout &lt;&lt; \"Apple\" &lt;&lt; endl;#else cout &lt;&lt; \"Orange\" &lt;&lt; endl;#endif doSomething(); return 0; }//test.cpp#include &lt;iostream&gt;void doSomething(){ using namespace std;#ifdef LIKE_APPLE cout &lt;&lt; \"Apple\" &lt;&lt; endl;#endif #ifndef LIKE_APPLE cout &lt;&lt; \"Orange\" &lt;&lt; endl;#endif}" }, { "title": "[C++] Chapter.0 시작해봅시다.", "url": "/posts/Cpp-Ch0/", "categories": "Language, C++", "tags": "c++", "date": "2022-08-25 23:11:30 +0900", "snippet": "C/C++ 꼭 공부해야할까?가장 기본적인 언어이므로 배워야한다.좋은 예술가는 베낀다. 위대한 예술가는 훔친다.일단 코드를 배끼면서 공부해라! 그래야 쌓이고 쌓이면서 좋은 프로그래머가 될수있다.공부 방법 올바른 타이핑 방법을 연습한다. 간단한 개념을 이해한다. - 개념을 이해해야지 나중에 큰것을 볼수있다. 예제를 따라 해본다. - 직접 손으로 따라해보고 익숙해져야한다. 문제가 생기면 해결한다. 예제를 내 맘대로 바꿔본다.프로그래밍 언어란?프로그램(Program) : 컴퓨터가 사용자가 원하는 기능을 수행하도록 만들어주는 것어플리케이션(Application) : 프로그램과 동일, 주로 모바일 환경에서 사용하는 용어소프트웨어(Software) : 프로그램과 동일, 주로 하드웨어와 비교할때 사용하는 용어하드웨어(Hardware) : 컴퓨터의 기계적인 부분기계어 (Machine Language)컴퓨터와 의사소통하기 위한 언어전자회로 방식 - 전압의 차이(Low / High), (0 / 1)로 구분하여 인식한다.어셈블리언어(Assembly Language)CPU의 단위기능을수행, 메모리의 정보를 직접적으로 제어하는 저수준의 언어고수준 언어(High-Level Language)C,C++, JAVA, Python 등등 흔히 알고있는 언어하드웨어 접근하기 좋은 언어 = Low Level Languge사람에게 좀더 가까운 언어 = High Level Language컴파일러(Compiler)내가 만든 코드를 기계어로 바꾸는 역할을 하는 도구실행 파일을 만들어주는 역할C/C++은 컴파일을 하게 될 경우 실행파일 생성생성파일을 CPU를 통하여 실행코드 - 컴파일러 - 실행파일 생성 - CPU - 실행 결과 출력인터프리터(Interpreter)컴파일과 비슷하지만, 달리 실행파일을 만들지 않고 바로 CPU를 통하여 실행실행 파일을 안만들어서 컴파일러보다 빠르다 생각이 들지만 실질적으로는 느림같은 코드를 반복적으로 실행하는 경우 실행파일이 없어 시간이 오래 걸림스크립트 - 인터프리터 - CPU - 실행 결과 출력이식성(Portability)컴파일러 언어 - 운영체제마다 컴파일러가 달라 호환성을 따져가져 개발해야함.자바 - JVM을 사용하여 운영체제 간의 호환성이 좋은편C/C++ 언어 소개C Language - Dennis Ritchie 1970년대 개발어셈블리 언어 개발에서 C언어 개발C++ Language - Biarne StroustrupC언어에서 객체지향 개념이 확장된 언어C/C++ 언어의 설계 철학 실제 세계에서 쓸모가 있어야한다. 프로그래머가 스스로 스타일을 선택할 수 있어야한다. 유요한 기능을 추가하는 것이 오용보다 더 중요하다. 프로그래머의 의도를 알 수 없다면 스스로 명시하게 한다. C++ 아래에 다른 언어는 없다.현재, 다양하게 발전하는 현대의 입장에서는 양날의 검이라 생각할 수 있다.프로그래밍 과정 소개 풀어야 할 문제를 정의한다. 해법을 설계한다. 해법을 구현하는 프로그램을 작성한다. 프로그램을 컴파일한다. 오브젝트 파일들을 링킹한다. 테스트해보고 문제가 있으면 고친다.컴파일 과정ex)g++ c- file1.cpp file2.cpp file3.cpp=&gt;g++(compiler) -c(compile 명령어) file1,2,3을 컴파일하여라.소스파일(.cpp) -&gt; compile -&gt; 오브젝트파일(.o/.obj)file1,2,3(.cpp) -&gt; file1,2,3(.obj)링커를 통하여 오브젝트 파일들을 합쳐 실행 파일로 만든다.file1.obj + file2.obj + file3.obj = project.exeexe 파일을 실행하여 결과물 확인후, 버그 수정컴파일 방식 / 모드 (IDE)Build = compile에 linking을 합한 행위Debug mode - 디버깅 도구 포함 &gt; 파일 용량이 커짐Release mode - 디버깅 도구 미포함 &gt; 파일 용량이 작아짐 &gt; 사용자에게 배포하기 위하여 디버깅 도구를 포함하지 않는다.처리속도가 Release가 더 빠르다.코딩하다 막혔을 때는?당황하지 말고 분노하지 말자!그냥 검색하면서 해결하면 그만이야나의 좋은 친구 Google에게 물어보자이번강의 용어정리기계어어셈블리 언어고수준 언어컴파일러인터프리터이식성오브젝트 파일소스파일링커DebugRelease" }, { "title": "[GitHub Pages] 블로그에 포스팅 하는 방법", "url": "/posts/blog-posting/", "categories": "GitHub, GitHub Pages", "tags": "github pages, jekyll, chripy", "date": "2022-08-23 00:41:30 +0900", "snippet": "블로그도 잘 만들어졌겟다. 이제 글을 작성하는법을 알아보려한다.공식 문서에 설명이 잘 되어있지만 정리 할겸 포스팅은 남겨본다.파일생성_post안에 파일을 생성해야하며, 파일 이름은 YYYY-MM-DD-TITLE.md형식으로 생성을 해주어야한다.공백이 존재하면 안된다.ex)2022-01-01-first-blog-post.md파일을 생성하고 로컬서버에서 확인하면 글이 작성 된것을 확인 할수있다.머리말 양식머리말을 추가하여 제목, 작성날짜, 카테고리, 태그를 추가할 수 있다.---title: Titledate: YYYY-MM-DD HH:MM:SS +/- TTTTcategories: [Category1, Category2] # 최대 2개까지 가능tags: [tag1, tag2] # 제한없음, 소문자로 작성 authors: username # _config.yml의 social.name 설정시 필요없음---ex)title: 블로그 첫 포스팅date: 2022-08-23 11:11:11 +0900categories: [GitPages, Jekyll]tags: [tag1, tag2]목차게시물의 오른쪽에 보이는 것이다.스크롤에 위치에 따라 현재 위치를 보여준다.목차생성 방법## 목차### 하위 목차명이렇게 생성할수있다.하나의 목차에 하위 목차가 여러개 존재할 수 있다.목차 설정목차를 on/off가 가능하다.전역 설정_config.yml파일의 toc을 false로 변경하면 모든 게시물에 목차가 안보이게 된다.특정 게시물 설정---toc: false # default: true---주의사항## 1.목차 처럼 목차 이름이 숫자로 시작하게되면 목차가 안먹힌다.게시물 고정목록에서 게시물을 고정할때 사용고정 게시물이 하나 이상일때 시간의 역순으로 정렬된다.사용법---pin: true---" }, { "title": "[GitHub Pages] Chirpy Thema 구성 파악", "url": "/posts/chripy-structure/", "categories": "GitHub, GitHub Pages", "tags": "github pages, jekyll, chripy", "date": "2022-08-21 23:31:15 +0900", "snippet": "이번에는 Chirpy Thema 구성파악을 해보려한다.프로젝트 디렉토리를 열거나 터미널에서 ls 명령어를 사용하여 프로젝트에 무엇이 들어있는지 확인 해본다._data _includes _javascript _layouts _plugins _posts _sass _site _tabs assets tools현재 Chirpy를 구성하는 소스들을 종류별로 모아 놓은 것이다.환경설정과 커스텀마이징을 위하여 소스 기능들을 설명하려 한다._data구성 요소 : 왼쪽 사이드의 버튼들을 구성하는 소스, 언어구성 소스 [yml]변경 요소 : 버튼 구성 변경, 언어 변경 등 수정가능_include구성 요소 : UI를 구성하는 소스 [html]변경 요소 : sidebar, topbar, footer 등등_javascript구성 요소 : UI의 기능 구현 소스 [js]변경 요소 : js를 잘 알지 못한다면, 수정하지 않는 것을 추천한다._layouts구성 요소 : include와 마찬가지로 UI를 구성하는 소스[html]변경 요소 : 글양식, 태그, 카테고리 구성 등등_plugins구성 요소 : 사이트 생성에 필요한 ruby 소스[rb]변경 요소 : X_posts구성 요소 : 사용자가 업로드할 글들을 저장하는 곳변경 요소 : 글 작성할때마다 여기에 저장하면 알아서 적용_sass구성 요소 : UI의 디자인을 구성하는 소스 [scss]변경 요소 : 디자인 구성_site구성 요소 : 프로젝트를 빌드하면 생기는 작업물 자체, 로컬에서만 사용변경 요소 : 변경된 프로젝드가 빌드되면 변경, gitignore에 포함 되어있어 git에는 배포가 되지 않음._tabs구성 요소 : 사이드 바의 메뉴들의 랜딩 페이지 표시 변경 요소 : 버튼 순서, 아이콘 변경 가능assets구성 요소 : 이미지 파일변경 요소 : 사용하고 싶은 이미지 파일 넣어놓고 사용tools앞에서 초기화랑 로컬서버실행할때 사용해보았다.구성 요소 : 프로젝트 초기화, 배포, 릴리즈, jekyll 로컬 서버 열기 를 실행 해주는 shell 파일변경 요소 : 사용시 오류가 난다면 구글링해서 원인이 무엇인지 찾고 왠만하면 수정하지말자일단 구성만 어떤식으로 되어있는지만 파악하고 자세하게는 나중에 구성을 바꾼다던가 하는마음이 생기면 그때 포스팅을 해야겠다.다음에는 글쓰는 방법을 포스팅 하려한다." }, { "title": "[GitHub Pages] Jekyll Thema 적용방법", "url": "/posts/apply-jekyll-thema/", "categories": "GitHub, GitHub Pages", "tags": "github pages, jekyll", "date": "2022-08-17 22:56:32 +0900", "snippet": "저번에는 Jekyll 로컬 서버를 이용하여 로컬에서 어떻게 띄우는 알아보았다.이번에는 Jekyll 테마를 적용하여 블로그를 꾸며볼것이다.Jekyll 테마 선택하기찾아보니 Jekyll 테마가 엄청 많다.테마를 모아둔 사이트를 소개하려한다. jamstackthemes.dev jekyllthemes.org여기 두개가 제일 보기 쉬워보여 두가지만 적어 놓았다.위의 사이트를 하나하나 보면서 원하는 테마를 찾는것도 좋지만, 많이 사용하는 테마들이 정보도 얻기 쉽고 그래서 테마 사용 순위를 한번 찾아보았다.Free Jekyll themes for 2022 « 2022년 3월 기준 사용 용도별 순위가 포스트된 사이트가 있어 여기도 소개 해보았다.필자는 chirpy 테마를 사용하였다. 원래는 주변에서 minimal-mistakes를 많이 사용하길래 따라하려했으나, 여러 사이트를 소개하려고 찾다보니 chirpy가 깔끔해보여 선택했다.테마 다운받기테마를 다운받는 방법은 2가지로 나뉜다.a. 프로젝트를 ZIP으로 받는 방법repo를 미리 만들어 놓고 프로젝트 파일을 넣는 방식b. 프로젝트를 Fork하는 방법repo를 미리 만들지 않고 다른사람의 repo를 복제하는 방식필자는 a방식을 사용하여 진행 할것이다.왜냐하면, 이미 앞장에서 repo를 만들고 진행을 했기도 했고fork방식은 chripy thema 개발에 관여를 하지않을거면 추천하지않는다고 적혀있다.자세한 설명은 여기서 확인 가능다른테마도 똑같이 진행해주되 테마마다 fork를 지향하는지 지양하는지 확인하고 a,b방식을 선택하여 진행하길 바란다.테마를 선택하였다면, 해당 테마 github repo를 접속하여 다운로드 한다.필자와 같은 테마를 이용한다면 Chripy Thema 다운로드에 접속하여 진행하면 된다.릴리즈 버전이 여러가지 있는데 최신버전으로 Download ZIP을 클릭하여 파일을 다운로드한다.테마 적용하기이전에 작성햇던ZIP파일을 압축 해제하고 모든파일들을 프로젝트안으로 가져온다.주의사항압축풀때 모든 파일(숨김파일포함)을 다 가져와야한다.초기화 진행할때 진행이 안되는 경우 발생함.여러 정보를 찾아보던중 Chripy테마는 파일을 가져온후 초기화를 진행해줘야한다는것을 알아냇다.초기화 방법프로젝트를 가져온 상태에서 commit을 진행한다.git add .git commit -m \"Init Chripy Thema\"그리고 Chirpy Thema는 shell 명령어로 초기화를 진행할 수 있도록 sh파일을 제공한다.sh tools/init.sh명령어를 통해 init.sh을 실행하면 아래 사진과 같이 초기화 성공 메세지 출력이 된다.init.sh 실행하면 무슨일이 일어나지??나중에 포스트해야겟다~Jekyll 실행하기테마를 적용하였으니 확인 하기 위해 Jekyll을 실행하여 로컬에서 확인을 해보자!앞에서 설정하였으니 Jekyll을 실행해보았다..아앗… 여기서 문제가 발생하였다..오류가 발생하는 이유는 테마에 적용할때 기존에 설치한 bundle이 삭제되어 bundle을 새로 설치해야 한다는것이다.왜 다른 블로그에서 테마를 정해놓고 jekyll을 설치를 하는지 깨달아버렸다.여러 시행착오 겪는거??오히려 좋아bundle installbundle 새로 설치하고bundle exec jekyll serveorsh tools/run.shChripy Thema는 로컬 서버를 여는 sh파일을 제공한다.로컬 서버 열린거 다시 확인하고 localhost:4000로 다시 접속하면 테마가 적용된것을 확인 할 수있다.기본 설정테마를 적용하였으니 이제 기본설정을 건드려 보려한다.기본설정은 _config.yml을 이용하여 수정한다.기본 필수속성 baseurl : 로컬 테스트용 '' url : 블로그 주소 https://gitusername.github.io lang : 언어설정 en or ko-KR timezone : 표준시간 설정 Asia/Seoul사이드바 설정 avatar : 이미지 링크 title : 원하는 제목 tagline : 부제목 설정 github : github_username twitter : tiwtter_username email : email_username@email처음으로 설정 해볼만한 것들은 이정도로 존재하며_config.yml은 이 글만보고 파악하려하지말고 한번 열어서 글보면서 수정도 해보고 다 읽어보길 바란다.많은 설정 부분이 존재하며 주석으로 설명도 잘되어있으니 추가적으로 설정할것이 있는지 확인 해보자배포하기설정을 바꾼것을 로컬에서 확인을 다하였으면 git에 배포를 하자.배포하기전 .gitignore에 제외시켜야할 파일이 있다.echo \"Gemfile.lock\" &gt;&gt; .gitignore명령어를 실행하여 Gemfile.lock을 제외시킨다.git add -Agit commit -m \"blog default setting\"git pushGit Pages branch 설정git에 배포가 정상적으로 되었다고 해도 페이지에 접속하면 적용이 안되는것을 확인할 수 있다.--- layout: home # index page ---이런 메시지만 출력될 것이다. 정상이다.Github에서 push된 코드들을 빌드를 하여 gh-pages branch가 없으면 생성&amp;배포하고 존재하면 해당 branch에 배포를 한다.Gitpage 설정을 빌드된 branch로 해야한다.Github repo의 상단 탭에서 Setting 으로 들어가서 master branch를 gh-pages로 바꾸고 Save를 누르면 변경이 된다.저장하고 바로는 적용이 안되고 한 3~5분정도 후에 블로그주소에 접속하여 보면 적용 된것을 확인 할수있다.위의 주소를 보면 로컬이 아닌 Github repo 주소인것을 확인하자이것으로 테마 적용 및 기본 설정은 완료 했으며, 다음장에는 간단하게 테마 구성파악을 포스팅 하려한다.오류발생테마 설정 하면서 발생한 오류들을 적어본다.Chirpy 초기화 실행 오류 1ZIP을 해제하고 초기화를 진행하려는데 이런 오류가 발생하였다.원인 :git 변동사항이 존재하여 발생하는 오류해결 :commit을 올리면 해결Chirpy 초기화 실행 오류 2[INFO] Initialization successful!출력이 안되고 Already initialized.만 출력이 되었었다.원인 :.github이 존재하지않아서 발생하는 오류ZIP압축 파일을 해제하고 복사해오면서 숨김파일을 안넣어서 생긴다.해결 :터미널에서 (Mac) ls -a , (Windows) dir /a 명령어를 통해 .github파일이 존재하는지 확인여기서 의문!왜 오류라고 안나오지? 라고 생각할 수 있다.이걸 이해하려면 init.sh 소스를 보면 된다.check_init() { local _has_inited=false if [[ ! -d .github ]]; then # using option `--no-gh` _has_inited=true else if [[ -f .github/workflows/$ACTIONS_WORKFLOW ]]; then # on BSD, the `wc` could contains blank local _count=\"$(find .github/workflows/ -type f -name \"*.yml\" | wc -l)\" if [[ ${_count//[[:blank:]]/} == 1 ]]; then _has_inited=true fi fi fi if $_has_inited; then echo \"Already initialized.\" exit 0 fi}check_init() 부분에서 .github/workflows/을 찾아야하는데 존재하지않아서 그렇다.배포오류 1증상 :username.github.io에 접속하게되면 페이지가 안뜨고 git - repo - Actions에서 오류가 발생함원인 :.gitignore에 Gemfile.lock을 추가하지않고 배포하는경우 해결 :웹으로 들어가 git repo에서 Gemfile.lock을 삭제하고 커밋을 올린다.배포오류 2증상 :refusing to allow a Personal Access Token to create or update workflow `.github/workflows/pages-deploy.yml` without `workflow` scopegit push 오류 발생원인 :git repo에서 workflows 권한이 없어 발생 해결 :git account Setting - Developer settings - Personal access tokens - 기기에 적용된 key 클릭 - workflow 체크박스 클릭 - Update token설정이 끝나고 배포 재시도를 한다.(repo Setting이 아닌 account Setting)" }, { "title": "[GitHub Pages] Jekyll 설치 방법", "url": "/posts/install-jekyll/", "categories": "GitHub, GitHub Pages", "tags": "github pages, jekyll", "date": "2022-08-16 23:19:15 +0900", "snippet": "저번에는 GitHub Pages를 이용하여 블로그를 생성을 해보았다.이번에는 Jekyll를 이용하여 홈페이지를 꾸며볼것이다.Jekyll이란 무엇인가?여기서 잠깐!Jekyll에 대해 좀 알아보고 넘어가보고자 한다.Jekyll이란?어원은 Jekyll &amp; Hyde의 Jekyll이다.GitHub설립자 중 한명이 Ruby를 기반으로 개발된 프레임워크.정적 웹사이트 구조이다.- 정적 웹사이트란 저장된 파일만을 이용하여 사용자에게 띄워주는 방식 Back-end코드가 없어 제작 간편 속도가 빠르며 가벼움HTML, MarkDown등 Markup 언어를 이용하여 작성하면 규칙에 따라 웹 페이지 생성이정도 까지만 알고 넘어가자더 많은 정보를 알고싶다면 Jekyll 지킬이란? 여기로 넘어가서 보거나, 구글링을 통하여 공부를 해보자Ruby 설치 필자는 M1 MAC을 사용하고있으므로 brew로 설치를 진행한다Jekyll을 설치하기전에 먼저 설치해야하는것이 있다.무엇일까?맞다. Ruby를 먼저 설치를 해야한다. 왜? Ruby기반으로 개발된 프레임워크니까아래 명령어를 터미널에 입력하여 rbenv와 ruby-build를 설치한다.brew install rbenv ruby-buildrbenvRuby 버전 관리 패키지이다. Ruby의 여러버전을 설치 할 수 있으며, 사용할 버전을 선택하고 사용가능하다.ruby-build다른 버전의 Ruby를 임의의 디렉터리에 컴파일하고 설치할 수 있게 하는 rbenv의 플러그인이다..ruby-build는 rbenv 없이 독자적으로 사용 할 수도 있다.macOS, Linux나 다른 UNIX-계열 운영체제에서만 사용 가능자세한 설명은 Ruby 공식 문서를 참고rbenv versions현재 사용중인, 설치된 Ruby 버전을 확인 하는 명령어지금은 아무 버전도 설치한 상황이 아니라 system만 존재한다.syetem 앞의 *는 현재 사용중 버전을 알려주는 표시이다.&lt;hr&gt;rbenv install -l설치 가능한 Ruby 버전을 보여주는 명령어&lt;hr&gt;rbenv install 원하는버전필자는 2.7.6 버전을 사용할 것이다.왜냐? 최신 버전으로 설치를 하는 경우 호환성 문제로 고생을 해본적이 너무 많아서 최신 버전을 약간 기피하는 성향이 생겼다.최신버전 문서를 읽고나서도 왠지 모르는 불안감에 일단 구버전으로 설치한다.설치를 진행 완료 후 versions 명령어를 사용하여 2.7.6 버전이 설치가 된 것을 확인한다rbenv global 설치한 버전Bundler 설치Bundler를 설치 하기전에 개념을 한번 살펴보고 가자GemRuby의 라이브러리 패키지command line으로 명령을 사용가능Bundler필요한 gem과 gem의 버전을 설치, 추적하고 Ruby프로젝트를 제공하는 도구이제 Bundler를 설치 해보자!gem install bundler해당 문구가 뜰것이다.이것의 원인을 찾아보앗더니 처음에 2.7.6버전을 설치를 하였으나 아직까지 system Ruby버전을 사용하고 있는중이라 권한이 없어서 발생하는 에러라고 한다.터미널 설정을 바꾸어 Ruby권한을 바꾸어야한다.rbenv의 PATH 설정 추가vi ~/.zshrcvi를 이용하여 .zsh 설정 파일을 연다.export PATH={$Home}/.rbenv/bin:$PATH &amp;&amp; \\eval \"$(rbenv init -)\"PATH 설정 추가를 하고 저장을 한다.source ~/.zshrcsource 명령어를 사용하여 변경 설정을 적용을 한다.이제 다시 Bundler를 설치를 진행하면 bundler 설치는 끝이다.Jekyll 설치gem install jekylljekyll 설치하는 도중 에러가 발생하였다.Xcode업데이트 이후 Command Line Tools를 설치를 해야한다고 한다.Command Line Tools를 설치하기 위하여 아래 명령어를 입력을 해봄xcode-select -install명령어를 실행하였으나, 오류를 다시 마주하게 되었다.프로그램 업데이트를 해야하는데 찾아보니그냥 재설치를 많이 하는것 같아 따라해봄sudo rm -rf /Library/Developer/CommandLineTools삭제후 다시 설치 명령어를 이용하여 설치 후, jekyll 설치하면 설치가 된다.설치 완료후 jekyll 생성을해보자Jekyll 생성처음에 clone한 위치로 가서 jekyll을 생성한다.jekyll new ./명령어를 실행하기전에 전에 만들어둔 index.html을 삭제하고 실행하여야한다.안그러면 이런식으로 오류가 발생한다.jekyll을 생성하게 되면 많은 파일들이 생성이 되는데 이파일들은 jekyll 기본 파일들이라고 생각하자Bundle 설치jekyll과 마찬가지로 프로젝트 디렉토리 안에서 bundler를 설치해야한다.bundler installLocal 서버 열기bundle exec jekyll serve명령어를 이용하여 로컬서버를 열고 localhost:4000으로 이동하여 서버가 열렸는지 확인!이런식으로 로컬서버로 열리는것을 확인 할 수있다.이번에 Jekyll 테마를 가져와서 꾸며보고 싶엇는데 Jekyll설치하는게 너무 오랜시간을 쏟아부어 테마 적용은 다음장에서 진행해야겟다." }, { "title": "[GitHub Pages] GitHub Pages를 이용하여 블로그 개설하기", "url": "/posts/create-git-pages/", "categories": "GitHub, GitHub Pages", "tags": "github, github pages", "date": "2022-08-15 22:41:30 +0900", "snippet": "이제부터라도 기록을 남기면서 생활을 해보고자 블로그를 하려고 한다.Naver Blog, Notion을 생각을 하였지만…단순히 그냥 난 개발자니까.. 속으로 생각하며 Git Blog를 생성 해보려한다.Github Repository를 생성한다.Repository 이름을 깃허브 username.github.io로 생성한다.필자는 아래의 설정을 따로 건들지 않고 빈 Repository를 만들기 위하여 설정을 아무것도 건들지 않았다.README.md 파일은 나중에 테마를 적용할때 테마 프로젝트안에 README.md 파일이 존재하므로 따로 추가 하지 않았다.Repository를 clone 하기생성한 Repository를 들어가서 Code를 주소를 복사한다.아래 빨간 박스를 누르면 복사가 자동으로 된다.복사된 주소를 터미널에서 저장하고 싶은 경로로 이동하여 아래의 명령어를 실행한다.git clone (복사된 주소)index.html 생성하기Repository를 복사한 디렉토리에 가서 index.html 파일을 생성한다.index.html의 역할은 홈페이지를 접속하였을때 기본적으로 보여주는 파일이다.index.html파일을 생성하기 전에 브라우저를 열고 Repository명을 입력하고 접속해보자.지금 만들고자 하는 블로그의 주소가 Repository명이다.https://ydo-oby.github.io/홈페이지에 접속하게 되면 아래의 사진럼 404 Not found 오류를 보게 될것이다.너의 사이트에 현재 index.html 파일을 제공해줄것을 요청하고 있다.이것을 다시 말하자면\"너의 사이트에는 지금 기본적으로 보여줄게 없어! 그래서 난 404 Error를 보여준거야!\"이것을 보면서 내가 위에서 말한 index.html의 역할을 다시 생각해보길 바란다.이제 진짜로 index.html을 생성해보자!터미널 명령어가 편하다면 터미널 명령어로 생성하고, 아니면 그냥 내가 clone한 폴더를 찾아서 index.html파일을 생성해준다.생성을 해주었다면 이제 git에 파일을 올려준다.git add .git commit -m \"create index.html\"git push origin masterorgit add .git commit -m \"create index.html\"git push origin main그리고 나서 내 git에 들어가서 index.html이 잘 넣어졌는지 확인하고 다시 주소창에 내 블로그로 들어가서 확인 해보자오류는 사라지고 흰색 화면만 나올것이다.이상하게 생각하지 마라.index.html은 존재하나 내용물이없어서 보여줄게 없어서 그런것이므로 정상적인것이다.이렇게 일단 블로그는 생성이 되었다.여기서 html 문법을 이용하거나 아무 글이나 작성하고 다시 git에 배포해보면 글이 작성이 되는것을 확인할 수 있다.궁금하다면 이건 알아서 작성해보고 배포해보고 확인해보자.Ruby, Jekyll을 이용해서 로컬서버 연결을 해볼것이다.Ruby는 무엇이지?Jekyll이 무엇인가?뭘까.. 궁금하다." } ]
