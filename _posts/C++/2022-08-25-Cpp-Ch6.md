---
title: "[C++] Chapter.6 행렬, 문자열, 포인터, 참조"
date: 2022-09-08 22:20:19 +0900
categories: [Language ,C++]
tags: [c++]
---
<hr>


## 배열의 기초적인 사용법
```cpp
//배열의 기초적인 사용법

#include <iostream>

using namespace std;

//구조체 선언
struct Rectangle
{
    int length;
    int width;
};

enum StudentName
{
    JACK,   //0
    LEE,    //1
    PARK,   //2
};
int main() {
    //Array 비슷한것이 나열되어있는 구조
    
    //동기
    //이전까지의
    //학생의 성적 기록
    //변수 여러개 사용하여 하나씩 저장
    
    //엠티 콘도 한층 빌리는것을생각
    
    //배열 선언
    int student_scores[5]; //5 int
    int student_one;
    
    //크기비교
    cout << sizeof(student_one) << endl;
    //4
    cout << sizeof(student_scores) << endl;
    //20 = int 5개가 되어 4 * 5 = 20이 된다.
    
    //어떠한 경우 배열의 크기가 너무커서 사용 못할수도잇다. - 변수의 크기가 너무 큰경우
    
    //배열 대입 방법
    student_scores[0] = 100;    //1st element
    student_scores[1] = 80;     //2nd element
    student_scores[2] = 90;     //3rd element
    student_scores[3] = 50;     //4th element
    student_scores[4] = 0;      //5th element
    
    
    //잘못된 경우 - 오류 발생
    //student_scores[5] = 30;
    //배열은 0부터 시작하여 n-1번까지 사용한다.

    
    cout << student_scores[0] << endl;
    cout << student_scores[1] << endl;
    cout << student_scores[2] << endl;
    cout << student_scores[3] << endl;
    cout << student_scores[4] << endl;
    //오류발생
    //cout << student_scores[5] << endl;
    //출력은 된다.
    
    //변수처럼 연산자도 사용가능
    cout << student_scores[0] + student_scores[3] << endl;
        
    //구조체 배열 선언
    Rectangle rec[10];
    
    
    cout << sizeof(Rectangle) << endl;
    //int 2개 : 8
    cout << sizeof(rec) << endl;
    //int 2개 * 배열 10개 : 80
    
    
    //배열 초기화방법
    int arr[5] = {1, 2, 3, 4, 5};
    cout << arr[0] << endl;
    cout << arr[1] << endl;
    cout << arr[2] << endl;
    cout << arr[3] << endl;
    cout << arr[4] << endl;
    
    //배열의 크기가 정확한 경우 []안에 숫자 없이 초기화가능 - 자동으로 크기에 맞춰준다.
    //int arr[] = {1, 2, 3, 4, 5};
    
    //배열 일부만 초기화가능
    int arr2[5] = {1, 2};
    
    //enum을 사용할수도잇다.
    //index도 enum으로 시용할수있다.
    cout << arr[JACK] << endl;
    cout << arr[LEE] << endl;
    cout << arr[PARK] << endl;
    
    //사이즈가 컴파일 타입에 고정이 되어야한다.
    
    int num_st;
    cin >> num_st;
    
    //index값이 불변적이라 오류값이 발생한다.
    //컴파일 타입에 숫자가 고정이 되어야한다
    int student_values[num_st];
    
    return 0;
}

```

## 배열 2/2
```cpp
//배열의 기초적인 사용법

#include <iostream>

using namespace std;

//배열안의 값은 있어도 없어도 무방하다
//포인터 변수로 받아오기때문에
void doSomething(int student_scores[20])
{
    cout << "--values--" << endl;
    cout << student_scores[0] << endl;
    cout << student_scores[1] << endl;
    cout << student_scores[2] << endl;
    cout << student_scores[3] << endl;
    cout << student_scores[4] << endl;
    
    cout << "--address--" << endl;
    cout << (size_t)&student_scores << endl;
    //함수 내부의 배열과 차이가 발생한다.
    //이값은 배열이 아니고 넘겨받은 배열의 첫번째 주소값을 저장하는 포인터 변수를받기때문에
    //파라미터의 변수는 주소값을 저장하는 다른 변수로 저장하기 때문에 주소값이 달라지는것이다.
    
    cout << (size_t)&student_scores[0] << endl;
    //
    cout << (size_t)&student_scores[1] << endl;
    cout << (size_t)&student_scores[2] << endl;
    cout << (size_t)&student_scores[3] << endl;
    cout << (size_t)&student_scores[4] << endl;
    
    
    cout << sizeof(student_scores) << endl;
    //포인터 변수의 사이즈를 출력한다.
    //32의 경우 4
    //64인 경우 8 출력
    //32비트에선 포인터의 변수 = 4바이트
    //64비트에선 포인터의 변수 = 8바이트
}
int main() {
    //배열의 주소 방식 & 함수 파라미터에서의 배열 사용
    
    const int num_student = 20;
    
    int student_scores[num_student] = {1,2,3,4,5};
    
    //배열 전체 주소 출력
    //10진법으로 출력하기위해  casting 사용
    //(long long) / (size_t)사용을 권장한다.
    cout << (long)&student_scores << endl;
    //6171914940
    
    //배열의 인덱스 주소 출력
    cout << (long)&student_scores[0] << endl;
    //6171914936
    cout << (long)&student_scores[1] << endl;
    //6171914940
    cout << (long)&student_scores[2] << endl;
    //6171914944
    cout << (long)&student_scores[3] << endl;
    //6171914948
    
    //인덱스 값에 따라 숫자가 4씩 증가한다 => int 자료형의크기 = 4
    //배열의 주소는 첫번째, 즉 인덱스가 0번인 배열과 주소가 같다.
    
    
    //함수 파라미터에 배열을 넣을수 있다.
    doSomething(student_scores);
    
    //함수 내부의 배열의 주소가 다른이유
    //배열의 이름 = 인식자 identifier로 사용이 된다.
    //배열의 경우 변수명을 내부적으로 주소로 사용한다.
    //그리하여 배열의 경우 앞에 &를 안 붙여도 주소값을 출력한다.
    
    //배열의 경우 주소로 데이터를주고받는것보다 데이터를 모두 복사하는것보다 효율이 좋기때문이다.
    //함수의 파라미터의 경우는 생긴건 배열처럼 보이지만 문법상 배열이 아니고 포인터라고 한다.
    //컴파일러는 포인터로 인식한다.
    
    //함수 파라미터로 넣어주게 되면 배열을 복사하는것이 아니라 주소값만 복사한다.
    //그래서 함수의 파라미터로 배열을 넣어줄때 그냥 포인터로 넣어주는 경우도 있긴하다고 한다.
    
    cout << (size_t)student_scores << endl;
    
    
    return 0;
}

```

## 배열과 반복문
```cpp
//배열과 반복문

#include <iostream>

using namespace std;

int main() {
    //배열은 같은 자료형을 나열한것이므로 반복문을 사용하면 편해진다.
    //앞에서 하나하나씩 출력한것을 반복문을 사용하면 편해진다.
    
    //반복문을 안사용하는 경우
    const int num_student = 5;
    int score0 = 10;
    int score1 = 20;
    int score2 = 30;
    int score3 = 40;
    int score4 = 50;
    
    int total_score = score0 + score1 + score2 + score3 + score4;
    
    double avg_score = static_cast<double>(total_score) / num_student;
    
    cout << "total : " << total_score << endl;
    cout << "avg : " << avg_score << endl;
    
    //반복문 사용
    int scores[num_student] = {10, 20, 30, 40 ,50};
    
    total_score = 0;
    avg_score = 0.0;
    
    for (int i = 0; i < num_student; ++i) {
        total_score += scores[i];
    }
    avg_score = static_cast<double>(total_score) / num_student;

    cout << "loop use total : " << total_score << endl;
    cout << "loop use avg : " << avg_score << endl;
    
    //배열의 인덱스 갯수 구하는 방법
    const int num_arr = sizeof(scores) / sizeof(int);

    cout << "array size : " << num_arr << endl;
    
    
    int max_score = 0;
    int min_score = INT_MAX;
    
    for (int i = 0; i < num_arr; ++i) {
        
        //최댓값
        if(max_score < scores[i])
            max_score = scores[i];
        
        //최솟값
        min_score = (min_score > scores[i]) ? scores[i] : min_score;
    }
    
    cout << "max value : " << max_score << endl;
    cout << "min value : " << min_score << endl;
    
    return 0;    
}
```

## 배열과 선택 정렬 selection sort
```cpp
//배열과 선택정렬
//selection sort

#include <iostream>

using namespace std;


void printArray(int array[], int length)
{
    for (int i = 0; i < length; ++i) {
        cout << array[i] << " ";
    }
    cout << endl;
}

int main() {
    //배열 사용법을 더 연습하기 위해 정렬 중 선택 정렬을 구현해본다.
    
    
    //선택정렬
    /*              index   value
     3 5 2 1 4        0     3 > 1
     1 5 2 3 4        1     5 > 2
     1 2 5 3 4        2     5 > 3
     1 2 3 5 4        3     5 > 4
     1 2 3 4 5       end     end
     
     인덱스 0번부터 작은숫자 비교하여 값을 바꾸고 다음 인덱스 1번부터 작은숫자를 비교하여 값을 바꾸는식으로 인덱스 값만큼 반복하여 오름차순으로 정렬을한다.
     */
    
    //선택 정렬 구현
    const int length = 5;
    
    int arr[length] = {3, 5, 2, 1, 4};
    
    printArray(arr, length);
    
    //내가 만든거
    for (int i = 0; i < length; ++i) {

        int min = INT_MAX;
        int min_idx = 0;
        
        for (int j = i; j < length; ++j) {
            if(min > arr[j])
            {
                min = arr[j];
                min_idx = j;
            }
                
        }
        
        int temp = arr[i];
        arr[i] = arr[min_idx];
        arr[min_idx] = temp;

    }
    printArray(arr, length);
    
    cout << "hong's code" << endl;
    //강의에서 만든거
    for (int startIndex = 0; startIndex < length - 1; ++startIndex) {
        
        int smallestIndex = startIndex;
        
        for (int currentIndex = startIndex+1; currentIndex < length; ++currentIndex) {
            
            if(arr[smallestIndex] > arr[currentIndex])
            {
                smallestIndex = currentIndex;
            }
        }
        
        //swap two values in the array
        //std::swap( arr[smallestIndex], arr[i]);
        int temp = arr[smallestIndex];
        arr[smallestIndex] = arr[startIndex];
        arr[startIndex] = temp;
    }
    printArray(arr, length);
    
    
    //swap
    int temp = arr[0];
    arr[0] = arr[1];
    arr[1] = temp;
    printArray(arr, length);
    
    return 0;
}
```

## 정적 다차원 배열
```cpp
//  정적 다차원 배열
//  Multi-dimensional Array

#include <iostream>

using namespace std;

int main() {
    //컴퓨터 메모리는 1차원적인주소공간을 가지고있다.
    //건물 복도 형식으로 되어있는데 배열을 사용하면서 건물처럼 사용해야할때가 발생한다.
    //일차원인것을 다차원인것처럼 사용한다.
    //나중에 동적 할당을 배우면 동적 다차원 배열도 배운다.
    
    //2차원적 배열
    
    //가장 기본적인 2차원 구조 = 행렬 구조
    const int num_rows = 3;
    const int num_columns = 5;
    
    for (int row = 0; row < num_rows; ++row) {
        for (int col = 0; col < num_columns; ++col) {
            cout << '['  << row << ']' << '[' << col <<']' << '\t';
        }
        cout << endl;
    }
    
    /*
     [0][0]    [0][1]    [0][2]    [0][3]    [0][4]
     [1][0]    [1][1]    [1][2]    [1][3]    [1][4]
     [2][0]    [2][1]    [2][2]    [2][3]    [2][4]
     */
    
    //다차원 배열 선언 방법
    int arr[num_rows][num_columns];     //row-major 방식 <-> colum-major
    //하나씩 초기화 하는 방법
    arr[0][0] = 1;
    
    int arr2[num_rows][num_columns] =
    {
        {1,2,3,4,5},        //row 0
        {6,7,8,9,10},       //row 1
        {11,12,13,14,15}    //row 2
    };
    
    for (int row = 0; row < num_rows; ++row) {
        for (int col = 0; col < num_columns; ++col) {
            cout << arr2[row][col] << '\t';
        }
        cout << endl;
    }
    //1차원 배열이 3줄 출력된다.
    /*
     1    2    3    4    5
     6    7    8    9    10
     11    12    13    14    15
     */
    
    //다차원배열 주소출력
    for (int row = 0; row < num_rows; ++row) {
        for (int col = 0; col < num_columns; ++col) {
            cout << (size_t)&arr2[row][col] << '\t';
        }
        cout << endl;
    }
    /*
     6171914896    6171914900    6171914904    6171914908    6171914912
     6171914916    6171914920    6171914924    6171914928    6171914932
     6171914936    6171914940    6171914944    6171914948    6171914952
     */
    //일차원 배열 1개가 끝나고 다음 줄에 4씩 증가한것을 보고
    //처음에 말한 1차원 배열을 다차원인것 처럼 사용한다는것이 이것을 보고 이해할 수 있다.
    //주소형식이 4씩증가하고 끝에서 다음 배열로 넘어갈때더 4씩 증가한것을 보고 일렬로 되어 있는 주소가 접힌것처럼 보이게 된다.
    
    
    //초기화 하는 방법2
    //num_rows는 생략 가능 ,num_columns는 생략 불가능
    //num_rows를 생략하는 경우 하나의 배열에는 모든 항목에 값이 들어가있어야한다.
    //배열에 빈값이 생기면 알아서 0으로 채워준다.
    int arr3[][num_columns] =
    {
        {1},        //row 0
        {6,7,8,9,10},       //row 1
        {11,12,13,14,15}    //row 2
    };
    
    
    //3차원 배열 방식
    int arr4[3][4][5];
    
    return 0;
}

```

## C언어 스타일의 배열 문자열
```cpp
```

## 포인터의 기본적인 사용법 
```cpp
```

## 널 포인터 null pointer
```cpp
```

## 포인터와 정적배열
```cpp
```
## 포인터 연산과 배열 인덱싱
```cpp
```