---
title: "[C++] Chapter.4 변수범위와 더 다양한 변수형"
date: 2022-09-01 21:39:12 +0900
categories: [Language ,C++]
tags: [c++]
---
<hr>


## 지역 변수, 범위, 지속시간

```cpp
//  지역 변수의 범위와 지속시간
//  Scope / Duration

#include <iostream>

using namespace std;


//같은변수여서 충돌이 난다.
//int a = 1;
//
//int a = 1;

//함수 선언 정의분리가능
//선언은 여러곳 가능 정의는 한번만 가능


//함수중 이름은 같은데 파라미터가 다른경우에는 충돌이일어나지않는다.
//충돌을 막기위하여 네임스페이스를 사용하여 분리를 해준다.
namespace work1
{
    int a = 1;
}

namespace work2
{
    int a = 3;
}

//네임스페이스안에 네임스페이스를 또 만들수 있다.
//네스티드 영역은 되도록이면 적게사용하는것이 좋다.
namespace work3::work33::work333
{
    int a = 3;
}



int main() {
    //블록 명칭공간,이름충돌, 이름숨기기
    
    //범위 Scope 눈으로 볼수았는 범위 뉘앙스
    //어디서 내가 변수를 사용할수있는가 볼수있다
    
    //지속기간 메모리에 얼마나 사용할수있는가
    
    
    //동적 할당 사용시 >> 지역, 지속기간 분리가 된다.
    
    //apple = 1;
    //변수가 선언전이라 안되어있어서 사용불가
    
    //변수 선언
    int apple = 5;
    cout << apple << endl;
        //5
    
    //블록 지정
    {
        //블록 밖에서 선언한변수는블록 안에서도 사용가능하다.
        apple = 1;
        cout << apple << endl;
        //1
        //이 apple은 다른 apple이다.
        //더 작은 영역안에같은변수가 있는경우 밖의 apple은 숨겨진다. hiding
        //블록간의 이름은분리하는게 좋다. 헷갈린다. 보기 안좋다.
        
        int apple = 6;
        cout << apple << endl;
        //6
    }
    cout << apple << endl;
    //1
    
    
    apple = 1;
    
    //:: 영역/범위 결정 연산자  스코프 레졸루션? 오퍼레이터
    work1::a;
    work2::a;
}
//메모리 반납 후
//apple = 3;
//변수선언된 범위가 아니여서 사용불가

```

## 전역 변수, 정적 변수, 내부 연결, 외부 연결
```cpp
//  전역 변수, 정적 변수, 내부 연결, 외부 연결
//  Global Static Internal External

#include <iostream>
#include "Constants.h"

using namespace std;

//forward declaration
//컴파일러가 main.cpp를 컴파일할때 어딘가에 함수가 정의가 되어있으니 링킹할때 그걸 사용하면 된다.라고 알려주는 길라잡이 역할을 한다.
void doSomething_t();
//(extern) void doSomething_t(); extern이 생략 된것이다.

extern int b;
extern int b_;
//extern int b_2 = 456;
//외부변수 선언

//전역변수
int value = 123;
int global_a = 1;

//정적변수 지속변수
void doSomething()
{
    //정적변수 선언
    static int a = 1;
    
    ++a;
    ++global_a;
    
    cout << a << " " << global_a << endl;
    
    //static global 차이
    //static 변수는 os로부터받은 메모리가 static이다.
    //동적 할당 배우면서 정확하게 알게 된다.
    //지역변수, 전역변수(일반 변수들)는 메모리 활동이 블록을 벗어나면 메모리를 반납햇다가 다시 선언하게 되면 다시 할당됫다 한다.
    
    //정적변수는 메모리가 고정으로 잡혀있는것이다. 블록을 벗어나고 다시 블록에 접근하여 사용할때 메모리를 다시할당하는것이아니라 원래 메모리주소를 사용한다.
    //정적변수는 초기화를하지않으면 사용하지 못한다.
    //메모리 관점에서 보면 이해가 쉬워진다.
    
    
}


int main() {
    
    //블록 내에서만작용 하는 변수 = 지역변수
    
    //어디서든 사용 가능한 변수 = 전역변수
    //편한것처럼 보이지만
    //가급적 사용을 하지 말아야 한다.
    //그렇지만, 여러가지 이유로 부득이하게 사용하게 된다.

    
    //지역변수의 경우 링키지가 없다.
    //특정 파일 내에선 어디서든 사용가능한 연결 = 내부연결
    //파일내에 선언한 변수를 다른 파일에서 사용하는 연결 = 외부연결
    
    //전역변수 123 출력
    cout << value << endl;
    //전역변수 123 출력
    
    //지역변수 블록 벗어나면 사용, 접근 불가
    int value = 1;
    
    cout << value << endl;
    //지역변수 1 출력
    
    //golbal scope operator사용하여 전역변수 사용가능
    cout << ::value << endl;
    //전역 변수 123 출력
    
    
    //전역변수 사용할때의 위험성 예시
    //전역변수 사용하고 다른 파일에서 사용하는 경우 어디서 사용하는지 관리하기가 힘들어진다.
    
    //대안방법1
    //전역 변수 사용시 설계를 유의하여 사용한다.
    //전역변수인지 아닌지 명확하게 사용을 한다. ex)함수의 파라미터를 사용할때
    
    //대안방법2
    //글로별 변수는 변수명에 구분을 두어 명확하게 사용하는것이다.
    //지역변수 a => int a;
    //전역변수 a => global_a;
    
    //대안방법3
    //객체지향을 배우고 객체지향을 사용하고 전역변수를 사용하지 않는것이다.
    
    doSomething();
    //2 출력
    doSomething();
    //3 출력 일반변수 사용시 2로 출력
    
    //링킹 => 연결 시켜주는? cpp파일들을 연결하여 obj를 묶어주는?
    //지역변수는 링키지가 없다.
    //다른 파일이랑 연결 될일이 없기때문에 없다.
    
    //내부연결
    //개별 cpp파일 안에서만 전역으로 작동하는 전역변수를 의미한다.
    //cpp안에서 모든곳에서 사용가능하다.
    //static 전역변수는 다른 cpp파일에서 접근이 불가능하다.
    //static은 문법상 다른 cpp파일에서 사용할 수 없도록 막아주는 역할을 한다.
    
    //외부연결
    //test.cpp에서 외부 함수를 쓰려고할때 include하여 접근 할수있다. 가급적 사용하진 않지만..
    //extern을 사용하여 사용이 가능하다.
    
    
    //링키지 => 연결 그 자체?
    
    //test.cpp에서 외부변수 초기화가 안되어있는 경우 실행하면 오류발생
    //링킹에러 발생
//    cout << b << endl;
    
    //test.cpp에서 초기화하면 출력이 잘됨
    cout << b_ << endl;
    
    //초기화를 두번해주면 오류가 발생한다.
    //이유 : extern 변수를 선언하고 초기화를 두번하게 되면 컴파일러 입장에서는 프로그램 전체에서 같은 변수가 2번 초기화가 된것이므로 충돌이 발생한것이다.
//    cout << b_2 << endl;
    
    
    //
    cout << "main.cpp : " << Constants::pi << endl;
    
    cout << "pi address of main.cpp : " << &Constants::pi << endl;
    
    doSomething_t();
    
    
    //같은 파일의 변수를 다른파일에서 사용하면서 주소를 출력해보면 다르게 나온다.
    //게임 코딩의 경우 이렇게 변수를 100~1000개 사용하면 메모리가 100~1000개의 사본이 생긴셈이다.
    //전역변수가 100~1000개 생기면 메모리 낭비가 예상치 못하게 커질수있다.
    
    //방지하는 방법
    //cpp파일을만들어서 초기화를해주고 헤더에서 선언만 하여 사용해준다.
    
    
    /*
     정리
     
     int g_x; // external linkage
     static int g_x; //internal linkage
     const int g_x; (x)사용 불가  초기화를 해주어야 한다.
     
     //초기화를 안해줘도 되지만 어느 한곳에서는 초기화가 되어있어야한다.
     extern int g_z;
     //초기화를 안해줘도 되지만 어느 한곳에서는 초기화가 되어있어야한다.
     extern const int g_z;
     
     int g_y(1);    변수 초기화
     static int g_y(1); 외부에서 접근 불가능한 변수 초기화
     const int g_y(1); 같은 파일 안에서만 사용하는 상수
     
     extern int g_w(1); 외부접근가능한 변수 초기화 << 다른곳에서 사용할땐 초기화 진행하면 안된다.
     extern const int g_w(1); 외부접근 가능한 상수 초기화
     
     */
}

test.h
```cpp
#include <iostream>
#include "Constants.h"

using namespace std;

extern int b;
extern int b_= 123;
extern int b_2 = 123;

void doSomething_t()
{
    cout << "Hello" << endl;
    
    cout << "test.cpp : " << Constants::pi << endl;
    cout << "pi address of test.cpp : " << &Constants::pi << endl;
}

Constants.h
```
#pragma once

namespace Constants
{
    //전역상수
//    const double pi(3.141592);
//    const double gravity(9.8);


//선언만 해준다.
extern const double pi;
extern const double gravity;
}
```


Constants.cpp
```cpp
//초기화를하였으니 컴파일을 하게 되면 cpp파일에서 obj가 만들어지고 obj들이 링킹이 될때 여러 cpp파일들이사용하게 된다.
namespace Constants
{
    //전역상수
    extern const double pi(3.141592);
    extern const double gravity(9.8);
}

```

## Using문과 모호성
```cpp
//  Using문과 모호성
//  Ambiguity

#include <iostream>

//std를 통채로 가져오는 방법
//using namespace std;

namespace  a
{
    int my_var(10);
    int my_a(10);
}

namespace  b
{
    int my_var(20);
    int my_b(10);
}
int main() {
    //프로그램의 크기가 커지면 동일한 이름의 변수와 함수를 사용하게 된다.
    //모호성
    //이름이 같아지면 무엇을사용해아하는지 모른다.
    
    //컴파일러에게 모호성을없애주는 역할을 하는게 using이다.
    //예시)
    //cout, endl, cin을 사용하기 위해 std::의 사용을줄이기 위해 using naemspce std;가 있다.
    
    //std안의 cout만 가져오는 방법
    using std::cout;
    using std::endl;
//    using namespace a;
//    using namespace b;
    
    //오류 발생
    //네임스페이스안의 동일한 변수가잇어서 모호성 발생
    //변수가 다르면 사용가능
//    cout << my_var << endl;
//    cout << my_a << endl;
//    cout << my_b << endl;
    
    
    //영역지정 연산자 이용하여 출력가능
    cout << a::my_var << endl;
    cout << b::my_var << endl;
    
    //영역 연산자를 이용하기 싫다!
    //영역을 분리하여 사용하면 된다.
    {
        using namespace a;
        cout << my_var << endl;
    }
    
    {
        using namespace b;
        cout << my_var << endl;
    }
    
    //using 의 위험성에 대해
    //헤더에 전역범위에 넣어버리면 헤더를 인클루드하는 모든cpp파일에 영향을 끼치게 된다.
    //헤더에 큰영역으로 두는것은좋지않다.
    //cpp파일에 넣는게좋긴하다.
    //헤더에 네임스페이스를안쓰느건아니긴하다.
    //쓰이긴 한다.
    //되도록 적은 범위에 영향을주도록 만드는게 좋다.
}
```

## auto 키워드와 자료형추론
```cpp
//  Auto 키워드롸 자료형 추론
//  Type Inference

#include <iostream>

using namespace std;

//함수에서도 auto 사용가능
auto add(int x, int y)
{
    return x + y;
}

//파라미터에선 auto 사용 불가
//파라미터에 auto를 쓰고싶은 이유:
//함수이름에 대하여 여러가지 변수형을 사용하고싶다. add(int, int) , add(double, double) 파라미터의 변수형에 따라 다르게 만들어주려면 귀찮다.
//근데 auto를사용하지못하면 방법이 없는건가?
//아니다.
//나중에 템플릿(Template) 배우면 자동으로 하나의 함수이름으로 여러가지자료형을 넣을수있게 된다.

//tailing
//->를 이용하여 auto값을 표시해준다.
//코드를 정리 할깨 정리하기 좋다.
//줄맞춤에 용이하다.
auto add(double x, double y) -> double
{
    return x + y;
}

/*
 
 tailing
 줄맞춤이 안맞음
 auto add() -> int;
 auto add() -> double;
 
 int add();
 double add();
 
 */

int main() {
    //큰 프로그램에서는 많은 변수를 선언하고 사용한다.
    
    //어떤 자료형인지 매번 수동으로 결정하게 되면 효율이 떨어진다.
    
    //자료형의 추론을 통해 효율을 높일수잇다.
    
//    int a = 123;
    //123만 보아도 a의 자료형은 int형이라는것을 추론할수있다.
    
    
    //auto keyword
    auto a = 123;
    //자동으로 a를 int형으로 할당한다.
    //자료형을 상황에 따라 스스로 결정하게 하는것을 형추론이라 한다.
    
    auto d = 123.0;
    //double
    auto c = 1 + 2;
    //int
    auto b = 1 + 2.0;
    //double
    
    //편리함과 동시에 잘 알고 사용해야한다.
    
    //함수의 리턴값에도 사용가능
    auto result = add(1, 2);

    
}
```



## 형변환

```cpp
//  암시적 형변환과 명시적 형변환
//  Implicit Type Conversion(coersion)
//  Explicit Type Conversion(coersion)

#include <iostream>
#include <typeinfo>
//자료형의 종류를 알수있는함수

#include <iomanip>
using namespace std;

int main() {
    //타입 출력 방법
    cout << typeid(4.0).name() << endl;
    //double
    
    int a = 123;
    cout << typeid(a).name() << endl;
    //int
    
    //암시적 형변환
    //컴파일러가 알아서 바꿔주는형변환
    int c = 123.0;
    cout << typeid(c).name() << endl;
    
    
    //명시적 형변환
    //작은것 -> 큰것
    float a1 = 1.0f;
    double d = a1;
    //float의 크기가 double보다 작기때문에 정밀도가떨어지지않는다.
    //크게 문제가 없다.
    //numeric promotion
    
    
    //큰것 -> 작은것
    //numeric conversion
    //int -> double
    double d2 = 3;
    
    //int -> short
    short s = 2;
    
    //int -> char
    int i = -128;
    char c1 = i;
    
    
    cout << static_cast<int>(c1) << endl;
    //48출력
    //127이 나오는게 아니고 엉뚱한 숫자가 출력됨
    //char이 들어갈수있는 숫자는 잘들어간다. -128~127
    
    
    
    
    double d1 = 0.123456789;
    float f1 = d1;
    
    cout << setprecision(12);
    
    cout << "d : " << d1 << endl;
    cout << "f : " << f1 << endl;
    //d : 0.123456789
    //f : 0.123456791043
    //정밀도가 떨어져 정확이 저장을 하지못한다.
    
    
    float ff = 3.14;
    int ii = ff;
    
    cout << ii << endl;
    //3출력, 버림 처리
    
    
    cout << 5u - 10 << endl;
    //4294967291
    cout << 5 - 10 << endl;
    //-5
    
    cout << 5u - 10u << endl;
    //4294967291
    //unsigned끼리의 연산은 unsigned 자료형에 저장하기때문에 이런 결과값이 발생한다.
    //형변환도 우선순위가 존재한다.
    
    //4바이트보다 작은것(short, char)은 int형으로 형변환이 우선적으로 된다.
    
    //형변환 우선순위
    //int, unsigned int, long, unsigned long, long long, unsigned long long, float, double, long double

    
    
    //명시적 형변환
    //프로그래머가 명시해주는 형변환
    
    
    int i3 = int(4.0); //cpp style
    int i3 = (int)4.0; //c style
    int i3 = static_cast<int>(4.0);
    //세가지의 기능 차이는 거의없다.
    
}
```