---
title: "[C++] Chapter.7 함수"
date: 2022-09-24 22:20:19 +0900
categories: [Language ,C++]
tags: [c++]
---
<hr>


## 매개변수와 실인자의 구분
```cpp
//매개변수와 인자의 구분
#include <iostream>


using namespace std;

int foo(int x, int y);
//x,y 는 foo의 파라미터이다.

int foo(int x, int y)
{
    return x + y;
}
//매개변수 함수가 어떤 기능하는지 조절해주는 기능
//함수가 끝나면 지역변수 처럼 사라진다.


int main() {
    //매개변수 = parameter
    //인자 = argument
        
    int x = 1, y = 2;
    
    foo(6, 7);
    //6,7은 인자이다.
    //argument, actual parameters
    
    foo(x, y+1);
    //x , y+1도 인자이다.
    //x = 1 , y+1 = 3 foo함수의 파라미타 x에는 1이 전달, 파라미터 y에는 3이 전달되는것이다.
    
    
    
    //파라미터 : 함수를 만들때 사용하는 값
    //인자 : 함수를 사용할때 넣는 값
    
    
    return 0;
}
```

## 값에 의한 전달
```cpp
// 값에 의한 인수 전달
// Passing Arguments by values
// Call by Value

#include <iostream>

using namespace std;

void doSomething(int y)
{
    cout << "In func value : " << y <<  "\nIn func value address : " << &y << endl;
}

int main() {
    
    doSomething(1);
    //리터럴 값 1이 doSomething의 y로 복사가 되는것이다.
    //더 자세하게 말하자면 doSomething에서 int y 가 선언이 되고 1값이 복사가 되는것이다.
    
    int x = 2;
    
    cout << "In main value : " << x <<  "\nIn main value address : " << &x << endl;
    
    doSomething(x);
    //x가 전달이 되는것 처럼 보이지만 실제로 전달되는것은 x안에 있는 값인 6이 전달이 되는것이다.
    //x자체가 전달이 되는것이라면 main과 doSomething에서의 변수 주소가 같아야하지만,
    //mian과 doSomething에서의 변수 주소가 다르게 출력 되는것을 출력결과로 통해 알수있다.
    
    doSomething(x + 1);
    
    //call by value의 장점
    //main과 function에서의 변수 주소가 달라서 function안에서 무슨짓을해도 main에 영향을 주지않는다.
    //코드가 복잡할수록 함수는 자기 할일만하는 것이 제일 깔끔하다.
    
    //하지만, 특별한 경우에는 함수가 외부에 영향을 주도록 해야하는 경우도 발생한다.
    //다음 단계인 이것은 참조에 의한 전달에서 설명을 한다.
    return 0;
}

```

## 참조에 의한 인수전달
```cpp
// 참조에 의한 인수 전달
// Passing Arguments by Reference
// Call by Reference

#include <iostream>
#include <cmath>

using namespace std;

//&키워드가없는경우 y에 몇을 더해도 함수밖에서 값이 변하지 않는다.
void addOne(int &y)
{
    y = y + 1;
    cout << "func y vlaue : " << y << "\ny address : " << &y << endl;
    //main의 인자값과 주소가 같다.
}

void getSinCos(double degrees, double &sin_out, double &cos_out)
{
    static const double pi = 3.141592;
    double radians = degrees * pi / 180.0;
    
    sin_out = sin(radians);
    //sin함수는 cmath안에 들어잇는함수이다.

    cos_out = cos(radians);
    //cos함수는 cmath안에 들어잇는함수이다.
}

void foo(const int &x)
{
    cout << x << endl;
}


//int *&ptr 해석
//int형 포인터의 ptr변수의 참조값
void ptrfoo(int *&ptr)
{
    cout << ptr << ", " << &ptr << endl;
}

//배열 전달
//배열의 크기가 지정이 되어야한다.
void printElement(int (&arr)[4])
{
    //이건잘사용하지않는다.
    //대부분 동적할당을 사용하여 사용하고, 배열은array, vector를 변수를 사용한다.
}

int main() {
    int x = 5;
    cout << "mian x vlaue : " << x << "\nx address : " << &x << endl;
    
    addOne(x);
    
    cout << "main x vlaue : " << x << "\nx address : " << &x << endl;
    //함수에 의한 값변화 출력 확인하기
    //값은 변화 하였지만 주소값은 동일하다.
    //참조에서 배운 함수 자체에 인자를 전달한것이가 때문이다.
    //참조에 의한 전달은 변수자체를 넘기는것이라 복사가 이뤄지지 않는다.
    
    
    
    double sin(0.0);
    double cos(0.0);
    
    getSinCos(30.0, sin, cos);
    //c나 cpp에서는 출력값이 하나만 지정가능하지만,
    //call by reference를 이용하여 마치 sin과 cos값이 반한값이 나오는 것처럼 구현이 가능하다.
    //(getsincos의 반환값은 void이지만 반환값이 double인 것처럼)
    //c, cpp에선 반환값(리턴값)이 하나만 지정이 가능하여, 매개변수를 여러개 지정하는경우가 많다.
    //인자가 많아지는경우 첫번쨰는 입력값, 출력으로 나가는값을 뒤로 두는것이 일반적이다.
    //그래서 일반적으로 입력값을 const로 막아둔다.
    
    //홍정모 강사께선 한번 계산되고 더이상 값이 변경이 되지않는 값은 const로 막아둔다고 하신다.
    
    cout << "sin value : " << sin << ", cos value : " << cos << endl;
    
    
    foo(6);
    //함수의파라미터가 참조값인 경우 리터럴을 발을수없지만, const로 지정하면 리터럴값도 받을수있다.
    //요즘에는 const로 입력값을 받는다고한다.
    
    
    //포인터에 대한 참조를 보낼수있다..
    int a = 5;
    int *ptr = &a;
    
    ptrfoo(ptr);
    
    cout << ptr << ", " << &ptr << endl;
    
   //배열에 대한 참조 전달
    int arr[]{1,2,3,4};
    printElement(arr);
    
    
    return 0;
}
```

## 주소에 의한 인수전달
```cpp
// 주소에 의한인수 전달
// Passing Arguuments by Address
// Call by Address

#include <iostream>

using namespace std;

void foo(int *ptr)
{
    cout << "func vlaue : " << *ptr << "\nfunc adress value : " << ptr << "\nfunc ptr adress value : " << &ptr << endl;
    
    *ptr = 10;
}

void foo2(const int *ptr)
{
    cout << "func vlaue : " << *ptr << "\nfunc adress value : " << ptr << "\nfunc ptr adress value : " << &ptr << endl;
    
//    *ptr = 10;
    //const 변수인 경우 값 변경불가.
}


//포인터에 의한 인자 전달
void getSinCos(double degrees, double *sin_out, double *cos_out)
{
    *sin_out = 1.0;
    *cos_out = 2.0;
    
}

//const 용법 설명
void foo3(const int *val1 , int  *const val2)
{
    //val1
    int x = 1;
    val1 = &x;
    //주소 값변경가능
//    *val1 = 10;
    //변수 값 변경 불가능
    
    //val2
//    val2 = &x;
    //주소값 변경 불가능
    //굳이 사용 안한다.
    //주소를 바꿔봣자 값에 의한 전달, 즉 함수가 끝나면 없어지기 때문에 주소값을 바꿔도 호출부분에서 크게 해가될부분이 없기때문이다.
}


int main() {
    //주소(포인터)를 이용한 매개변수 전달을 배워보자
    
    int val = 5;
    cout << "main vlaue : " << val << "\nmain adress value : " << &val << endl;
    
    cout << val << endl;
    
    foo(&val);
    
    int *ptr = &val;
    
    cout << val << endl;
    
    foo(ptr);
    
    cout << &ptr << endl;
    //함수안의 주소값과 main의 주소값이 다르다.
    /* 주소값이 다른이유
     typedef int* pint
     
     void foo(pint ptr)
     {
     
     }
     이렇게 보면 매개변수가 pint변수인 foo함수가 된다.
     //형태로 추륵해보면 값에 의한 전달과 같다.
     //주소 값을 값에 의한 전달(call by value)로 전달하는것이라 그렇다.
     //포인터도 그냥 변수다. 단지 주소값을 가지고있을뿐;;
     */
    
    //포인터에 의한 인수 전달도 참조처럼 함수의 반환값이 여러개 인것처럼 구현이가능하다.
    double sin, cos;
    
    //참조와 달리 함수를 사용할때 &를 사용해야한다.
    getSinCos(30, &sin, &cos);
    
    cout << "sin : " << sin << ", cos : " << cos << endl;
    //실용적인측면에서 그냥 call by ref를사용하는것이 편하다.
    
    //착각이 되는것
    /*
     call by ref와 같은 작동을 해서
     ref는 함수 내부와 main과 같은 변수지만,
     pointer는 함수 내부와 main과 다른 변수이다.
    */
    
    //

    
    return 0;
}
```

## 
```cpp
```

## 
```cpp
```

## 
```cpp
```

## 
```cpp
```

## 
```cpp
```

## 
```cpp
```

## 
```cpp
```

## 
```cpp
```

## 
```cpp
```

## 
```cpp
```

## 
```cpp
```

## 
```cpp
```