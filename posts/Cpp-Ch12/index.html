<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.1" /><meta property="og:title" content="[C++] Chapter.12 가상 함수들" /><meta property="og:locale" content="en" /><meta name="description" content="A minimal, responsive, and powerful Jekyll theme for presenting professional writing." /><meta property="og:description" content="A minimal, responsive, and powerful Jekyll theme for presenting professional writing." /><link rel="canonical" href="https://ydo-oby.github.io//posts/Cpp-Ch12/" /><meta property="og:url" content="https://ydo-oby.github.io//posts/Cpp-Ch12/" /><meta property="og:site_name" content="YdO-ObY" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-09-24T22:20:19+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[C++] Chapter.12 가상 함수들" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-10-15T22:16:47+09:00","datePublished":"2022-09-24T22:20:19+09:00","description":"A minimal, responsive, and powerful Jekyll theme for presenting professional writing.","headline":"[C++] Chapter.12 가상 함수들","mainEntityOfPage":{"@type":"WebPage","@id":"https://ydo-oby.github.io//posts/Cpp-Ch12/"},"url":"https://ydo-oby.github.io//posts/Cpp-Ch12/"}</script><title>[C++] Chapter.12 가상 함수들 | YdO-ObY</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="YdO-ObY"><meta name="application-name" content="YdO-ObY"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar3.PNG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">YdO-ObY</a></div><div class="site-subtitle font-italic">나의 공부기록</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/YdO-ObY" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[C++] Chapter.12 가상 함수들</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[C++] Chapter.12 가상 함수들</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1664025619" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Sep 24, 2022 </em> </span> <span> Updated <em class="" data-ts="1665839807" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Oct 15, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/YdO-ObY">YdO-ObY</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6675 words"> <em>37 min</em> read</span></div></div></div><div class="post-content"><hr /><h2 id="다형성의-기본-개념"><span class="mr-2">다형성의 기본 개념</span><a href="#다형성의-기본-개념" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
</pre><td class="rouge-code"><pre><span class="c1">// 다형성의 기본 개념</span>
<span class="c1">// 자식 클래스의 객체에 부모 클래스의 포인터를 사용한다면?</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Animal</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="n">string</span> <span class="n">m_name</span><span class="p">;</span>
    
<span class="nl">public:</span>
    <span class="n">Animal</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="p">{}</span>
    
    <span class="n">string</span> <span class="n">getName</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_name</span><span class="p">;</span> <span class="p">}</span>
    
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">speak</span><span class="p">()</span> <span class="k">const</span>  <span class="c1">//virtual 키워드 사용</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m_name</span> <span class="o">&lt;&lt;</span> <span class="s">" ??? "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">//cat은 animal의 일종이다.</span>
<span class="c1">//Animal 상속</span>
<span class="c1">//일반화된 Animal class로 구현한다.</span>
<span class="k">class</span> <span class="nc">Cat</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Cat</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span> <span class="o">:</span> <span class="n">Animal</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="p">{}</span>
    
    <span class="kt">void</span> <span class="n">speak</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m_name</span> <span class="o">&lt;&lt;</span> <span class="s">" Meow "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Dog</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Dog</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span> <span class="o">:</span> <span class="n">Animal</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="p">{}</span>
    
    <span class="kt">void</span> <span class="n">speak</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m_name</span> <span class="o">&lt;&lt;</span> <span class="s">" Woof "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//지금까지 포인터에 대해 여러가지 측면을 살펴보았다.</span>
    <span class="c1">//상속과 포인터를 엮어서 한번 알아보자</span>
    
    <span class="n">Animal</span> <span class="n">animal</span><span class="p">(</span><span class="s">"My animal"</span><span class="p">);</span>
    <span class="n">Cat</span> <span class="n">cat</span><span class="p">(</span><span class="s">"my cat"</span><span class="p">);</span>
    <span class="n">Dog</span> <span class="n">dog</span><span class="p">(</span><span class="s">"my dog"</span><span class="p">);</span>
    
    
    <span class="n">animal</span><span class="p">.</span><span class="n">speak</span><span class="p">();</span> <span class="c1">//???</span>
    <span class="n">cat</span><span class="p">.</span><span class="n">speak</span><span class="p">();</span>    <span class="c1">//Meow</span>
    <span class="n">dog</span><span class="p">.</span><span class="n">speak</span><span class="p">();</span>    <span class="c1">//Woof</span>
    
    
    <span class="c1">//포인터 사용</span>
    <span class="n">Animal</span> <span class="o">*</span><span class="n">ptr_animal1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cat</span><span class="p">;</span>
    <span class="n">Animal</span> <span class="o">*</span><span class="n">ptr_animal2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dog</span><span class="p">;</span>
    
    <span class="n">ptr_animal1</span><span class="o">-&gt;</span><span class="n">speak</span><span class="p">();</span>   <span class="c1">//my cat - ???</span>
    <span class="n">ptr_animal2</span><span class="o">-&gt;</span><span class="n">speak</span><span class="p">();</span>   <span class="c1">//my dog - ???</span>
    
    <span class="c1">//자식 클래스를 부모 클래스의 포인터로 캐스팅 하여 사용하게 되면 자기 자신이 부모 클래스인것으로 작동한다.</span>
    
    <span class="c1">//활용 가능 예시</span>
    <span class="n">Cat</span> <span class="n">cats</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">Cat</span><span class="p">(</span><span class="s">"Cat1"</span><span class="p">),</span><span class="n">Cat</span><span class="p">(</span><span class="s">"Cat2"</span><span class="p">),</span> <span class="n">Cat</span><span class="p">(</span><span class="s">"Cat3"</span><span class="p">),</span> <span class="n">Cat</span><span class="p">(</span><span class="s">"Cat4"</span><span class="p">),</span> <span class="n">Cat</span><span class="p">(</span><span class="s">"Cat5"</span><span class="p">)};</span>
    <span class="n">Dog</span> <span class="n">dogs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">Dog</span><span class="p">(</span><span class="s">"Dog1"</span><span class="p">),</span><span class="n">Dog</span><span class="p">(</span><span class="s">"Dog2"</span><span class="p">)};</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">cats</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">speak</span><span class="p">();</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">dogs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">speak</span><span class="p">();</span>
    
    <span class="c1">//이렇게 사용이 가능하지만, 상속받은 동물이 여러가지 인경우 for문을 여러개 만드는 불상사가 발생한다.</span>
    
    <span class="c1">//모두 Animal을 상속받는 객체 이므로 Animal을 활용하면 되지않을끼?</span>
    
    <span class="n">Animal</span> <span class="o">*</span><span class="n">my_animals</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="o">&amp;</span><span class="n">cats</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">&amp;</span><span class="n">cats</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="o">&amp;</span><span class="n">cats</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="o">&amp;</span><span class="n">cats</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="o">&amp;</span><span class="n">cats</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
        <span class="o">&amp;</span><span class="n">dogs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">&amp;</span><span class="n">dogs</span><span class="p">[</span><span class="mi">1</span><span class="p">]};</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">my_animals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">speak</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="c1">//virtual 키워드사용시 자식 클래스의 자신의 함수를 사용한다.</span>
    
    <span class="c1">//자식 클래스의 객체를 부모 클래스의 포인터에 넣어서 사용이 가능하다.</span>
    <span class="c1">//이것을 다형성이라고 한다.</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="가상-함수와-다형성"><span class="mr-2">가상 함수와 다형성</span><a href="#가상-함수와-다형성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
</pre><td class="rouge-code"><pre><span class="c1">// 가상 함수와 다형성</span>
<span class="c1">// Virtual Functions, Polymorphism</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"A"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"B"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"C"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="k">public</span> <span class="n">C</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"D"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//다형성을 구현할떄 상속과 virtual 키워드를 사용한다.</span>
    <span class="c1">//이번에는 virtual 용법, 가상 함수에 대해 알아보자</span>

    <span class="c1">//현실적으로 상속의 깊이가 이렇게 깊지는 않다.</span>
    
    
    <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
<span class="c1">//    a.print();</span>
    
    <span class="n">B</span> <span class="n">b</span><span class="p">;</span>
<span class="c1">//    b.print();</span>
    
    <span class="n">C</span> <span class="n">c</span><span class="p">;</span>
<span class="c1">//    c.print();</span>
    
    <span class="n">D</span> <span class="n">d</span><span class="p">;</span>
<span class="c1">//    d.print();</span>
    
    <span class="c1">//다형성 사용</span>
    <span class="c1">//이번에는 참조사용, 이전에 포인터를 사용해 보았으니 참조도 사용해보자</span>
    <span class="n">A</span> <span class="o">&amp;</span><span class="n">ref</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">ref</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="c1">//b를 넣엇지만, A로 작동한다.</span>
    
    <span class="c1">//virtual keyword 사용시</span>
    <span class="c1">//B출력</span>
    <span class="c1">//A의 함수가 virtual function이면서 B의 overrding된 함수가 존재 할때 자기 자신의 함수를 호출한다.</span>
    
    
    <span class="n">A</span> <span class="o">&amp;</span><span class="n">ref2</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">ref2</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="c1">//C출력</span>
    <span class="c1">//C는 B를 상속받앗는데 왜 C가 호출이되는가?</span>
    <span class="c1">//B는 가상함수가 아닌데 왜 C가출력이 되는가?</span>
    
    
    
    <span class="n">B</span> <span class="o">&amp;</span><span class="n">ref3</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">ref3</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="c1">//A객체기 아닌 B의 객체로 c를 넣었을때도 C가 출력이 된다.</span>
    <span class="c1">//B는 가상 함수가 아닌데 왜 B가 아닌 C가 출력이 되는가?</span>
    
    
    <span class="c1">//이유</span>
    <span class="c1">//가상 함수는 가장 상위클래스의 함수가 가상함수인경우 하위 클래스의 함수도 가상함수가 된다.</span>

    
    <span class="c1">//추가 내용</span>
    <span class="c1">//오버로딩 할때 반환형이 다르면 컴파일 오류 발생</span>
    <span class="c1">//오버로딩된 가상함수가 상위클래스의 함수와 구조가 다르다고 오류 발생</span>
    
    <span class="c1">//virtual keyword는 호출할때 스택에 쌓이고 찾는게 아니라</span>
    <span class="c1">//virtual table이라는 곳에 추가가 되면서 찾아쓰는 구조이다.</span>
    <span class="c1">//그러므로 느리다.</span>
    <span class="c1">//상속의 깊이가 깊고 가상함수가 구현이 되어있다면 속도가 현저히 느려진다.</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="override-final-공변-반환값"><span class="mr-2">override, final, 공변 반환값</span><a href="#override-final-공변-반환값" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
</pre><td class="rouge-code"><pre><span class="c1">// override, final, 공변 반환값</span>
<span class="c1">// Convariant</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"A"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="n">A</span><span class="o">*</span> <span class="n">getThis</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"B"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="n">B</span><span class="o">*</span> <span class="n">getThis</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"C"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//이번에는 다형성을 사용할떄 유용한 override, final keyword에 대해 알아보자</span>
    <span class="c1">//Convariant tpye도 알아보자</span>
    
    
    <span class="c1">//앞에서본 예시와 다르게 함수에 파라미터가 추가가 되어있다.</span>
    <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">B</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">C</span> <span class="n">c</span><span class="p">;</span>
    
    <span class="n">A</span> <span class="o">&amp;</span><span class="n">ref</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">ref</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">//파라미터가 다른경우 가상함수여도 부모의 클래스함수가 호출이 된다.</span>
    
    <span class="c1">//override keyword를 함수옆에 적어주면 B 호출</span>
    <span class="c1">//override keyword</span>
    <span class="c1">//override를 사용하게 되면 함수 자체를 컴파일러에게 나 이 함수 상위클래스에있는 함수 overriding할꺼야 하고 박아버리는것이다.</span>
    <span class="c1">//그러면 컴파일러는 overriding function으로 인지를 하고 오류를 찾아준다.</span>
    <span class="c1">//상위 클래스 함수는 int인데 왜 넌 short야? 이거 고쳐 라고 알려준다.</span>
    <span class="c1">//B의 함수 파라미터를 int로 수정하면 오류가 사라지고 빌드 하면 B가 출력이 된다.</span>
    
    <span class="c1">//오버로딩할때는 override 키워드를 적어주는것이 좋다. 오류찾기도 쉬워지고</span>

    <span class="c1">//final keyword</span>
    <span class="c1">//final keyword를 함수 이름 옆에 적어주면 하위 클래스에서 override를 못하게 막는 용법이다.</span>
    
    <span class="c1">//B에서 print() final인경우 C에서 print() 구현 불가</span>
    <span class="c1">//A에서 print() final인경우 B,C 둘다 print() 구현 불가</span>

    
    <span class="c1">//Convariant Return Type</span>
    
    <span class="n">A</span> <span class="o">&amp;</span><span class="n">ref2</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span><span class="p">.</span><span class="n">getThis</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">print</span><span class="p">();</span>     <span class="c1">//B출력</span>
    <span class="c1">//B의 getThis()실행 후 B 출력</span>
    <span class="n">ref2</span><span class="p">.</span><span class="n">getThis</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">print</span><span class="p">();</span>  <span class="c1">//A출력</span>
    <span class="c1">//B의 getThis()실행이 되지만 A 출력</span>
    <span class="c1">//왜 A의 getThis()가 아니라 B의 getThis()가 호출이 될까?</span>
    <span class="c1">//ref2가 A이므로 B의 getthis()로 B의 포인터를 반환을 해주어도 내부적으로 A로 다시 바꾼후 호출하는 구조이다.</span>
    
    
    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">getThis</span><span class="p">()).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//class B</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">ref2</span><span class="p">.</span><span class="n">getThis</span><span class="p">()).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//class A</span>
    
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="가상-소멸자"><span class="mr-2">가상 소멸자</span><a href="#가상-소멸자" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre><td class="rouge-code"><pre><span class="c1">// 가상 소멸자</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"~Base()"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">m_array</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="n">Derived</span><span class="p">(</span><span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">length</span><span class="p">];</span>
    <span class="p">}</span>
    
    <span class="o">~</span><span class="n">Derived</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"~Derived()"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">delete</span> <span class="p">[]</span> <span class="n">m_array</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//이번에는 가상 소멸자에 대해 알아보자</span>
    
    <span class="c1">//상속 구조에서 생성자는 자식클래스에서 자신의 생성자를 사용하지만</span>
    <span class="c1">//소멸자는 가상 소멸자를사용하는것이좋다.</span>
    
    
<span class="c1">//    Derived derived(5);</span>
    <span class="c1">//자식 소멸자 호출후 부모 소멸자 호출</span>
    
    <span class="n">Derived</span> <span class="o">*</span><span class="n">derived2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">Base</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">derived2</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">base</span><span class="p">;</span>
    <span class="c1">//부모클래스는 자식클래스가 무엇으로부터 만들어졌는지 모르므로</span>
    <span class="c1">//base포인터를 이용하여 제거를 시도를 한다.</span>
    <span class="c1">//~Base()만 실행이된다.</span>
    
     
    <span class="c1">//동물예시</span>
    <span class="c1">//부모 클래스 - 동물</span>
    <span class="c1">//자식 클래스 - 개, 고양이, 닭, 소 등등존재</span>
    <span class="c1">//개 고양이 닭 소가 존재하는 Derived 객체를 Base 포인터에 넣어 다형성을 형성하였다고 하자.</span>
    <span class="c1">//그러면 동적할당을 제거할때 Derived에서 개, 고양이, 닭, 소 4개의 종류를 하나하나 지우는것보다 Base에서 한번에 지우는게 좋아보인다.</span>
    
    <span class="c1">//소멸자를 virtual로 만들면</span>
    <span class="c1">//자식 소멸자 호출후, 부모 소멸자가 호출이 된다.</span>
    
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="동적-바인딩과-정적-바인딩"><span class="mr-2">동적 바인딩과 정적 바인딩</span><a href="#동적-바인딩과-정적-바인딩" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
</pre><td class="rouge-code"><pre><span class="c1">// 동적 바인딩과 정적 바인딩</span>
<span class="c1">// binding</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">substact</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">multiply</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//이번에는 동적 바인딩과 정적 바인딩에 대해 알아보자</span>
    <span class="c1">//가상함수를 이용하는 다형성이 내부적으로 어떤식으로 실행이 되는지 이해하려면 동적 바인딩, 정적 바인딩의 차이를 이해하면된다.</span>
    
    
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span><span class="p">;</span>
    
    <span class="kt">int</span> <span class="n">op</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"0 : add, 1 : substact, 2: multiply"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">op</span><span class="p">;</span>
    
    
    <span class="c1">//static binding (early binding)</span>
    <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">substact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
            
    <span class="p">}</span>
    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//변수명이나 함수명이 깔끔하게 빌드타임에 정의가 되어있는경우를 정적 바인딩이라고 한다.</span>
    
    <span class="c1">//Dynamic binding (late binding)</span>
    
    <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">func_ptr</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="c1">//function pointer</span>
    <span class="c1">//함수에 대한 포인터</span>
    <span class="c1">//컴파일 타임에 변수가 결정이 되어있지 않다.</span>
    
    <span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//op가 결정이 되고나서 func_ptr의 주소가 결정이 된다.</span>
        <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">func_ptr</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">func_ptr</span> <span class="o">=</span> <span class="n">substact</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">func_ptr</span> <span class="o">=</span> <span class="n">multiply</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">func_ptr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//func_ptr에 저장된 함수 주소가 할당이 된 함수를 실행 하는방법 - 간접적인 방법</span>
    
    
    <span class="c1">//차이점</span>
    <span class="cm">/*
     속도 정적바인딩이 더빠르다.
     변수가 다 정해져있으므로 빠르다.
    
     동적 바인딩은 함수가 안정해져있고, 함수를 실행할때도 포인터의 주소를 거쳐서 함수를 호출하기 때문에 느리다.
     
     속도는 느리지만, 동적 바인딩을 사용하면 프로그래밍이 유연해진다.
     
     자유도가 높아진다.     
    */</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="가상-함수-테이블"><span class="mr-2">가상 함수 테이블</span><a href="#가상-함수-테이블" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre><td class="rouge-code"><pre><span class="c1">// 가상 함수 표</span>
<span class="c1">// Virtual Tables</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fun1</span><span class="p">()</span> <span class="p">{};</span>
     <span class="kt">void</span> <span class="n">fun2</span><span class="p">()</span> <span class="p">{};</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
     <span class="kt">void</span> <span class="n">fun1</span><span class="p">()</span> <span class="p">{};</span>
     <span class="kt">void</span> <span class="n">fun3</span><span class="p">()</span> <span class="p">{};</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//이번에는 가상함수 표에 대해 알아보자</span>
    <span class="c1">//이전에 다형성 사용시 가상함수는 느릴수도있는 이유가 스택에 쌓여서 진행하는것이 아니라, 가상함수표에 쌓이고 찾아오는 방식이라고 하였다.</span>
    
    
    <span class="c1">//가상함수가 선언이 되면 함수 포인터가 생성이되고 가상함수표를 만들고 동적 바인딩을 한다.</span>
    
    <span class="c1">//가상함수가 없으면 함수 포인터도 존재하지않고 정적 바인딩을 한다.</span>
    
    <span class="cm">/*
     Base - virtual fun1(), virtual fun2(), FunctionPointer *_vptr;
     Derived - virtual fun1(), FunctionPointer *_vptr;
     
     부모 클래스의 경우
     Base 객체를 만들고 fun1을 호출하게 되면 가상함수에 관한 포인터를 이용하여 가상함수 표를 찾는다.
     여기서 가상함수표에는 fun1()과 같은 포인터와 func2()과 같은 포인터를 가지고있다.
     
     가상함수표에서 fun1() 포인터를 찾고 그 포인터가 가르키고 있는 fun1()에 접근하여 fun1()을 실행한다.
     
     자식 클래스의 경우
     Derived 객체를 만들고 fun1을 호출하게 되면 가상함수에 관한 포인터를 이용하여 가상함수 표를 찾는다.
     여기서 가상함수표에는 fun1()과 같은 포인터와 fun2()과 같은 포인터를 가지고있다.
     Derived에는 가상함수가 fun1()밖에 없는데 어떻게 fun2()도 가지고있냐? 부모쪽에서 fun2()가 가상함수이므로 만들어져 있던 것이다.
     
     가상함수표에서 fun1() 포인터를 찾고 그 포인터가 가르키고 있는 fun1()에 접근하여 fun1()을 실행한다.
     여기까지는 부모클래스가 자기자신의 객체를 만들어서 사용하는것과 같다.
     
     하지만, 자식클래스에 없는 가상함수 fun2()를 호출하게 된다면 어떻게 될까??
     가상함수표에서 fun2() 포인터를 찾고 그 포인터가 가르키고 있는 부모 클래스에 존재하는fun2()에 접근하여 fun2()을 실행한다.
     
     자식클래스로 만들어진객체를 부모클래스의 포인터,참조로 넣어도 가상함수 표는 유지가 되기 때문에 다형성으로 사용 가능한것이다.
    
     */</span>
    
    
    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Base</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Derived</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//가상 함수가아닌경우</span>
    <span class="c1">//1</span>
    <span class="c1">//1 출력</span>
    <span class="c1">//가상 함수가 아닌경우 최소한의데이터만 생성하므로 1이 발생</span>
    
    <span class="c1">//가상 함수인경우</span>
    <span class="c1">//8</span>
    <span class="c1">//8 출력</span>
    <span class="c1">//가상함수를 사용하면 함수포인터가 발생한다고 하였다.</span>
    <span class="c1">//그래서 포인터의 크기가 출력이 된것이다.</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="순수-가상-함수-추상-기본-클래스-인터페이스-클래스"><span class="mr-2">순수 가상 함수, 추상 기본 클래스, 인터페이스 클래스</span><a href="#순수-가상-함수-추상-기본-클래스-인터페이스-클래스" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
</pre><td class="rouge-code"><pre><span class="c1">// 순수 가상함수, 추상기본클래스, 인터페이스클래스</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Animal</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="n">string</span> <span class="n">m_name</span><span class="p">;</span>
    
<span class="nl">public:</span>
    <span class="n">Animal</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span><span class="o">:</span> <span class="n">m_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="p">{}</span>
    
    <span class="n">string</span> <span class="n">getName</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">m_name</span><span class="p">;</span> <span class="p">}</span>
    
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">speak</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//Pure virtual function</span>
    <span class="c1">//바디가 없고 등호 = 0 으로 사용한다.</span>
    <span class="c1">//자식 클래스에서 이 함수를 반드시 구현해라 라는의미이다.</span>
    
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Cat</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Cat</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span> <span class="o">:</span> <span class="n">Animal</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="p">{}</span>
    
    <span class="kt">void</span> <span class="n">speak</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m_name</span> <span class="o">&lt;&lt;</span> <span class="s">" Meow "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Dog</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Dog</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span> <span class="o">:</span> <span class="n">Animal</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="p">{}</span>
    
    <span class="kt">void</span> <span class="n">speak</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m_name</span> <span class="o">&lt;&lt;</span> <span class="s">" Woof "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Cow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Cow</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span> <span class="o">:</span> <span class="n">Animal</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="p">{}</span>
    
    <span class="kt">void</span> <span class="n">speak</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m_name</span> <span class="o">&lt;&lt;</span> <span class="s">" Moooo "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//이번에는 순수 가상 함수, 추상기본 클래스, 인터페이스 클래스에 대해알아보자.</span>
    
    <span class="c1">//지금까지는 다형성에서 가상함수를 구현할때 자식클래스에서 자신에게 적합한 함수를 오버라이딩하는 관점에 대해 배웠다.</span>
    
    <span class="c1">//이번에는 설계관점에서 기본클래스에서 자식 클래스에 제약을 만들고 강제하는 방법에대해 알아보자.</span>
    
    <span class="cm">/*
     1.순수 가상 함수 Pure Virtual Function
     바디가 존재하지 않음
     자식 클래스에서 반드시 오버라이딩 필요
     
     2.추상 클래스 Abstract Calss
     순수가상 함수가 포함된 클래스이다.
     
     3.인터페이스 클래스 Interface Class
     순수 가상 함수로만 이루어진 클래스이다.
    
     */</span>
    
    
    <span class="c1">//앞에선 Animal 예시를 가져와 고쳐보자</span>
    
    
    <span class="c1">//Animal ani("Hi");</span>
    <span class="c1">//순수 가상함수가 존재하는 추상클래스는 인스턴스를 만들지 못한다.</span>
    
    
    <span class="n">Cow</span> <span class="n">cow</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
    <span class="c1">//speak()가 구현이 안되어있어서 오류 발생</span>
    <span class="c1">//speak()가 추상적이야~ 라고 오류를 뱉는다.</span>
    
    <span class="n">cow</span><span class="p">.</span><span class="n">speak</span><span class="p">();</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>인터페이스 클래스 예시</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre><td class="rouge-code"><pre><span class="c1">// 순수 가상함수, 추상기본클래스, 인터페이스클래스</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">//인터페이스 클래스 예시</span>
<span class="k">class</span> <span class="nc">IErrorLog</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">//순수 가상 함수</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">reportError</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">errorMessage</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IErrorLog</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">FileErrorLog</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IErrorLog</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">reportError</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">errorMessage</span><span class="p">)</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Writing error to a file"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ConsoleErrorLog</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IErrorLog</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">reportError</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">errorMessage</span><span class="p">)</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Printing error to a console"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">//인터페이스라고 부르는이유</span>
<span class="c1">//외부에서 사용할때 기능을 예측하는 인터페이스 역할을 한다.</span>

<span class="c1">//인터페이스 클래스의 자식들은 무조건 순수 가상함수를 구현을 해주어야한다.</span>

<span class="kt">void</span> <span class="n">doSomething</span><span class="p">(</span><span class="n">IErrorLog</span> <span class="o">&amp;</span> <span class="n">log</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">log</span><span class="p">.</span><span class="n">reportError</span><span class="p">(</span><span class="s">"RunTime error!"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    
    <span class="n">cow</span><span class="p">.</span><span class="n">speak</span><span class="p">();</span>
    
    
    <span class="n">FileErrorLog</span> <span class="n">file_log</span><span class="p">;</span>
    <span class="n">ConsoleErrorLog</span> <span class="n">console_log</span><span class="p">;</span>
    
    <span class="n">doSomething</span><span class="p">(</span><span class="n">file_log</span><span class="p">);</span>
    <span class="n">doSomething</span><span class="p">(</span><span class="n">console_log</span><span class="p">);</span>
    <span class="c1">//파라미터가 IErrorLog이지만 FileErrorLog,ConsoleErrorLog 둘다 IErrorLog의 상속을 받는 관계이므로 사용이 가능하다.</span>
    <span class="c1">//재사용이 유용하다.</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><h2 id="가상-기본-클래스와-다이아몬드-상속-문제"><span class="mr-2">가상 기본 클래스와 다이아몬드 상속 문제</span><a href="#가상-기본-클래스와-다이아몬드-상속-문제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre><td class="rouge-code"><pre><span class="c1">// 가상 기본 클래스와 다이아몬드 상속 문제</span>
<span class="c1">// virtual base class</span>
<span class="c1">// the diamond problem</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">PoweredDevice</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">m_i</span><span class="p">;</span>
    
    <span class="n">PoweredDevice</span><span class="p">(</span><span class="kt">int</span> <span class="n">power</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"PoweredDevice: "</span> <span class="o">&lt;&lt;</span> <span class="n">power</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Scanner</span> <span class="o">:</span><span class="k">virtual</span> <span class="k">public</span> <span class="n">PoweredDevice</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Scanner</span><span class="p">(</span><span class="kt">int</span> <span class="n">scanner</span><span class="p">,</span> <span class="kt">int</span> <span class="n">power</span><span class="p">)</span> <span class="o">:</span> <span class="n">PoweredDevice</span><span class="p">(</span><span class="n">power</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Scanner: "</span> <span class="o">&lt;&lt;</span> <span class="n">scanner</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="k">class</span> <span class="nc">Printer</span> <span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">PoweredDevice</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Printer</span><span class="p">(</span><span class="kt">int</span> <span class="n">printer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">power</span><span class="p">)</span> <span class="o">:</span> <span class="n">PoweredDevice</span><span class="p">(</span><span class="n">power</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Printer: "</span> <span class="o">&lt;&lt;</span> <span class="n">printer</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Copier</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Scanner</span><span class="p">,</span> <span class="k">public</span> <span class="n">Printer</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Copier</span><span class="p">(</span><span class="kt">int</span> <span class="n">scanner</span><span class="p">,</span> <span class="kt">int</span> <span class="n">printer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">power</span><span class="p">)</span> <span class="o">:</span> <span class="n">Scanner</span><span class="p">(</span><span class="n">scanner</span><span class="p">,</span> <span class="n">power</span><span class="p">),</span> <span class="n">Printer</span><span class="p">(</span><span class="n">printer</span><span class="p">,</span> <span class="n">power</span><span class="p">),</span> <span class="n">PoweredDevice</span><span class="p">(</span><span class="n">power</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//이번에는 가상 기본 클래스와 다이아몬드 상속문제에 대해 알아보자</span>
    
    <span class="c1">//앞에서 다중상속 부분에서 상속을 할때 다이아몬드 구조로 만들면 위험해진다고 했엇다.</span>
    
    <span class="c1">//다이아몬드 문제를 해결하기 위해 가상 기본 클래스를 이용한다.</span>
    
    <span class="n">Copier</span> <span class="n">cop</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">cop</span><span class="p">.</span><span class="n">Scanner</span><span class="o">::</span><span class="n">PoweredDevice</span><span class="o">::</span><span class="n">m_i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">cop</span><span class="p">.</span><span class="n">Printer</span><span class="o">::</span><span class="n">PoweredDevice</span><span class="o">::</span><span class="n">m_i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//주소가 같다</span>
    <span class="c1">// 상속 받는 클래스에 vietual을 붙여주면 주소가 같아진다.</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><h2 id="객체-잘림과-reference-wrapper"><span class="mr-2">객체 잘림과 reference wrapper</span><a href="#객체-잘림과-reference-wrapper" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
</pre><td class="rouge-code"><pre><span class="c1">// 객체 잘림과 reference_wrapper</span>
<span class="c1">// object slicing</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">m_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I'm Base"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">m_j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I'm Derived"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">doSomething</span><span class="p">(</span><span class="n">Base</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">b</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">doSomething2</span><span class="p">(</span><span class="n">Base</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">b</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//이번에는 상속관계에서 객체 잘림 현상에 대해 알아보자</span>
    
    <span class="c1">//상속의 구조를 보았을때 부모보다 자식의 정보가 더 많이 가지고있다.</span>
    <span class="c1">//자식 클래스에는 일반화된 구조의 부모에서 추가적인 기능을 구현을 하기 때문에 추가적인 변수 함수들이 존재한다.</span>
    <span class="c1">//만약에 부모의 객체에 자식의 객체를 강제로 대입하게 되면 자식클래스보다 부모클래스의 정보가 적기 때문에 사라지게 된다.</span>
    <span class="c1">//이것을 객체 잘림이라고 한다.</span>
    
    
    <span class="c1">//객체 잘림을 방지하기 위한 방법이 reference_wrapper이다.</span>
    
    
    <span class="n">Derived</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">Base</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
    <span class="c1">//부모 클래스에 자식객체를 대입하여 다형성 발생</span>
    
    <span class="n">b</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="c1">//Derived print;</span>
    
    <span class="n">Base</span> <span class="n">b2</span><span class="p">;</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
    <span class="c1">//&amp;를 사용 안하게 되면 단순 복사 대입이므로</span>
    <span class="c1">//b에는 d의 정보를 담을수가없다.</span>
    <span class="c1">//m_j가 추가된 정보를 가질수가없어서 사라지게 된다.</span>
    
<span class="c1">//    b2.m_j = 10; 사용불가</span>
    
    
    <span class="n">b2</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="c1">//Base 출력</span>
    <span class="c1">//복사하는 과정에서 자식클래스의 정보를 가져오지못하여 오버로딩된 함수를 사용하지못하고 자기자신의 함수를 호출한다.</span>
    
    
    <span class="n">doSomething</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
    <span class="c1">//파라미터가 참조 변수이므로 Derived 출력</span>
    
    <span class="n">doSomething2</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
    <span class="c1">//파라미터가 참조 변수가 아니므로 복사 대입이 발생하여</span>
    <span class="c1">//마찬가지로 Base가 출력이 된다.</span>
    
    
    <span class="c1">//흔한 실수 예시 vector</span>
    
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span> <span class="n">my_vec</span><span class="p">;</span>
    <span class="n">my_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="n">my_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span> <span class="n">ele</span> <span class="o">:</span> <span class="n">my_vec</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ele</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="c1">//모든 객체가 Base출력</span>

    
    <span class="cm">/*
     vector&lt;Base&amp;&gt; my_vec;
    my_vec.push_back(b);
    my_vec.push_back(d);
    
    for (auto &amp; ele : my_vec) {
        ele.print();
    }
     vector에선 &amp;사용 불가
    */</span>
        
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">*&gt;</span> <span class="n">my_vec2</span><span class="p">;</span>
    <span class="n">my_vec2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b2</span><span class="p">);</span>
    <span class="n">my_vec2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
   
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span> <span class="n">ele</span> <span class="o">:</span> <span class="n">my_vec2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ele</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">();</span>
   <span class="p">}</span>
    <span class="c1">//Base Derived 둘다 출력 성공</span>
    
    <span class="c1">//참조를 사용하는 방법</span>
    <span class="c1">//functional Library 사용</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">reference_wrapper</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;&gt;</span> <span class="n">my_vec3</span><span class="p">;</span>
    <span class="c1">//vector&lt;Base&amp;&gt; my_vec3 처럼 작동한다.</span>
    <span class="n">my_vec3</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">b2</span><span class="p">);</span>
    <span class="n">my_vec3</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
   
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span> <span class="n">ele</span> <span class="o">:</span> <span class="n">my_vec3</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ele</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">print</span><span class="p">();</span>
   <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="동적-형변환"><span class="mr-2">동적 형변환</span><a href="#동적-형변환" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
</pre><td class="rouge-code"><pre><span class="c1">// 동적 형변환</span>
<span class="c1">// Dynamic Casting</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">m_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I'm Base"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">m_j</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
    
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I'm Derived"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">string</span> <span class="n">m_name</span> <span class="o">=</span> <span class="s">"Dr. Two"</span><span class="p">;</span>
    
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I'm Derived"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//이번에는 동적 형변환에 대해 알아보자</span>
    
    <span class="c1">//다형성을 사용할때 종종  자식클래스의 포인터를 부모클래스의 포인터로 바꾸고 나중에 다시 자식클래스의 포인터로 바꿔야하는 경우가생긴다.</span>
    <span class="c1">//이때 사용하는것이 동적 형변환이다.</span>
    
    
    <span class="n">Derived1</span> <span class="n">d1</span><span class="p">;</span>
    <span class="n">Base</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d1</span><span class="p">;</span>
    
    <span class="c1">//base에 d1의 주소를 넣어주었다.</span>
    <span class="c1">//base-&gt;m_j에 접근불가</span>
    <span class="c1">//base를 다시 Derived1으로 형변환을 해야하는 경우가 발생한다면. 동적 형변환을 사용하면 된다</span>
    
    <span class="c1">//동적 형변환은 이런식으로 구현한다.</span>
    <span class="k">auto</span> <span class="o">*</span><span class="n">base_to_d1</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived1</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">base_to_d1</span><span class="o">-&gt;</span><span class="n">m_j</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//Derived1으로 형변환을 하여서 m_j에 접근이 가능하게 되었다.</span>
    
    
    <span class="c1">//동적형변환을 하는경우는 되도록 안하게 구현하는것이 좋다.</span>
    <span class="c1">//변수의 자료형이 왔다 갔다 하는것이 많아지면 코드도 복잡해지고 나중에 유지보수도 힘들어진다.</span>
    
    
    
    
    <span class="k">auto</span> <span class="o">*</span><span class="n">base_to_d2</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived2</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>

    <span class="c1">//그냥 출력하게 되면 오류가 발생한다.</span>
    <span class="c1">//이유</span>
    <span class="c1">//동적 형변환이 실패가 되면 nullptr을 반환한다.</span>
    <span class="k">if</span><span class="p">(</span><span class="n">base_to_d2</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">base_to_d2</span><span class="o">-&gt;</span><span class="n">m_name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    
    <span class="c1">//원인</span>
    <span class="c1">//Dervied1의 주소를 가진 base가 Derived2로 형변환을 하게 되어 오류가 발생한것이다.</span>
    
    <span class="c1">//정적 형변환도 되긴하지만 오류를 발생하지않는다.</span>
    
    <span class="k">auto</span> <span class="o">*</span><span class="n">base_to_d3</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Derived1</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">base_to_d3</span><span class="o">-&gt;</span><span class="n">m_j</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    
    <span class="k">auto</span> <span class="o">*</span><span class="n">base_to_d4</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Derived2</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">base_to_d4</span><span class="o">-&gt;</span><span class="n">m_name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="유도-클래스에서-출력-연산자-사용하기"><span class="mr-2">유도 클래스에서 출력 연산자 사용하기</span><a href="#유도-클래스에서-출력-연산자-사용하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre><td class="rouge-code"><pre><span class="c1">// 유도 클래스에서 출력 연산자 사용하기</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Base</span><span class="p">()</span> <span class="p">{}</span>
    
    <span class="c1">//멤버 함수가 아니므로 오버라이딩 불가</span>
    <span class="k">friend</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Base</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//print()를 만들고 print에서 출력하도록 한다.</span>
        <span class="k">return</span> <span class="n">b</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">virtual</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">print</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">"Base"</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Derived</span><span class="p">()</span> <span class="p">{}</span>
    
    <span class="k">virtual</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">print</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">"Derived"</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">};</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//다형성은 여러가지로 유용하지만 모든경우에 다형성을 사용할수없다.</span>
    
    <span class="c1">//대표적인 예시 - 출력 연산자</span>
    <span class="c1">//출력 연산자는 오버라이딩이 불가능하다.</span>
    
    <span class="c1">//다형성으로 출력 연산자를 사용하는 방법</span>
    
    <span class="n">Base</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    
    <span class="n">Derived</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    
    <span class="n">Base</span> <span class="o">&amp;</span><span class="n">bref</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bref</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    
    <span class="c1">//자식 클래스의 print()를 이용하여 마치 &lt;&lt; operator가 오버라이딩 된것처럼 작동한다.</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/language/'>Language</a>, <a href='/categories/c/'>C++</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >c++</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%5BC%2B%2B%5D+Chapter.12+%EA%B0%80%EC%83%81+%ED%95%A8%EC%88%98%EB%93%A4+-+YdO-ObY&url=https%3A%2F%2Fydo-oby.github.io%2F%2Fposts%2FCpp-Ch12%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%5BC%2B%2B%5D+Chapter.12+%EA%B0%80%EC%83%81+%ED%95%A8%EC%88%98%EB%93%A4+-+YdO-ObY&u=https%3A%2F%2Fydo-oby.github.io%2F%2Fposts%2FCpp-Ch12%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fydo-oby.github.io%2F%2Fposts%2FCpp-Ch12%2F&text=%5BC%2B%2B%5D+Chapter.12+%EA%B0%80%EC%83%81+%ED%95%A8%EC%88%98%EB%93%A4+-+YdO-ObY" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Day1/">[개발일지] 1일차 개발일지 작성시작</a><li><a href="/posts/Day2/">[개발일지] 2일차 개발일지 - 기획시작 1</a><li><a href="/posts/Cpp-Ch10/">[C++] Chapter.10 객체들 사이의 관계에 대해</a><li><a href="/posts/Cpp-Ch15/">[C++] Chapter.15 의미론적 이동과 스마트포인터</a><li><a href="/posts/Cpp-Ch14/">[C++] Chapter.14 예외처리</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/github-pages/">github pages</a> <a class="post-tag" href="/tags/jekyll/">jekyll</a> <a class="post-tag" href="/tags/c/">c#</a> <a class="post-tag" href="/tags/unity/">unity</a> <a class="post-tag" href="/tags/chripy/">chripy</a> <a class="post-tag" href="/tags/github/">github</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Cpp-Ch13/"><div class="card-body"> <em class="small" data-ts="1664025619" data-df="ll" > Sep 24, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[C++] Chapter.13 템플릿</h3><div class="text-muted small"><p> 함수 템플릿 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // 함수 템플릿 #include &amp;lt;...</p></div></div></a></div><div class="card"> <a href="/posts/Cpp-Ch14/"><div class="card-body"> <em class="small" data-ts="1664025619" data-df="ll" > Sep 24, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[C++] Chapter.14 예외처리</h3><div class="text-muted small"><p> 예외처리의 기본 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 ...</p></div></div></a></div><div class="card"> <a href="/posts/Cpp-Ch15/"><div class="card-body"> <em class="small" data-ts="1664025619" data-df="ll" > Sep 24, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[C++] Chapter.15 의미론적 이동과 스마트포인터</h3><div class="text-muted small"><p> 이동의 의미와 스마트 포인터 main.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Cpp-Ch11/" class="btn btn-outline-primary" prompt="Older"><p>[C++] Chapter.11 상속</p></a> <a href="/posts/Cpp-Ch13/" class="btn btn-outline-primary" prompt="Newer"><p>[C++] Chapter.13 템플릿</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/YdO-ObY">YdO-ObY</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/github-pages/">github pages</a> <a class="post-tag" href="/tags/jekyll/">jekyll</a> <a class="post-tag" href="/tags/c/">c#</a> <a class="post-tag" href="/tags/unity/">unity</a> <a class="post-tag" href="/tags/chripy/">chripy</a> <a class="post-tag" href="/tags/github/">github</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
