<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.1" /><meta property="og:title" content="[C++] Chapter.11 상속" /><meta property="og:locale" content="en" /><meta name="description" content="A minimal, responsive, and powerful Jekyll theme for presenting professional writing." /><meta property="og:description" content="A minimal, responsive, and powerful Jekyll theme for presenting professional writing." /><link rel="canonical" href="https://ydo-oby.github.io//posts/Cpp-Ch11/" /><meta property="og:url" content="https://ydo-oby.github.io//posts/Cpp-Ch11/" /><meta property="og:site_name" content="YdO-ObY" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-09-24T22:20:19+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[C++] Chapter.11 상속" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-10-13T00:51:50+09:00","datePublished":"2022-09-24T22:20:19+09:00","description":"A minimal, responsive, and powerful Jekyll theme for presenting professional writing.","headline":"[C++] Chapter.11 상속","mainEntityOfPage":{"@type":"WebPage","@id":"https://ydo-oby.github.io//posts/Cpp-Ch11/"},"url":"https://ydo-oby.github.io//posts/Cpp-Ch11/"}</script><title>[C++] Chapter.11 상속 | YdO-ObY</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="YdO-ObY"><meta name="application-name" content="YdO-ObY"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar3.PNG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">YdO-ObY</a></div><div class="site-subtitle font-italic">나의 공부기록</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/YdO-ObY" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[C++] Chapter.11 상속</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[C++] Chapter.11 상속</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1664025619" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Sep 24, 2022 </em> </span> <span> Updated <em class="" data-ts="1665589910" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Oct 13, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/YdO-ObY">YdO-ObY</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5750 words"> <em>31 min</em> read</span></div></div></div><div class="post-content"><hr /><h2 id="상속의-기본1"><span class="mr-2">상속의 기본(1)</span><a href="#상속의-기본1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
</pre><td class="rouge-code"><pre><span class="c1">// 상속의 기본 1</span>
<span class="c1">// Inheritance</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Mother</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">m_i</span><span class="p">;</span>
    
<span class="nl">public:</span>
    <span class="n">Mother</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">i_in</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_i</span><span class="p">(</span><span class="n">i_in</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Mother constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">setValue</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">i_in</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_i</span> <span class="o">=</span> <span class="n">i_in</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="n">getValue</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">//객체지향의 상속</span>
<span class="c1">//부모의 사망으로 인한 상속 개념이 아니다.</span>


<span class="c1">//Mother를 상속 받는 Child class</span>
<span class="c1">//상속은 이렇게 받는다.</span>
<span class="k">class</span> <span class="nc">Child</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Mother</span> <span class="c1">//상속 : public말고 private도 가능하다.</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">double</span> <span class="n">m_d</span><span class="p">;</span>
    
<span class="nl">public:</span>
    <span class="c1">//생성자</span>
    <span class="n">Child</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">i_in</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span> <span class="n">d_in</span><span class="p">)</span> <span class="c1">// : m_i(i_in), m_d(d_in) 초기화가 안됨 Public이여도 안된다.</span>
    <span class="c1">//생성자가 존재하는 이유 메모리가 할당될때 초기화를 해줘라지, 메모리가 할당된후 값을 복사해줘가아니다.</span>
    <span class="c1">//m_i가 초기화 안되는이유 - Child를 생성할때 m_i의 메모리가 존재 하지않기 때문에</span>
    <span class="c1">//왜 메모리가없는가? 상속 관계일때 생성자의 생성순서를 알아야하는데 다음에 배우도록하자.</span>
     <span class="o">:</span> <span class="n">Mother</span><span class="p">(</span><span class="n">i_in</span><span class="p">)</span> <span class="p">,</span> <span class="n">m_d</span><span class="p">(</span><span class="n">d_in</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//초기화 리스트를 안사용하고 직접 접근한다.</span>
<span class="c1">//        Mother::setValue(i_in);</span>
<span class="c1">//        m_d = d_in;</span>
    <span class="p">}</span>
    <span class="c1">//Child를 만드려는 이유를 생각을 해보자</span>
    <span class="c1">//왜 Child가 필요한가?</span>
    <span class="c1">//Mother에서 구현해도 되는데 Child class를 왜 만들었지?</span>
    <span class="c1">//기능을 분담을 하려고</span>
    
    <span class="c1">//상속은 왜 받앗는가?</span>
    <span class="c1">//Mother의 m_i를 사용하기 위해</span>
    
    <span class="c1">//애초에 Child는 m_d 멤버 변수와, Mother의 m_i를 같이 이용하기 위해 만든 class이므로</span>
    <span class="c1">//생성자에서 Motehr의 m_i와 자신의 멤버변수인 m_d를 같이 만든다.</span>
    
    <span class="c1">//Mother에 같은 이름으로 구현이 되어있는 함수</span>
    <span class="c1">//과연 누구의 것을 실행할까?</span>
    <span class="c1">//자기 클래스에 잇는것을 우선으로 실행한다..</span>
    <span class="kt">void</span> <span class="n">setValue</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span> <span class="n">d_in</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_d</span> <span class="o">=</span> <span class="n">d_in</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">double</span> <span class="n">getValue</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_d</span><span class="p">;</span>
    <span class="p">}</span>
    
    
    <span class="kt">void</span> <span class="n">setValue</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">i_in</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span> <span class="n">d_in</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//Mother에 있는 m_i에 i_in을 넣어줄것이다.</span>
        <span class="c1">//m_i = i_in;</span>
        <span class="c1">//public변수의 경우 접근이 가능하다.</span>
        
        <span class="c1">//private는 자식에게 접근을 허용되지 않는다.</span>
        <span class="c1">//protect 키워드를 사용한다.</span>
        
        <span class="c1">//private상태이면서 자식에게는 허용하는 접근제어자이다.</span>
        
        
        <span class="c1">//private인 상태에서 사용하는 방법 - 부모의 함수를 실행하여 m_i에 값을 넣는다.</span>
        <span class="n">Mother</span><span class="o">::</span><span class="n">setValue</span><span class="p">(</span><span class="n">i_in</span><span class="p">);</span>
        
        <span class="n">m_d</span> <span class="o">=</span> <span class="n">d_in</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="k">class</span> <span class="nc">Daughter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Mother</span>
<span class="p">{</span>
    
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Son</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Mother</span>
<span class="p">{</span>
    
<span class="p">};</span>

<span class="c1">//여러 클래스에서 상속을 받을 수 있다.</span>
<span class="c1">//상속받은 클래스 - Derived class</span>
<span class="c1">//상속한 클래스 - general class</span>
<span class="c1">//클래스안에 같은 기능이 있는경우(일반화 해야하는 경우) 상속 클래스를 만든다.</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//객체 지향에서 가장 중요한 상속에 대해 알아보자</span>
    <span class="c1">//상속</span>
    <span class="c1">//is-a relationship</span>
    
    
    <span class="n">Mother</span> <span class="n">mother</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>
<span class="c1">//    mother.setValue(1024);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mother</span><span class="p">.</span><span class="n">getValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    
    <span class="n">Child</span> <span class="n">child</span><span class="p">(</span><span class="mi">1022</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
<span class="c1">//    child.setValue(128);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">child</span><span class="p">.</span><span class="n">getValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//Child는 empty class 이지만 Mother와 같이 실행이 잘 된다.</span>
    <span class="c1">//Child는 Mother에 있는 것들을 기본적으로는 모두 사용 가능하다. (동기)</span>
    <span class="c1">//캡슐화를 통하여 사용하지 못하게할 수 있다.</span>
    

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">child</span><span class="p">.</span><span class="n">Mother</span><span class="o">::</span><span class="n">getValue</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//1022 출력</span>
    
    
    
    <span class="c1">//Child에서 생성자를 만들고 정상작동 하였으나, Mother에도 생성자를 만드니 오류가 발생한다.</span>
    <span class="c1">//Child에서 생성이 될때 내부적으로 Mother의 생성자도 생성한다.</span>
    <span class="c1">//그래서 오류가 발생한 것이다.</span>
    
    <span class="c1">//Mother에 기본생성자를 만드는 방법</span>
    <span class="c1">//Child가 Mother에 넣으면서 생성자를 호출 하는 방법</span>
    <span class="c1">//: Mother(i_in) , m_d(d_in) 붙여주기</span>
    
    <span class="c1">//이번에는 상속에 대해 간단하게만 알아보았다.</span>
    <span class="c1">//어떤 오류가 발생하는지, 어떻게 상속을 구현하는지만 정리해두자</span>
    <span class="c1">//다음에 상속2에서 더 자세한 설명을 한다.</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="상속의-기본2"><span class="mr-2">상속의 기본(2)</span><a href="#상속의-기본2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>main.cpp</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
</pre><td class="rouge-code"><pre><span class="c1">// 상속의 기본(2)</span>
<span class="c1">// Inheritance</span>

<span class="c1">//#include &lt;iostream&gt; //Student 안에 Person안에 이미 라이브러리를 받아와서 삭제가능</span>
<span class="cp">#include</span> <span class="cpf">"Student.hpp"</span><span class="cp">
#include</span> <span class="cpf">"Teacher.hpp"</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//이번에는 좀더 구체적인 사례를 보고 상속을 더 깊게 알아보자</span>
    
    <span class="c1">//중복 되는 부분은 코드를 한곳에 몰아놓고 재사용하여 작업량을 줄이는것이 중요하다.</span>
    
    <span class="c1">//학생도 이름이 존재하고, 교사도 이름이 존재한다.</span>
    <span class="c1">//이름이 중복으로 존재한다.</span>
    <span class="c1">//일반화를 하면</span>
    <span class="c1">//학생과 교사는 사람이다.</span>
    <span class="c1">//앞에서 말한 상속 is-a 관계가 여기서 나온다.</span>
    <span class="c1">//Student is Person</span>
    <span class="c1">//Teacher is Person</span>
    
    <span class="c1">//일반화 - 공통적인 부분을 묶는것</span>
    <span class="c1">//Person 헤더를 만들어 학생과 교사의 공통부분을 묶어준다.</span>

    <span class="c1">//Studnet, Teacher의 생성자에서 m_name에서 오류가 발생한다.</span>
    <span class="c1">//의미</span>
    <span class="c1">//m_name은 Person안에 있는 멤버변수 이므로 m_name의 관리 책임은 person에 있다.</span>
    <span class="c1">//생성자 호출순서로 인해 Student가 생성이 될때 m_name 메모리가 아직 할당이 되어있지 않아 Person을 호출하여 간접적으로 초기화 하는방향으로 진행 해야한다.</span>
    <span class="c1">//Person에서 m_name을 초기화 해주어야한다.</span>
    
    
    
    
    <span class="c1">//Studnet, Teacher안에 iostream, string 라이브러리가 존재하므로 main에서 include없이 사용가능하다</span>
    
    <span class="n">Student</span> <span class="n">std</span><span class="p">(</span><span class="s">"Jack Jack"</span><span class="p">);</span>
    <span class="n">std</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">"Jack Jack2"</span><span class="p">);</span>


    
    <span class="n">Teacher</span> <span class="n">teacher</span><span class="p">(</span><span class="s">"Dr. H"</span><span class="p">);</span>
    <span class="n">teacher</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">"Dr. K"</span><span class="p">);</span>
    
    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">teacher</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    
    <span class="c1">//상속을 받으면 멤버 함수가 아닌데 멤버함수처럼 사용이 가능하다.</span>
    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">teacher</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    
    
    <span class="n">std</span><span class="p">.</span><span class="n">doNothing</span><span class="p">();</span>
    <span class="n">teacher</span><span class="p">.</span><span class="n">doNothing</span><span class="p">();</span>
    <span class="c1">//상속을 사용 하지않았다면 각각의 클래스에 doNothing함수를 구현을 했어야한다.</span>
    
    <span class="n">std</span><span class="p">.</span><span class="n">study</span><span class="p">();</span>
    <span class="n">teacher</span><span class="p">.</span><span class="n">teach</span><span class="p">();</span>
    <span class="c1">//study와 teach는 각 클래스의 고유 멤버 함수이다.</span>
    <span class="c1">//서로 사용 불가능하다.</span>
    
    <span class="n">Person</span> <span class="n">ps</span><span class="p">;</span>
    <span class="n">ps</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">"Test"</span><span class="p">);</span>
    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ps</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    
<span class="c1">//    ps.study();</span>
<span class="c1">//    ps.teach();</span>
    <span class="c1">//자식 클래스에 구현 되어있는것은 부모 클래스에선 사용 불가능하다.</span>
    
    
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Student.hpp</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="cm">/*
 학생 정보 헤더파일
 */</span>

<span class="cp">#pragma once
</span>
<span class="c1">//#include &lt;string&gt;</span>
<span class="c1">//#include &lt;iostream&gt;</span>

<span class="cp">#include</span> <span class="cpf">"Person.hpp"</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Student</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Person</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="c1">//std::string m_name; //학생 이름</span>
    <span class="c1">//Person에 있는 내용이므로 삭제한다.</span>
    
    <span class="kt">int</span> <span class="n">m_intel</span><span class="p">;</span>        <span class="c1">//학생 학습 능력치</span>
    
<span class="nl">public:</span>
    <span class="n">Student</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">name_in</span> <span class="o">=</span> <span class="s">"No Name"</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">intel_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">//: m_name(name_in), m_intel(intel_in)</span>
        <span class="o">:</span> <span class="n">Person</span><span class="p">(</span><span class="n">name_in</span><span class="p">),</span> <span class="n">m_intel</span><span class="p">(</span><span class="n">intel_in</span><span class="p">)</span>
    <span class="p">{}</span>
    

    <span class="c1">//Name은 Person에 있는 변수를 사용하는것이므로 함수를 옮긴것이다.</span>
    <span class="c1">//Intel은 Student의 고유 멤버 변수이다.</span>
    <span class="c1">//중복이 되지않은 기능이므로 Person에 옮길수없다.</span>
    <span class="kt">void</span> <span class="n">setIntel</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">intel_in</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_intel</span> <span class="o">=</span> <span class="n">intel_in</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">int</span> <span class="n">getIntel</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_intel</span><span class="p">;</span>
    <span class="p">}</span>

    
    <span class="kt">void</span> <span class="n">study</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" is studing"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Student</span> <span class="o">&amp;</span> <span class="n">student</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//const 함수가 아니라 오류 발생</span>
        <span class="c1">//Person의 함수에서 const 함수로 수정하면 오류가 사라진다.</span>
        <span class="c1">//일반화의 장점 한곳에서 수정을 하였는데 Student, Teacher의 같은 오류가 같이 사라졌다.</span>
        <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">student</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">student</span><span class="p">.</span><span class="n">m_intel</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>
    
    
<span class="p">};</span>

</pre></table></code></div></div><p>Teacher.hpp</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="cm">/*
 교사 정보 헤더파일
 */</span>

<span class="cp">#pragma once
</span>
<span class="c1">//#include &lt;string&gt; Person에서 이미 받아온 라이브러리 이므로 삭제해도 된다. 뭐 그냥 냅둬도 되는데 깔끔하게 보이기 위해 지우는 습관을 들여놓자</span>

<span class="cp">#include</span> <span class="cpf">"Person.hpp"</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Teacher</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Person</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="c1">//std::string m_name; //교사 이름</span>
    <span class="c1">//Person에 있는 내용이므로 삭제한다.</span>
    
<span class="nl">public:</span>
    <span class="n">Teacher</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">name_in</span> <span class="o">=</span> <span class="s">"No Name"</span><span class="p">)</span><span class="c1">// : m_name(name_in)</span>
     <span class="o">:</span> <span class="n">Person</span><span class="p">(</span><span class="n">name_in</span><span class="p">)</span>
    <span class="p">{</span>
<span class="c1">//        this-&gt;getName();</span>
<span class="c1">//        this-&gt;setName("TR");</span>
        <span class="c1">//getName, setName 정상적으로 작동한다.</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="n">teach</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" is teaching"</span>  <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Teacher</span> <span class="o">&amp;</span> <span class="n">teacher</span><span class="p">)</span>
    <span class="p">{</span>
<span class="c1">//        out &lt;&lt; teacher.m_name;</span>
        <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">teacher</span><span class="p">.</span><span class="n">getName</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>
    
    
<span class="p">};</span>
</pre></table></code></div></div><p>Person.hpp</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="cp">#pragma once
</span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_name</span><span class="p">;</span>
    
    <span class="c1">//public으로 안하는 이유 - 상속받는 곳에서 모두 사용하게 되면 어디서 뭐가 언제 바뀌었는지 확인이 불가능한 경우가 발생한다.</span>
    <span class="c1">//</span>
    
<span class="nl">public:</span>
    
    <span class="c1">//defalut 생성자가 없어서 오류 발생</span>
    
    <span class="c1">//default 생성자 생성 or 생성자에 기본값 넣어주기</span>
<span class="c1">//    Person()</span>
<span class="c1">//    : m_name("No Name")</span>
<span class="c1">//    {}</span>
    
    <span class="c1">//default 값 설정</span>
    <span class="n">Person</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">name_in</span> <span class="o">=</span> <span class="s">"No Name"</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_name</span><span class="p">(</span><span class="n">name_in</span><span class="p">)</span>
    <span class="p">{}</span>
    
    
    <span class="c1">//Studnet와 Teacher의 공통 함수인 getName, setName을 가져와서 자식 클래스에서 부모의 m_name을 건드리던것을 아예 없애 버렸다.</span>
    <span class="c1">//부모에서만 m_name을 건드리게끔 수정을 하였다.</span>
    <span class="kt">void</span> <span class="n">setName</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">name_in</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_name</span> <span class="o">=</span> <span class="n">name_in</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_name</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kt">void</span> <span class="n">doNothing</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m_name</span> <span class="o">&lt;&lt;</span> <span class="s">" is doing nothing"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    
    
<span class="p">};</span>
</pre></table></code></div></div><h2 id="유도된-클래스들의-생성-순서"><span class="mr-2">유도된 클래스들의 생성 순서</span><a href="#유도된-클래스들의-생성-순서" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
</pre><td class="rouge-code"><pre><span class="c1">// 유도된 클래스들의 생성 순서</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">//class Mother</span>
<span class="c1">//{</span>
<span class="c1">//private:</span>
<span class="c1">//    int m_i;</span>
<span class="c1">//</span>
<span class="c1">//public:</span>
<span class="c1">//    double m_d;</span>
<span class="c1">//</span>
<span class="c1">//    Mother() : m_i(1)</span>
<span class="c1">//    {</span>
<span class="c1">//        cout &lt;&lt; "Mother construction" &lt;&lt; endl;</span>
<span class="c1">//    }</span>
<span class="c1">//};</span>
<span class="c1">//</span>
<span class="c1">//</span>
<span class="c1">////Child는  Mother로부터 유도가 되었다. 고 말할수있다.</span>
<span class="c1">//class Child : public Mother</span>
<span class="c1">//{</span>
<span class="c1">//public:</span>
<span class="c1">//    double m_dc;</span>
<span class="c1">//</span>
<span class="c1">//    Child() : m_dc(1.0) // : m_d(1024) 생성자 초기화는 안되었던거 앞에서 확인을 하였다 .</span>
<span class="c1">//    {</span>
<span class="c1">//        cout &lt;&lt; "Child construction" &lt;&lt; endl;</span>
<span class="c1">////        //public인 경우 접근이 아주 쉽다.</span>
<span class="c1">////        this-&gt;m_d = 10.0;</span>
<span class="c1">////        //상속을 받은 멤버 변수를 명확하게 보여주기 위해 작성가능</span>
<span class="c1">////        Mother::m_d = 1024.0;</span>
<span class="c1">//    }</span>
<span class="c1">//</span>
<span class="c1">//</span>
<span class="c1">//</span>
<span class="c1">//};</span>


<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">A</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"A Constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">B</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"B Constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">C</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"C Constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//상속의 문법을 확인을 해보았으니, 생성이 어떤식으로 일어나는지 알아보자</span>
    
    <span class="c1">//생성자 초기화는 안되었던거 앞에서 확인을 하였다. 왜 안되는지 한번 알아보자</span>
    
    <span class="c1">//</span>
    
<span class="c1">//    Child c1;</span>
    <span class="c1">//부모 생성자 생성후 자식 생성자 생성</span>
    <span class="c1">//디버깅로 확인을해보면 Child 생성자부분으로 이동후, 생성자는 생성하지 않고 Mother생성자로 이동을 한다.</span>
    <span class="c1">//Child에서 Mother의 생성자를 호출하지 않아도 Mother의 default 생성자를 호출하는것이다.</span>
    <span class="c1">//내부적으로 자식 클래스에서 부모클래스의 생성자를 호출한다.</span>
    
    <span class="c1">//순서</span>
    <span class="c1">//부모의 클래스 초기화 후, 자기자신(자식) 클래스를 초기화를 한다.</span>
    
    
    <span class="c1">//자식 생성자에서 부모클래스의 멤버변수의 초기화를 진행하지 못하는이유</span>
    <span class="c1">//자식클래스에서는 부모클래스 메모리가 할당이 안되어있기 때문에 초기화를 못하는것이다.</span>

    <span class="c1">//그래서 앞에서 부모의 생성자를 이용하여 초기화를 했던것이다.</span>
    
    <span class="c1">//부모의 생성자를 자식 클래스에서 호출이 가능한가?</span>
    
    
    <span class="c1">//m_i를 그러면 하드코딩 방식으로만 해야하는가? , 값을 받아와서 초기화하는것은 불가능한것인가?</span>
    <span class="c1">//아니다 앞에서 이미 사용을해보았지만, 부모의 생성자를 이용하여 초기화 값을 원하는대로 조정이 가능하다.</span>
    <span class="c1">//사실은 자식 생성자의 initializer list에서는 Mother()가 숨어져있는것이다.</span>
    <span class="cm">/*
     Child() : Mother(), m_dc(10) 처럼 말이다.
     */</span>
    
    
    
    
    <span class="c1">//상속의 깊이가 존재하는경우 ABC 다단구조의 경우 생성자 생성 방식 살펴보기</span>
    
    
    <span class="n">C</span> <span class="n">c</span><span class="p">;</span>
    <span class="c1">//생성자 생성 순서</span>
    <span class="c1">//1. A의 생성자 생성</span>
    <span class="c1">//2. B의 생성자 생성</span>
    <span class="c1">//3. C의 생성자 생성</span>
    
    <span class="n">B</span> <span class="n">b</span><span class="p">;</span>
    <span class="c1">//생성자 생성 순서</span>
    <span class="c1">//1. A의 생성자 생성</span>
    <span class="c1">//2. B의 생성자 생성</span>
    
    <span class="c1">//소멸자는 생성자 생성순서와 반대로 진행이 된다.</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="유도된-클래스들의-생성과-초기화"><span class="mr-2">유도된 클래스들의 생성과 초기화</span><a href="#유도된-클래스들의-생성과-초기화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
</pre><td class="rouge-code"><pre><span class="c1">// 유도된 클래스들의 생성과 초기화</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Mother</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">m_i</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="n">Mother</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">i_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_i</span><span class="p">(</span><span class="n">i_in</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Mother construction"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Child</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Mother</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">float</span> <span class="n">m_d</span><span class="p">;</span>

    <span class="n">Child</span><span class="p">()</span> <span class="o">:</span> <span class="n">m_d</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">),</span> <span class="n">Mother</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Child construction"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"A : "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="o">~</span><span class="n">A</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Destructor A"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">B</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="n">A</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"B : "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="o">~</span><span class="n">B</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Destructor B"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">C</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="o">:</span> <span class="n">B</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"C : "</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="o">~</span><span class="n">C</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Destructor C"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//이전에 생성자의 생성자 호출 순서를 알아보았고, 이번에는 생성과 초기화를 알아보자</span>
    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Mother</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//크기 4</span>
    <span class="c1">//멤버변수 int크기</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Child</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//크기 8</span>
    <span class="c1">//자기 자신의 크기 float 4 + 부모의 크기 4로 인해 8의 크기가 된다.</span>
    
    
    <span class="c1">//Child에서 메모리 할당 될때 Mother도 모두 받을수있는 메모리를 할당 받는다.</span>
    
    
    <span class="n">C</span> <span class="n">c</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">);</span>
    
    <span class="c1">//생성자 생성 순서</span>
    <span class="c1">//A -&gt; B -&gt; C</span>
    
    <span class="c1">//소멸자 생성 순서</span>
    <span class="c1">//C -&gt; B -&gt; A</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="상속돠-접근-지정자"><span class="mr-2">상속돠 접근 지정자</span><a href="#상속돠-접근-지정자" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre><td class="rouge-code"><pre><span class="c1">//상속과 접근 지정자</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">m_public</span><span class="p">;</span>
<span class="nl">protected:</span>
    <span class="kt">int</span> <span class="n">m_protected</span><span class="p">;</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">m_private</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">protected</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Derived</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">//public, protected,private 모두 사용가능</span>
        <span class="n">m_public</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
        <span class="n">m_protected</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="c1">//        m_private = 123; 불가능</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">GrandChild</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Derived</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">GrandChild</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">//Derived : private Base인 경우 접근 불가</span>
        <span class="n">Derived</span><span class="o">::</span><span class="n">m_public</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="c1">//        Derived::m_protected;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//상속을 사용할때 public을 왜써야하는지 의문을 가졋을것이다.</span>
    <span class="c1">//이번에는 상속에 관한 접근지정자에 대해 알아보자</span>
    
    
    <span class="n">Base</span> <span class="n">base</span><span class="p">;</span>
    
    <span class="n">base</span><span class="p">.</span><span class="n">m_public</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="c1">//    base.m_protected = 123; 불가능</span>
    <span class="c1">//상속된곳에서는 사용가능</span>
    
<span class="c1">//    base.m_private = 123; 불가능</span>
    
    <span class="n">Derived</span> <span class="n">derived</span><span class="p">;</span>
    
    <span class="c1">//상속 접근제어자가 protected인 경우 public인 멤버변수에도 접근이 불가능하다.</span>
<span class="c1">//    derived.m_public = 123;</span>
<span class="c1">//    derived.m_protected = 123; 불가능</span>
<span class="c1">//    derived.m_private = 123;   불가능</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="유도된-클래스에-새로운-기능-추가하기"><span class="mr-2">유도된 클래스에 새로운 기능 추가하기</span><a href="#유도된-클래스에-새로운-기능-추가하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="c1">//유도된 클래스에 새로운 기능 추가하기</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">m_value</span><span class="p">;</span>
    
<span class="nl">public:</span>
    <span class="n">Base</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Derived</span><span class="p">(</span><span class="kt">int</span> <span class="n">valus</span><span class="p">)</span> <span class="o">:</span> <span class="n">Base</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//Base의 값을 변경을 하고자한다.</span>
    <span class="p">}</span>
    
    <span class="c1">//Base의 값을 변경을 하고자한다.</span>
    <span class="kt">void</span> <span class="n">setValue</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
<span class="c1">//        Base::m_value = value;</span>
        <span class="c1">//private라서 오류가 발생한다.</span>
        <span class="c1">//protected로 변경하면 정상작동</span>
        
        <span class="c1">//private로 된 상태에서 접근을 할수있다.</span>
        <span class="c1">//public get,set함수를 만들어서 접근을 하게 만들순있지만</span>
        <span class="c1">//이렇게하면 상위 함수를 거치기 때문에 퍼포먼스가 떨어지는 경우가 발생한다.</span>
    <span class="p">}</span>

<span class="p">};</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//이번에는 유도된 클래스(자식클래스)에 새로운 기능을 추가할때 생각해야하는것이 무엇이 있는지 알아보자</span>
    
    
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><h2 id="상속받은-함수를-오버라이딩-하기"><span class="mr-2">상속받은 함수를 오버라이딩 하기</span><a href="#상속받은-함수를-오버라이딩-하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
</pre><td class="rouge-code"><pre><span class="c1">// 상속받은 함수를 오버라리딩 하기</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="kt">int</span> <span class="n">m_value</span><span class="p">;</span>
    
<span class="nl">public:</span>
    <span class="n">Base</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="p">{}</span>
    
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I'm Base"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span> <span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Base</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"This is base output"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">double</span> <span class="n">m_d</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">Derived</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">Base</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="p">{}</span>
    
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Base</span><span class="o">::</span><span class="n">print</span><span class="p">();</span>  <span class="c1">//부모 함수 호출</span>
        
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I'm Derived"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span> <span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">Derived</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
        <span class="c1">//operator 오버로딩사용하는방법</span>
        <span class="c1">//캐스팅이 되는이유 - 자식 클래스메모리를 할당받을때 부모의 내용에 대한 메모리를 가지고있기때문에 캐스팅이 가능하다.</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"This is derived output"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//이번에는 상속관계에서의 오버라이딩을 알아보자</span>
    
    
    <span class="n">Base</span> <span class="n">base</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">base</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">base</span><span class="p">;</span>
    
    <span class="n">Derived</span> <span class="n">derived</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
    <span class="n">derived</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">derived</span><span class="p">;</span>
    <span class="c1">//자식클래스에는 print함수가 없으므로 Base의 print()를 호출함</span>
    <span class="c1">//자식클래스에 print()가 있는경우 Derived의 print()를 호출함</span>
    
    <span class="c1">//특수한 경우 자식 클래스에서 기능 수행을 하는데 부모 클래스의 기능을 수행을하고 추가적으로 자기자신의 기능을 수행하게 하고싶은 경우가 발생한다.</span>
    <span class="c1">//기능은 비슷하므로 함수 이름을 같게 만드려고 한다.</span>
    <span class="c1">//이때 함수안에 부모 함수 호출을 하게 만들면 된다.</span>
    
    <span class="c1">//</span>
    
    
    
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="상속-받은-함수를-감추기"><span class="mr-2">상속 받은 함수를 감추기</span><a href="#상속-받은-함수를-감추기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre><td class="rouge-code"><pre><span class="c1">//상속받은 함수를 감추기</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="kt">int</span> <span class="n">m_i</span><span class="p">;</span>
    
<span class="nl">public:</span>
    <span class="n">Base</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_i</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="p">{}</span>
    
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I'm Base"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">double</span> <span class="n">m_d</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">Derived</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">Base</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="p">{}</span>
    
    <span class="c1">//이걸 사용하면 Derived안에서 Base의 m_i 멤버변수는 public으로 작동한다.</span>
    <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">m_i</span><span class="p">;</span>
    
<span class="nl">private:</span>
    <span class="c1">//이걸 사용하면 Derived에서 print함수 사용 불가능하다.</span>
    <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">print</span><span class="p">;</span> <span class="c1">//괄호 필요없음 함수 이름만 적으면 된다.</span>

    
<span class="c1">//정리할때 using 붙는것들을 앞에 모두 구현하고 정리를 하는것이 좋다.</span>
    
    <span class="c1">//부모에서는 접근되지만 자식에서만 접근 불가능하게 하는방법 2</span>
    
<span class="nl">private:</span>
    <span class="c1">//아예 지우는것도 자식 클래스에서 접근 불가능하게 만들 수 있다.</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//이번에는 상속된 기능을 막는방법에 대해 알아보자</span>
    
    <span class="c1">//앞에선 상속을 하는 이유는 부무클래스의 기능을 사용하기 위해 상속을이용하엿따.</span>
    
    <span class="n">Derived</span> <span class="n">derived</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
    
    <span class="n">derived</span><span class="p">.</span><span class="n">m_i</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
    <span class="c1">//변경 불가 왜냐? protected로 되어있으므로 안된다.</span>
    
<span class="c1">//    derived.print();</span>
    <span class="c1">//부모에게 받은 public함수 이므로 사용이 가능하다</span>
     
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="다중-상속"><span class="mr-2">다중 상속</span><a href="#다중-상속" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre><td class="rouge-code"><pre><span class="c1">// 다중 상속</span>
<span class="c1">// Multiple Inheritance</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">USBDevice</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">long</span> <span class="n">m_id</span><span class="p">;</span>
    
<span class="nl">public:</span>
    <span class="n">USBDevice</span><span class="p">(</span><span class="kt">long</span> <span class="n">id</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_id</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="p">{}</span>
    
    <span class="kt">long</span> <span class="n">getID</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_id</span><span class="p">;</span> <span class="p">}</span>
    
    <span class="kt">void</span> <span class="n">plugAndPlay</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">NetworkDevice</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">long</span> <span class="n">m_id</span><span class="p">;</span>
    
<span class="nl">public:</span>
    <span class="n">NetworkDevice</span><span class="p">(</span><span class="kt">long</span> <span class="n">id</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_id</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="p">{}</span>
    
    <span class="kt">long</span> <span class="n">getID</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_id</span><span class="p">;</span> <span class="p">}</span>
    
    <span class="kt">void</span> <span class="n">networking</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">USBNetworkDevice</span> <span class="o">:</span> <span class="k">public</span> <span class="n">USBDevice</span><span class="p">,</span> <span class="k">public</span> <span class="n">NetworkDevice</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">//id가 다른경우</span>
    <span class="n">USBNetworkDevice</span><span class="p">(</span><span class="kt">long</span> <span class="n">usb_id</span><span class="p">,</span> <span class="kt">long</span> <span class="n">net_id</span><span class="p">)</span> <span class="o">:</span> <span class="n">USBDevice</span><span class="p">(</span><span class="n">usb_id</span><span class="p">),</span> <span class="n">NetworkDevice</span><span class="p">(</span><span class="n">net_id</span><span class="p">)</span>
    <span class="p">{}</span>
    
    <span class="c1">//id가 같은경우 사용 가능</span>
    <span class="n">USBNetworkDevice</span><span class="p">(</span><span class="kt">long</span> <span class="n">id</span><span class="p">)</span> <span class="o">:</span> <span class="n">USBDevice</span><span class="p">(</span><span class="n">id</span><span class="p">),</span> <span class="n">NetworkDevice</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
    <span class="p">{}</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//이번에는 다중상속에 대해 알아보자</span>
    
    
    <span class="n">USBNetworkDevice</span> <span class="n">my_device</span><span class="p">(</span><span class="mf">3.14</span><span class="p">,</span> <span class="mf">6.022</span><span class="p">);</span>
    
    <span class="c1">//각각의 부모클래스의 기능이 사용가능하다.</span>
    <span class="n">my_device</span><span class="p">.</span><span class="n">networking</span><span class="p">();</span>
    <span class="n">my_device</span><span class="p">.</span><span class="n">plugAndPlay</span><span class="p">();</span>
    
    <span class="c1">//문제 발생</span>
    <span class="c1">//중복되는 함수를 사용할때 오류가 발생한다.</span>
    
<span class="c1">//    my_device.getID();</span>
    <span class="c1">//어디서온 함수를 사용할것인가?를 모르기 때문에 오류가 발생한다.</span>
    
    <span class="n">my_device</span><span class="p">.</span><span class="n">USBDevice</span><span class="o">::</span><span class="n">getID</span><span class="p">();</span>
    <span class="n">my_device</span><span class="p">.</span><span class="n">NetworkDevice</span><span class="o">::</span><span class="n">getID</span><span class="p">();</span>
    <span class="c1">//이렇게 범위 결정 연산자를 사용하여 명확하게 구분을지어주면 해결이 된다.</span>
    
    <span class="c1">//다중상속을 다이아몬드 구조로 짜게 되면 위험할수도 있다.</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/language/'>Language</a>, <a href='/categories/c/'>C++</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >c++</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%5BC%2B%2B%5D+Chapter.11+%EC%83%81%EC%86%8D+-+YdO-ObY&url=https%3A%2F%2Fydo-oby.github.io%2F%2Fposts%2FCpp-Ch11%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%5BC%2B%2B%5D+Chapter.11+%EC%83%81%EC%86%8D+-+YdO-ObY&u=https%3A%2F%2Fydo-oby.github.io%2F%2Fposts%2FCpp-Ch11%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fydo-oby.github.io%2F%2Fposts%2FCpp-Ch11%2F&text=%5BC%2B%2B%5D+Chapter.11+%EC%83%81%EC%86%8D+-+YdO-ObY" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Day1/">[개발일지] 1일차 개발일지 작성시작</a><li><a href="/posts/Day2/">[개발일지] 2일차 개발일지 - 기획시작 1</a><li><a href="/posts/Cpp-Ch10/">[C++] Chapter.10 객체들 사이의 관계에 대해</a><li><a href="/posts/Cpp-Ch15/">[C++] Chapter.15 의미론적 이동과 스마트포인터</a><li><a href="/posts/Cpp-Ch14/">[C++] Chapter.14 예외처리</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/github-pages/">github pages</a> <a class="post-tag" href="/tags/jekyll/">jekyll</a> <a class="post-tag" href="/tags/c/">c#</a> <a class="post-tag" href="/tags/unity/">unity</a> <a class="post-tag" href="/tags/chripy/">chripy</a> <a class="post-tag" href="/tags/github/">github</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Cpp-Ch12/"><div class="card-body"> <em class="small" data-ts="1664025619" data-df="ll" > Sep 24, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[C++] Chapter.12 가상 함수들</h3><div class="text-muted small"><p> 다형성의 기본 개념 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 6...</p></div></div></a></div><div class="card"> <a href="/posts/Cpp-Ch13/"><div class="card-body"> <em class="small" data-ts="1664025619" data-df="ll" > Sep 24, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[C++] Chapter.13 템플릿</h3><div class="text-muted small"><p> 함수 템플릿 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // 함수 템플릿 #include &amp;lt;...</p></div></div></a></div><div class="card"> <a href="/posts/Cpp-Ch14/"><div class="card-body"> <em class="small" data-ts="1664025619" data-df="ll" > Sep 24, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[C++] Chapter.14 예외처리</h3><div class="text-muted small"><p> 예외처리의 기본 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Cpp-Ch10/" class="btn btn-outline-primary" prompt="Older"><p>[C++] Chapter.10 객체들 사이의 관계에 대해</p></a> <a href="/posts/Cpp-Ch12/" class="btn btn-outline-primary" prompt="Newer"><p>[C++] Chapter.12 가상 함수들</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/YdO-ObY">YdO-ObY</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/github-pages/">github pages</a> <a class="post-tag" href="/tags/jekyll/">jekyll</a> <a class="post-tag" href="/tags/c/">c#</a> <a class="post-tag" href="/tags/unity/">unity</a> <a class="post-tag" href="/tags/chripy/">chripy</a> <a class="post-tag" href="/tags/github/">github</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
